package rite.main


import model.SemRole

package inference {
	
	abstract class AtomSt {
		protected[this] var mgr = null:RoleMgr
		def roleMgr = mgr
		def register(m: RoleMgr): Unit
		
		def claim(): Unit
		def check: Boolean
	}
	
	class Subsume(a: Term, b: Term) extends AtomSt {
		
		def register(m: RoleMgr) {
			if (mgr != m) {
				mgr = m
				a.register(Set.empty[SemRole], m)
				b.register(Set.empty[SemRole], m)
				val ars = a.roles
				val brs = b.roles
				a.register(brs, m)
				b.register(ars, m)
			}
		}
		
		def claim() {
			a.claimSubsume(b)
		}
		
		def check = a.checkSubsume(b)
	}
	
	class Disjoint(a: Term, b: Term) extends AtomSt {
		
		def register(m: RoleMgr) {
			if (mgr != m) {
				mgr = m
				a.register(Set.empty[SemRole], m)
				b.register(Set.empty[SemRole], m)
				val ars = a.roles
				val brs = b.roles
				a.register(brs, m)
				b.register(ars, m)
			}
		}
		
		def claim() {
			a.claimDisjoint(b)
		}
		
		def check = a.checkDisjoint(b)
	}
	
	class NonEmpty(a: Term) extends AtomSt {
		
		def register(m: RoleMgr) {
			if (mgr != m) {
				mgr = m
				a.register(Set.empty[SemRole], m)
			}
		}
		
		def claim() {
			a.claimNonEmpty()
		}
		
		def check = a.checkNonEmpty
	}
	
	
	class UVar(val under: Term)
	
	class Schema(val uvars: Set[UVar], f: (Map[UVar, Term]) => Unit) extends AtomSt {
		
		def register(m: RoleMgr) {
			if (mgr != m) {
				mgr = m
				uvars.foreach(_.under.register(Set.empty[SemRole], m))
			}
		}
		
		private[this] class WrapIETerm(t: IETerm, rs: Set[SemRole]) extends Term {
			val roles = rs
			val tmref = t.ref
			private[inference] def register(rs: Set[SemRole], mgr: RoleMgr) {}
		}
		
		private[this] class WrapTask(f: () => Unit) extends Task {
			def run() { f() }
		}
		
		def claim() {
			
			val tmp0 = (p: Map[UVar, Term]) => mgr.ie.addTask(new WrapTask(() => f(p)))
			
			val tmp1 = (tmp0 /: uvars)((tmp, uv) => {
				(p) => {
					val dep = p.values.map(_.tmref.to).toSet
					uv.under.tmref.to.forSpecific(x => x.foreachSub(dep, y => if (!y.aux) y.ifNotEmpty(dep + x, 
						() => tmp(p + ((uv, new WrapIETerm(y, uv.under.roles)))))))
				}
			})
			
			tmp1(Map.empty[UVar, Term])
		}
		
		def check = false
	}
}
