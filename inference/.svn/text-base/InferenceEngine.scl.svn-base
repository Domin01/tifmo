package rite.main


import scala.collection.mutable
import scala.collection.immutable.Queue
import mylib.mSet
import model.SemRole

package inference {

	class InferenceEngine {
		
		private[inference] val W = new WTerm(null, this)
		
		private[this] val ws = mutable.Map((null:Set[SemRole], W))
		
		private[inference] def getW(roles: Set[SemRole]) = {
			if (ws.contains(roles)) {
				ws(roles)
			} else if (roles.size == 1) {
				ws(null)
			} else {
				val ret = new WTerm(roles, this)
				ws(roles) = ret
				ret
			}
		}
		
		private[this] var hc = false
		private[inference] def contradict(term: IETerm) {
//println(term)
//for (t <- term.supersets.tails; if !t.isEmpty; a = t.head; b <- t.tail; if a.hasDjt(b)) {
//	println("super djt: " + a + " " + b)
//}
			hc = true
		}
		def hasContradict() = {
			val ret = hc
			hc = false
			ret
		}
		
		
		private[this] var taskQueue = Queue.empty[Task]
		private[inference] def addTask(task: Task) {
			taskQueue = taskQueue.enqueue(task)
		}
		def profit() {
			while (!taskQueue.isEmpty) {
				val (task, q) = taskQueue.dequeue
				taskQueue = q
				task.run()
			}
		}
		
		private[this] var procQueue = Queue.empty[Task]
		private[inference] def addProc(proc: Task) {
			procQueue = procQueue.enqueue(proc)
		}
		def exploit() {
			profit()
			while (!procQueue.isEmpty) {
				val (proc, q) = procQueue.dequeue
				procQueue = q
				proc.run()
				profit()
			}
		}
		
		private[this] var jobQueue = Queue.empty[() => Unit]
		private[this] def addJob(job: () => Unit) {
			jobQueue = jobQueue.enqueue(job)
		}
		def explore() {
			exploit()
			while (!jobQueue.isEmpty) {
				val (job, q) = jobQueue.dequeue
				jobQueue = q
				job()
				exploit()
			}
		}
		
		private[inference] def newTerm(roles: Set[SemRole], genesis: String) = {
			//println("new Term: " + genesis)
			val w = getW(roles)
			val term = new IETerm(roles, genesis, this)
			term.subsume(w)
			term
		}
		
		private[inference] def auxTerm(roles: Set[SemRole], genesis: String) = {
			//println("aux Term: " + genesis)
			val w = getW(roles)
			val term = new AuxTerm(roles, genesis, this)
			term.subsume(w)
			term
		}
		
		private[inference] def getCP(of: Set[(IETerm, SemRole)]) = {
			val tm = IETerm.findCP(of)
			if (tm == null) {
				val roles = (Set.empty[SemRole] /: of)((a, b) => {
					if (b._2 == null) a ++ b._1.roles else a + b._2
				})
				val ntm = //if (of.forall(!_._1.aux)) {
					newTerm(roles, IETerm.genesisCP(of))
				//} else {
				//	auxTerm(roles, IETerm.genesisCP(of))
				//}
				ntm.isCP(of)
				ntm
			} else {
				tm
			}
		}
		
		private[inference] def getIN(of: Set[IETerm]) = {
			val tm = IETerm.findIN(of)
			if (tm == null) {
				val ntm = //if (of.forall(!_.aux)) {
					newTerm(of.head.roles, IETerm.genesisIN(of))
				//} else {
				//	auxTerm(of.head.roles, IETerm.genesisIN(of))
				//}
				ntm.isIN(of)
				ntm
			} else {
				tm
			}
		}
		
		private[inference] def getPI(of: IETerm, rs: Set[SemRole]) = {
			val tm = IETerm.findPI(of, rs)
			if (tm == null) {
				val ntm = //if (!of.aux) {
					newTerm(if (rs.size == 1) null else rs, IETerm.genesisPI(of, rs))
				//} else {
				//	auxTerm(if (rs.size == 1) null else rs, IETerm.genesisPI(of, rs))
				//}
				ntm.isPI(of, if (rs.size == 1) rs.head else null)
				ntm
			} else {
				tm
			}
		}
		
		private[inference] def auxPI(of: IETerm, rs: Set[SemRole]) = {
			val tm = IETerm.findPI(of, rs)
			if (tm == null) {
				val ntm = //if (!of.aux) {
					auxTerm(if (rs.size == 1) null else rs, IETerm.genesisPI(of, rs))
				//} else {
				//	auxTerm(if (rs.size == 1) null else rs, IETerm.genesisPI(of, rs))
				//}
				ntm.isPI(of, if (rs.size == 1) rs.head else null)
				ntm
			} else {
				//tm.setAux()
				tm
			}
		}
		
		private[inference] def constructCP(of: Set[(IETerm, SemRole)], 
				dep: Set[IETerm], f: (IETerm) => Unit) {
			if (dep.forall(x => x.ref.to == x)) {
				val pre = IETerm.findCP(of)
				if (pre != null) {
					f(pre)
				} else {
					val ofr = of.map(x => (x._1.ref, x._2))
					addJob(() => {
						if (dep.forall(x => x.ref.to == x)) {
							val cof = ofr.map(x => (x._1.to, x._2))
							val tm = IETerm.findCP(cof)
							val p = if (tm == null) {
								val roles = (Set.empty[SemRole] /: cof)((a, b) => {
									if (b._2 == null) a ++ b._1.roles else a + b._2
								})
								val ntm = auxTerm(roles, IETerm.genesisCP(cof))
								ntm.isCP(cof)
								ntm
							} else {
								tm
							}
							f(p)
						}
					})
				}
			}
		}
		
		private[inference] def constructIN(of: Set[IETerm], 
				dep: Set[IETerm], f: (IETerm) => Unit) {
			if (dep.forall(x => x.ref.to == x)) {
				val pre = IETerm.findIN(of)
				if (pre != null) {
					f(pre)
				} else {
					val ofr = of.map(_.ref)
					addJob(() => {
						if (dep.forall(x => x.ref.to == x)) {
							val cof = ofr.map(_.to)
							val tm = IETerm.findIN(cof)
							val p = if (tm == null) {
								val ntm = auxTerm(cof.head.roles, IETerm.genesisIN(cof))
								ntm.isIN(cof)
								ntm
							} else {
								tm
							}
							f(p)
						}
					})
				}
			}
		}
		
		private[inference] def constructPI(of: IETerm, rs: Set[SemRole], 
				dep: Set[IETerm], f: (IETerm) => Unit) {
			if (dep.forall(x => x.ref.to == x)) {
				val pre = IETerm.findPI(of, rs)
				if (pre != null) {
					f(pre)
				} else {
					val ofr = of.ref
					addJob(() => {
						if (dep.forall(x => x.ref.to == x)) {
							val cof = ofr.to
							val tm = IETerm.findPI(cof, rs)
							val p = if (tm == null) {
								val ntm = auxTerm(if (rs.size == 1) null else rs, IETerm.genesisPI(cof, rs))
								ntm.isPI(cof, if (rs.size == 1) rs.head else null)
								ntm
							} else {
								tm
							}
							f(p)
						}
					})
				}
			}
		}
	}
}
