package tifmo

import knowledge.SemRole.SemRole
import scala.collection.mutable

package inference {
	
	abstract class IEPred {
		
		private[inference] def apply(): Boolean
		private[inference] def dispose(): Unit
		private[inference] def sched(): Unit
		
		protected val parts: List[Any]
		protected val name: String
		protected val rels: Set[IETerm]
		
		override def equals(a: Any) = {
			if (a.isInstanceOf[IEPred]) {
				val that = a.asInstanceOf[IEPred]
				name == that.name && parts == that.parts
			} else {
				false
			}
		}
		override lazy val hashCode = (name, parts).hashCode
		override def toString = parts.mkString(name + "(", ";", ")")
		
		protected[this] def mark(npred: IEPred) = {
			val ret = npred.rels.head.schedcache.add(npred)
			for (x <- npred.rels.tail) {
				assert(ret == x.schedcache.add(npred))
			}
			ret
		}
		
		private[inference] def unmark() {
			rels.foreach(_.schedcache.remove(this))
		}
	}
	
	private[inference] trait PoolMgr[T <: IEPred] {
		
		protected[this] val pool: List[mutable.Set[T]]
		
		protected[this] def apply(a: T) = {
			val ret = pool.head.add(a)
			for (x <- pool.tail) {
				assert(ret == x.add(a))
			}
			ret
		}
		
		protected[this] def dispose(a: T) {
			pool.foreach(_.remove(a))
		}
		
	}
	
	class IEPredNonEmpty(val term: IETerm) extends IEPred with PoolMgr[IEPredNonEmpty] {
		
		protected[this] val pool = term.kne :: Nil
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = term :: Nil
		protected val name = "NonEmpty"
		
		protected[this] val rels = Set(term)
		
		private[inference] def sched() {
			val tmp = term.ref.to
			val npred = new IEPredNonEmpty(tmp)
			if (mark(npred)) {
				val tmpl = tmp.neTriggers.toList
				tmpl.foreach(_.fire(npred))
			}
		}
		
	}
	
	class IEPredSubsume(val subset: IETerm, val superset: IETerm) extends IEPred with PoolMgr[IEPredSubsume] {
		
		protected[this] val pool = subset.assub :: superset.assuper :: Nil
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = subset :: superset :: Nil
		protected val name = "Subsume"
		
		protected[this] val rels = Set(subset, superset)
		
		private[inference] def sched() {
			val sub = subset.ref.to
			val sup = superset.ref.to
			val npred = new IEPredSubsume(sub, sup)
			if (mark(npred)) {
				val subl = sub.subTriggers.toList
				val supl = sup.superTriggers.toList
				subl.foreach(_.fire(npred))
				supl.foreach(_.fire(npred))
			}
		}
		
	}
	
	class IEPredDisjoint(a: IETerm, b: IETerm) extends IEPred with PoolMgr[IEPredDisjoint] {
		
		val pair = Set(a, b)
		def oneIs(x: IETerm) = pair.contains(x)
		def another(x: IETerm) = {
			assert(pair.contains(x))
			if (pair.size == 1) x else (pair - x).head
		}
		
		protected[this] val pool = pair.toList.map(_.djts)
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = pair :: Nil
		protected val name = "Disjoint"
		
		protected[this] val rels = pair
		
		private[inference] def sched() {
			val na = a.ref.to
			val nb = b.ref.to
			val npred = new IEPredDisjoint(na, nb)
			if (mark(npred)) {
				if (na == nb) {
					val tmpl = na.djtTriggers.toList
					tmpl.foreach(_.fire(npred))
				} else {
					val nal = na.djtTriggers.toList
					val nbl = nb.djtTriggers.toList
					nal.foreach(_.fire(npred))
					nbl.foreach(_.fire(npred))
				}
			}
		}
		
	}
	
	class IEPredCP(val head: IETerm, val comp: Set[(IETerm, SemRole)]) extends IEPred with PoolMgr[IEPredCP] {
		
		val roleMap = comp.map(x => {
			val rs = if (x._2 == null) x._1.roles else Set(x._2)
			(rs, x)
		}).toMap
		
		protected[this] val pool = head.iscps :: comp.map(_._1).toList.map(_.mkcps)
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = head :: comp :: Nil
		protected val name = "IsCP"
		
		protected[this] val rels = comp.map(_._1) + head
		
		private[inference] def sched() {
			val nh = head.ref.to
			val nc = comp.map(x => (x._1.ref.to, x._2))
			val npred = new IEPredCP(nh, nc)
			if (mark(npred)) {
				var tgl = nh.iscpTriggers.toList
				for (x <- nc.map(_._1)) {
					tgl = x.mkcpTriggers.toList ::: tgl
				}
				tgl.foreach(_.fire(npred))
			}
		}
		
	}
	
	class IEPredPI(val head: IETerm, val compt: IETerm, val compr: SemRole) extends IEPred with PoolMgr[IEPredPI] {
		
		val headrs = if (compr == null) head.roles else Set(compr)
		
		protected[this] val pool = head.ispis :: compt.mkpis :: Nil
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = head :: compt :: compr :: Nil
		protected val name = "IsPI"
		
		protected[this] val rels = Set(head, compt)
		
		private[inference] def sched() {
			val nh = head.ref.to
			val nc = compt.ref.to
			val npred = new IEPredPI(nh, nc, compr)
			if (mark(npred)) {
				val nhl = nh.ispiTriggers.toList
				val ncl = nc.mkpiTriggers.toList
				nhl.foreach(_.fire(npred))
				ncl.foreach(_.fire(npred))
			}
		}
		
	}
	
	class IEPredIN(val head: IETerm, val comp: Set[IETerm], val aux: Boolean) extends IEPred with PoolMgr[IEPredIN] {
		
		protected[this] val pool = head.isins :: comp.toList.map(_.mkins)
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = head :: comp :: aux :: Nil
		protected val name = "IsIN"
		
		protected[this] val rels = comp + head
		
		private[inference] def sched() {
			assert(!aux)
			val nh = head.ref.to
			val nc = comp.map(_.ref.to)
			val npred = new IEPredIN(nh, nc, true)
			if (nh.isins.contains(npred) && mark(npred)) {
				val nhl = nh.isinTriggers.toList
				nhl.foreach(_.fire(npred))
			}
		}
		
	}
	
	class IEPredComp(val h: IETerm, val a: IETerm, val tot: IETerm) extends IEPred with PoolMgr[IEPredComp] {
		
		protected[this] val pool = if (tot == null || a == tot) {
			h.iscomp :: a.mkcomp :: Nil
		} else {
			h.iscomp :: a.mkcomp :: tot.mkcomp :: Nil
		}
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = h :: a :: tot :: Nil
		protected val name = "Comp"
		
		protected[this] val rels = Set.empty[IETerm]
		
		private[inference] def sched() { throw new Exception("This shouldn't be called.") }
		
	}
	
	class IEPredDI(val h: IETerm, val a: IETerm, val b: IETerm, val r: SemRole) extends IEPred with PoolMgr[IEPredDI] {
		
		protected[this] val pool = h.isdi :: a.mkdi :: b.mkdi :: Nil
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = h :: a :: b :: r :: Nil
		protected val name = "IsDI"
		
		protected[this] val rels = Set.empty[IETerm]
		
		private[inference] def sched() { throw new Exception("This shouldn't be called.") }
		
	}
	
	class IEPredDU(val h: IETerm, val a: IETerm, val b: IETerm, val r: SemRole) extends IEPred with PoolMgr[IEPredDU] {
		
		protected[this] val pool = h.isdu :: a.mkdu :: b.mkdu :: Nil
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = h :: a :: b :: r :: Nil
		protected val name = "IsDU"
		
		protected[this] val rels = Set.empty[IETerm]
		
		private[inference] def sched() { throw new Exception("This shouldn't be called.") }
		
	}
	
	class IEPredDE(val h: IETerm, val a: IETerm, val b: IETerm, val r: SemRole) extends IEPred with PoolMgr[IEPredDE] {
		
		protected[this] val pool = h.isde :: a.mkde :: b.mkde :: Nil
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = h :: a :: b :: r :: Nil
		protected val name = "IsDE"
		
		protected[this] val rels = Set.empty[IETerm]
		
		private[inference] def sched() { throw new Exception("This shouldn't be called.") }
		
	}
	
	class IEPredSL(val h: IETerm, val a: IETerm, val slct: Slction) extends IEPred with PoolMgr[IEPredSL] {
		
		protected[this] val pool = h.issl :: a.mksl :: Nil
		private[inference] def apply() = apply(this)
		private[inference] def dispose() { dispose(this) }
		
		protected val parts = h :: a :: slct :: Nil
		protected val name = "IsSL"
		
		protected[this] val rels = Set.empty[IETerm]
		
		private[inference] def sched() { throw new Exception("This shouldn't be called.") }
		
	}
	
}
