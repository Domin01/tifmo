package tifmo

import mylib.oneFromEach
import mylib.listPartitions
import knowledge.WordInfo
import knowledge.SemRole.SemRole

import scala.collection.mutable

package inference {
	
	/**
	 * The basic class which implements inference rules for algebraic forms. 
	 */
	class IEBasic extends IEngine with FAConversion {
		
		// contradiction awareness
		private[this] var flagContra = false
		protected[this] def contradict(a: IETerm) {
			flagContra = true
		}
		/**
		 * Returns true iff there has been a contradiction during forward chaining, 
		 * since the last call of this function.
		 * 
		 * @param reset If set true, the flag of contradiction is reset after the 
		 * function is called.
		 */
		def hasContra(reset: Boolean = false) = {
			val ret = flagContra
			if (reset) flagContra = false
			ret
		}
		//////////////////////////////////////////////////
		
		// table of constants
		/**
		 * Defines a new constant.
		 */
		private[this] val constPool = mutable.Map.empty[String, IETermRef]
		def newConstant(name: String, roles: Set[SemRole]) {
			assert(!constPool.contains(name))
			constPool(name) = newTerm(roles).ref
		}
		/**
		 * Get a constant term (or its complement) by WordInfo.
		 */
		def getConstant(word: WordInfo) = {
			val pre = constPool(word.lex).to
			if (word.isStopwd) {
				getW(pre.roles)
			} else if (word.sign) {
				pre
			} else {
				getComp(pre)
			}
		}
		///////////////////////////////////////////////////
		
		// rule: PI(A), B \subset A => PI(B) \subset PI(A)
		private[this] val rPISub0 = (pia: IETerm, suba: IETerm, rs: Set[SemRole]) => {
			constructPI(suba, rs, List(pia), (x:IETermRef, args: List[FuncArg]) => args match {
				case FuncArg(pia:IETerm) :: Nil => {
					claimSubsume(x.to, pia)
				}
				case _ => throw new Exception("rPISub0 error!")
			})
		}
		private[this] val rPISub1 = (sub: IEPredSubsume, args: List[FuncArg]) => {
			for (pi <- sub.superset.mkpis.toList) {
				rPISub0(pi.head, sub.subset, pi.headrs)
			}
		}
		private[this] val rPISub2 = (a: IETerm) => {
			if (a.roles != null) {
				foreachSubset(a, Nil, rPISub1)
			}
		}
		forAnyTerm(rPISub2)
		private[this] val rPISub3 = (pi: IEPredPI, args: List[FuncArg]) => {
			for (x <- pi.compt.subSets) {
				rPISub0(pi.head, x, pi.headrs)
			}
		}
		private[this] val rPISub4 = (a: IETerm) => {
			if (a.roles != null) {
				foreachMkPI(a, Nil, rPISub3)
			}
		}
		forAnyTerm(rPISub4)
		/////////////////////////////////////////////////
		
		// rule: T = PI((X x Y x ...) x A x B x ...), A.ne, B.ne, ... => T = X x Y x ...
		private[this] val rPICP0 = (pi: IEPredPI, cp: IEPredCP) => {
			val fil = cp.roleMap.keySet.filter(_.subsetOf(pi.headrs))
			if (fil.flatten == pi.headrs) {
				val comp = fil.map(cp.roleMap(_))
				val cl = cp.comp.map(_._1) -- comp.map(_._1)
				if (fil.size == 1) {
					val tmp = comp.head._1
					claimSubsume(pi.head, tmp)
					if (cl.forall(_.knownNE)) claimSubsume(tmp, pi.head)
				} else {
					if (cl.forall(_.knownNE)) claimCP(pi.head, comp)
				}
			}
		}
		private[this] val rPICP1 = (cp: IEPredCP, args: List[FuncArg]) => {
			for (pi <- cp.head.mkpis.toList) {
				rPICP0(pi, cp)
			}
		}
		private[this] val rPICP2 = (x: IETerm) => {
			if (x.roles != null) foreachIsCP(x, Nil, rPICP1)
		}
		forAnyTerm(rPICP2)
		private[this] val rPICP3 = (pi: IEPredPI, args: List[FuncArg]) => {
			for (cp <- pi.compt.iscps.toList) {
				rPICP0(pi, cp)
			}
		}
		private[this] val rPICP4 = (x: IETerm) => foreachIsPI(x, Nil, rPICP3)
		forAnyTerm(rPICP4)
		private[this] val rPICP5 = (ne: IEPredNonEmpty, args: List[FuncArg]) => {
			var tmp = Nil:List[(IEPredCP, IEPredPI)]
			for (cp <- ne.term.mkcps; pi <- cp.head.mkpis) {
				tmp = (cp, pi) :: tmp
			}
			for ((cp, pi) <- tmp) {
				rPICP0(pi, cp)
			}
		}
		private[this] val rPICP6 = (x: IETerm) => ifNotEmpty(x, Nil, rPICP5)
		forAnyTerm(rPICP6)
		/////////////////////////////////////////////////
		
		// rule: A -> B, C -> D => A x C -> B x D
		private[this] val rCPSub1 = (cp: IEPredCP, args: List[FuncArg]) => {
			def findAllCP(ll: Set[Set[(IETerm, SemRole)]]) = {
				val kk = oneFromEach.map[(IETerm, SemRole), (Set[IETerm], Set[(IETerm, SemRole)])](ll, null, (x, y) => {
					if (x == null) {
						(y._1.mkcps.filter(_.comp.contains(y)).map(_.head).toSet, Set(y))
					} else {
						val tmp = x._2 + y
						(y._1.mkcps.filter(z => tmp.subsetOf(z.comp)).map(_.head).toSet, tmp)
					}
				}, _._1.isEmpty)
				kk.flatMap(x => x._1.filter(y => y.hasCP(x._2)))
			}
			var task = Nil:List[() => Unit]
			if (cp.comp.filter(_._1.isW).size <= 1) {
				val llsuper = cp.comp.map(x => x._1.superSets.map(y => (y, x._2)))
				for (x <- findAllCP(llsuper)) {
					task = (() => claimSubsume(cp.head, x)) :: task
				}
				val llsub = cp.comp.map(x => x._1.subSets.map(y => (y, x._2)))
				for (x <- findAllCP(llsub)) {
					task = (() => claimSubsume(x, cp.head)) :: task
				}
			}
			task.foreach(_())
		}
		private[this] val rCPSub2 = (x: IETerm) => {
			if (x.roles != null) foreachIsCP(x, Nil, rCPSub1)
		}
		forAnyTerm(rCPSub2)
		private[this] val rCPSub3 = (sub: IEPredSubsume, args: List[FuncArg]) => {
			var task = Nil:List[() => Unit]
			for (x <- sub.subset.mkcps; y <- sub.superset.mkcps; if x.roleMap.keySet == y.roleMap.keySet) {
				if (x.roleMap.keys.forall(k => x.roleMap(k)._1.hasSuper(y.roleMap(k)._1))) {
					task = (() => claimSubsume(x.head, y.head)) :: task
				}
			}
			task.foreach(_())
		}
		private[this] val rCPSub4 = (x: IETerm) => foreachSubset(x, Nil, rCPSub3)
		forAnyTerm(rCPSub4)
		/////////////////////////////////////////////////
		
		// rule: PI1(A), PI2(A) => A \subset PI1(A) x PI2(A)
		private[this] val rPIdef0 = (cp: IEPredCP, args: List[Any]) => args match {
			case FuncArg(x:IETerm) :: Nil => {
				claimSubsume(x, cp.head)
				for ((t, r) <- cp.comp) {
					claimPI(t, cp.head, r)
				}
			}
			case _ => throw new Exception("rPIdef0 error!")
		}
		private[this] val rPIdef1 = (pi: IEPredPI, args: List[Any]) => {
			val cands = pi.compt.mkpis
			for (lrs <- listPartitions[SemRole](pi.compt.roles -- pi.headrs, cands.map(_.headrs))) {
				val comp = lrs.map(x => cands.find(_.headrs == x) match {
					case Some(y) => {
						(y.head, y.compr)
					}
					case None => throw new Exception("rPIdef1 find error!")
				}).toSet + ((pi.head, pi.compr))
				forCPof(comp, List(pi.compt), rPIdef0)
			}
		}
		private[this] val rPIdef2 = (x: IETerm) => {
			if (x.roles != null) foreachMkPI(x, Nil, rPIdef1)
		}
		forAnyTerm(rPIdef2)
		//////////////////////////////////////////////////
		
		// rule: PI(X x A \cap B) = X \cap PI(W x A \cap B)
		private[this] val rPIWIN0 = (a: IETerm, rem: Set[IETerm], ll: Set[List[(IETerm, Set[(IETerm, SemRole)])]], rs: Set[SemRole]) => {
			for (l <- oneFromEach[(IETerm, Set[(IETerm, SemRole)])](ll)) {
				val (mm, nn) = l.unzip
				val arglst = List[FuncArg](a, rem, nn, mm, rs)
				val inpi = (tms: List[IETermRef]) => {
					constructIN(rem ++ tms.map(_.to), arglst, (x: IETermRef, args: List[FuncArg]) => {
						constructPI(x.to, rs, arglst, (x: IETermRef, args: List[FuncArg]) => {
							claimIN(a, mm.toSet + x.to, true)
						})
					})
				}
				val cploop = (inpi /: nn)((func, comp) => (tms: List[IETermRef]) => {
					constructCP(comp, arglst, (x: IETermRef, args: List[FuncArg]) => func(x :: tms))
				})
				cploop(Nil)
			}
		}
		private[this] val rPIWIN1 = (bs: Set[IETerm], rs: Set[SemRole]) => {
			var rem = Nil:List[IETerm]
			val ll = (for (b <- bs) yield {
				val tmp = for {
					cp <- b.iscps.toList
					if cp.comp.filter(_._1.isW).size <= 1 && cp.roleMap.contains(rs)
					(t, r) = cp.roleMap(rs)
					if !t.isW
				} yield {
					(t, cp.comp - ((t, r)) + ((getW(t.roles), r)))
				}
				if (tmp.isEmpty) {
					rem = b :: rem
				}
				tmp
			}) - Nil
			(rem.toSet, ll)
		}
		private[this] val rPIWIN2 = (cp: IEPredCP, args: List[FuncArg]) => {
			var tmp = Nil:List[(IETerm, Set[IETerm], Set[List[(IETerm, Set[(IETerm, SemRole)])]], Set[SemRole])]
			for (in <- cp.head.mkins; if !in.aux; pi <- in.head.mkpis; if cp.roleMap.contains(pi.headrs)) {
				val (t, r) = cp.roleMap(pi.headrs)
				val (rem, prell) = rPIWIN1(in.comp - cp.head, pi.headrs)
				tmp = (pi.head, rem, prell + List((t, cp.comp - ((t, r)) + ((getW(t.roles), r)))), pi.headrs) :: tmp
			}
			for ((a, rem, ll, rs) <- tmp) {
				rPIWIN0(a, rem, ll, rs)
			}
		}
		private[this] val rPIWIN3 = (x: IETerm) => {
			if (x.roles != null) foreachIsCP(x, Nil, rPIWIN2)
		}
		forAnyTerm(rPIWIN3)
		private[this] val rPIWIN4 = (in: IEPredIN, args: List[FuncArg]) => {
			var tmp = Nil:List[(IETerm, Set[IETerm], Set[List[(IETerm, Set[(IETerm, SemRole)])]], Set[SemRole])]
			for (pi <- in.head.mkpis) {
				val (rem, ll) = rPIWIN1(in.comp, pi.headrs)
				tmp = (pi.head, rem, ll, pi.headrs) :: tmp
			}
			for ((a, rem, ll, rs) <- tmp) {
				rPIWIN0(a, rem, ll, rs)
			}
		}
		private[this] val rPIWIN5 = (x: IETerm) => {
			if (x.roles != null) foreachIsIN(x, Nil, rPIWIN4)
		}
		forAnyTerm(rPIWIN5)
		private[this] val rPIWIN6 = (pi: IEPredPI, args: List[FuncArg]) => {
			var tmp = Nil:List[(IETerm, Set[IETerm], Set[List[(IETerm, Set[(IETerm, SemRole)])]], Set[SemRole])]
			for (in <- pi.compt.isins; if !in.aux) {
				val (rem, ll) = rPIWIN1(in.comp, pi.headrs)
				if (!ll.isEmpty) tmp = (pi.head, rem, ll, pi.headrs) :: tmp
			}
			for ((a, rem, ll, rs) <- tmp) {
				rPIWIN0(a, rem, ll, rs)
			}
		}
		private[this] val rPIWIN7 = (x: IETerm) => {
			if (x.roles != null) foreachMkPI(x, Nil, rPIWIN6)
		}
		forAnyTerm(rPIWIN7)
		/////////////////////////////////////////////////
		
		// rule: (A x B) \cap (C x D) = (A \cap C) x (B \cap D)
		private[this] val rCPIN0 = (a: IETerm, ll: Set[List[IEPredCP]]) => {
			for (l <- oneFromEach[IEPredCP](ll)) {
				val tmp = for (rs <- l.head.roleMap.keySet.toList) yield {
					(l.map(_.roleMap(rs)._1).toSet, if (rs.size == 1) rs.head else null)
				}
				val (tl, rl) = tmp.unzip
				val arglst = List[FuncArg](a, tl, rl)
				val cpdo = (ins: List[IETermRef]) => {
					claimCP(a, (ins.map(_.to) zip rl).toSet)
				}
				val inloop = (cpdo /: tl)((func, comp) => (ins: List[IETermRef]) => {
					constructIN(comp, arglst, (x: IETermRef, args: List[FuncArg]) => func(x :: ins))
				})
				inloop(Nil)
			}
		}
		private[this] val rCPIN1 = (cp: IEPredCP, args: List[FuncArg]) => {
			var tmp = Nil:List[(IETerm, Set[List[IEPredCP]])]
			for (in <- cp.head.mkins; if !in.aux) {
				val prell = for (x <- (in.comp - cp.head)) yield {
					x.iscps.filter(_.roleMap.keySet == cp.roleMap.keySet).toList
				}
				if (!prell.contains(Nil)) {
					tmp = (in.head, prell + List(cp)) :: tmp
				}
			}
			for ((a, ll) <- tmp) {
				rCPIN0(a, ll)
			}
		}
		private[this] val rCPIN2 = (x: IETerm) => {
			if (x.roles != null) foreachIsCP(x, Nil, rCPIN1)
		}
		forAnyTerm(rCPIN2)
		private[this] val rCPIN3 = (in: IEPredIN, args: List[FuncArg]) => {
			var tmp = Nil:List[(IETerm, Set[List[IEPredCP]])]
			val rsss = in.comp.head.iscps.map(_.roleMap.keySet).toSet
			for (rss <- rsss) {
				val ll = for (x <- in.comp) yield {
					x.iscps.filter(_.roleMap.keySet == rss).toList
				}
				if (!ll.contains(Nil)) {
					tmp = (in.head, ll) :: tmp
				}
			}
			for ((a, ll) <- tmp) {
				rCPIN0(a, ll)
			}
		}
		private[this] val rCPIN4 = (x: IETerm) => {
			if (x.roles != null) foreachIsIN(x, Nil, rCPIN3)
		}
		forAnyTerm(rCPIN4)
		/////////////////////////////////////////////////
		
		// rule: Complement
		private[this] val rComp1 = (djt: IEPredDisjoint, args: List[FuncArg]) => args match {
			case FuncArg(a:IETerm) :: FuncArg(h:IETerm) :: Nil => {
				claimSubsume(djt.another(a), h)
			}
			case _ => throw new Exception("rComp1 error!")
		}
		private[this] val rComp2 = (sub: IEPredSubsume, args: List[FuncArg]) => args match {
			case FuncArg(h:IETerm) :: Nil => {
				claimSubsume(sub.subset, h)
			}
			case _ => throw new Exception("rComp2 error!")
		}
		private[this] val rComp3 = (djt: IEPredDisjoint, args: List[FuncArg]) => args match {
			case FuncArg(tot:IETerm) :: FuncArg(a:IETerm) :: FuncArg(h:IETerm) :: Nil => {
				ifSubsume(djt.another(a), tot, List(h), rComp2)
			}
			case _ => throw new Exception("rComp3 error!")
		}
		protected[this] def applyComp(h: IETerm, a: IETerm, tot: IETerm) {
			if (tot == null) {
				foreachDisjoint(a, List(a, h), rComp1)
			} else {
				foreachDisjoint(a, List(tot, a, h), rComp3)
			}
		}
		/////////////////////////////////////////////////
		
		// rule: DI
		private[this] val rDI0 = (sub: IEPredSubsume, args: List[FuncArg]) => args match {
			case FuncArg(tc:Set[(IETerm, SemRole)]) :: FuncArg(h:IETerm) :: Nil => {
				constructCP(tc, List(h), (x:IETermRef, args: List[FuncArg]) => {
					claimSubsume(x.to, h)
				})
			}
			case _ => throw new Exception("rDI0 error!")
		}
		private[this] val rDI1 = (cp: IEPredCP, args: List[FuncArg]) => args match {
			case FuncArg(b:IETerm) :: FuncArg(r:SemRole) :: FuncArg(h:IETerm) :: Nil => {
				cp.comp.find(_._2 == r) match {
					case Some(x) => {
						ifSubsume(b, x._1, List(cp.comp - x, h), rDI0)
					}
					case None => {}
				}
			}
			case _ => throw new Exception("rDI1 error!")
		}
		private[this] val rDI2 = (sub: IEPredSubsume, args: List[FuncArg]) => {
			foreachIsCP(sub.subset, args, rDI1)
		}
		protected[this] def applyDI(h: IETerm, a: IETerm, b: IETerm, r: SemRole) {
			foreachSubset(a, List(b, r, h), rDI2)
		}
		/////////////////////////////////////////////////
		
		// rule: DE
		private[this] val rDE0 = (sub: IEPredSubsume, args: List[FuncArg]) => args match {
			case FuncArg(tmpt:IETerm) :: FuncArg(h:IETerm) :: Nil => {
				claimSubsume(tmpt, h)
			}
			case _ => throw new Exception("rDE0 error!")
		}
		private[this] val rDE1 = (cp: IEPredCP, args: List[FuncArg]) => args match {
			case FuncArg(tmpt:IETerm) :: FuncArg(cph:IETerm) :: FuncArg(a:IETerm) :: FuncArg(h:IETerm) :: Nil => {
				constructIN(Set(cp.head, a), List(tmpt, cph, h), (x: IETermRef, args: List[FuncArg]) => {
					ifSubsume(x.to, cph, List(tmpt, h), rDE0)
				})
			}
			case _ => throw new Exception("rDE1 error!")
		}
		private[this] val rDE2 = (sub: IEPredSubsume, args: List[FuncArg]) => args match {
			case FuncArg(tmpt:IETerm) :: FuncArg(tmpr:SemRole) :: FuncArg(r:SemRole) :: FuncArg(h:IETerm) :: Nil => {
				forCPof(Set((tmpt, tmpr), (getW(null), r)), List(tmpt, sub.subset, sub.superset, h), rDE1)
			}
			case FuncArg(tmpt:IETerm) :: FuncArg(null) :: FuncArg(r:SemRole) :: FuncArg(h:IETerm) :: Nil => {
				forCPof(Set((tmpt, null), (getW(null), r)), List(tmpt, sub.subset, sub.superset, h), rDE1)
			}
			case _ => throw new Exception("rDE2 error!")
		}
		private[this] val rDE3 = (cp: IEPredCP, args: List[FuncArg]) => args match {
			case FuncArg(a:IETerm) :: FuncArg(b:IETerm) :: FuncArg(r:SemRole) :: FuncArg(h:IETerm) :: Nil => {
				if (cp.comp.size == 2 && cp.comp.contains((b, r)) && cp.head.roles == a.roles) {
					val (tmpt, tmpr) = (cp.comp - ((b, r))).head
					ifSubsume(cp.head, a, List(tmpt, tmpr, r, h), rDE2)
				}
			}
			case _ => throw new Exception("rDE3 error!")
		}
		protected[this] def applyDE(h: IETerm, a: IETerm, b: IETerm, r: SemRole) {
			foreachMkCP(b, List(a, b, r, h), rDE3)
		}
		
		
	}
}
