package tifmo

import knowledge.SemRole.SemRole
import scala.collection.mutable

package inference {
	/**
	 * Provides reference to an [[tifmo.inference.IETerm]] instance. 
	 * 
	 * Inference engine terms may be merged 
	 * if they are proved to be equal, after merging some terms will dispose 
	 * their memory. So you should use IETermRef class to refer to a 
	 * conceptual term, of which the reference to an actual IETerm instance 
	 * is automatically updated during the merging process. 
	 * 
	 * @param orig The original [[tifmo.inference.IETerm]] instance being refered to. 
	 */
	class IETermRef(orig: IETerm) {
		
		private[inference] var t = orig
		
		/**
		 * Returns the [[tifmo.inference.IETerm]] instance currently being refered to. 
		 */
		def to: IETerm = {
			if (t != t.ref.t) t = t.ref.to
			t
		}
		
		override def toString = to.toString
	}
	
	/**
	 * Implementation of an inference engine term.
	 * 
	 * @param roles The dimension of this term, `null` iff the term is one dimensional.
	 * @param isW True iff this is a W term.
	 */
	class IETerm(val roles: Set[SemRole], val isW: Boolean, val id: Int) extends Ordered[IETerm] {
		
		assert(roles == null || (roles.size >= 2 && !roles.contains(null)))
		
		/**
		 * An [[tifmo.inference.IETermRef]] instance which originally refers to 
		 * this term.
		 */
		val ref = new IETermRef(this)
		
		///////////////////////////////////////////////
		
		def compare(that: IETerm) = id - that.id
		override def toString = "#" + id + (if (roles != null) roles.mkString("[", ",", "]") else "")
		
		///////////////////////////////////////////////
		
		private[inference] var kne = mutable.Set.empty[IEPredNonEmpty]
		private[inference] val assub = mutable.Set.empty[IEPredSubsume]
		private[inference] val assuper = mutable.Set.empty[IEPredSubsume]
		private[inference] val djts = mutable.Set.empty[IEPredDisjoint]
		private[inference] val iscps = mutable.Set.empty[IEPredCP]
		private[inference] val mkcps = mutable.Set.empty[IEPredCP]
		private[inference] val ispis = mutable.Set.empty[IEPredPI]
		private[inference] val mkpis = mutable.Set.empty[IEPredPI]
		 val isins = mutable.Set.empty[IEPredIN]
		private[inference] val mkins = mutable.Set.empty[IEPredIN]
		
		private[inference] val iscomp = mutable.Set.empty[IEPredComp]
		private[inference] val mkcomp = mutable.Set.empty[IEPredComp]
		private[inference] val isdi = mutable.Set.empty[IEPredDI]
		private[inference] val mkdi = mutable.Set.empty[IEPredDI]
		private[inference] val isdu = mutable.Set.empty[IEPredDU]
		private[inference] val mkdu = mutable.Set.empty[IEPredDU]
		private[inference] val isde = mutable.Set.empty[IEPredDE]
		private[inference] val mkde = mutable.Set.empty[IEPredDE]
		private[inference] val issl = mutable.Set.empty[IEPredSL]
		private[inference] val mksl = mutable.Set.empty[IEPredSL]
		
		///////////////////////////////////////////////
		
		private[inference] val neTriggers = mutable.Set.empty[Trigger[IEPredNonEmpty]]
		private[inference] val subTriggers = mutable.Set.empty[Trigger[IEPredSubsume]]
		private[inference] val superTriggers = mutable.Set.empty[Trigger[IEPredSubsume]]
		private[inference] val djtTriggers = mutable.Set.empty[Trigger[IEPredDisjoint]]
		private[inference] val iscpTriggers = mutable.Set.empty[Trigger[IEPredCP]]
		private[inference] val mkcpTriggers = mutable.Set.empty[Trigger[IEPredCP]]
		private[inference] val ispiTriggers = mutable.Set.empty[Trigger[IEPredPI]]
		private[inference] val mkpiTriggers = mutable.Set.empty[Trigger[IEPredPI]]
		private[inference] val isinTriggers = mutable.Set.empty[Trigger[IEPredIN]]
		private[inference] val disposers = mutable.Set.empty[() => Unit]
		
		///////////////////////////////////////////////
		
		private[inference] val schedcache = mutable.Set.empty[IEPred]
		
		///////////////////////////////////////////////
		
		/**
		 * Returns if the term is known to be non-empty.
		 */
		def knownNE = (!kne.isEmpty)
		
		/**
		 * Returns all currently known supersets of this term (including itself).
		 */
		def superSets = assub.map(_.superset).toSet
		
		/**
		 * Returns the number of supersets of this term.
		 */
		def superSize = assub.size
		
		/**
		 * Returns if `that` is known to be a superset of this term.
		 */
		def hasSuper(that: IETerm) = assub.contains(new IEPredSubsume(this, that))
		
		/**
		 * Returns all currently known subsets of this term (including itself).
		 */
		def subSets = assuper.map(_.subset).toSet
		
		/**
		 * Returns the number of subsets of this term.
		 */
		def subSize = assuper.size
		
		/**
		 * Returns if `that` is known to be a subset of this term.
		 */
		def hasSub(that: IETerm) = assuper.contains(new IEPredSubsume(that, this))
		
		/**
		 * Returns all sets which are currently known to be disjoint to this term.
		 */
		def disjointSets = djts.map(_.another(this)).toSet
		
		/**
		 * Returns if `that` is known to be disjoint to this term.
		 */
		def disjointTo(that: IETerm) = djts.contains(new IEPredDisjoint(this, that))
		
		/**
		 * Returns if this term is known to be a Cartesian product of the terms in `comp`.
		 */
		def hasCP(comp: Set[(IETerm, SemRole)]) = iscps.contains(new IEPredCP(this, comp))
		
		/**
		 * Returns if this term is known to be a projection of `term` into dimension `r`.
		 */
		def hasPI(term: IETerm, r: SemRole) = ispis.contains(new IEPredPI(this, term, r))
		
		/**
		 * Returns if this term is known to be an intersection of the terms in `comp`.
		 */
		def hasIN(comp: Set[IETerm]) = {
			comp.forall(hasSuper(_)) && {
				val whole = comp.flatMap(_.superSets.filter(_.isins.isEmpty))
				whole.contains(this) || isins.exists(_.comp.subsetOf(whole))
			}
		}
		
		/**
		 * Returns if this term is known to be a complement of the term `a`.
		 */
		def hasComp(a: IETerm, tot: IETerm = null) = iscomp.contains(new IEPredComp(this, a, tot))
		
		/**
		 * Returns if this term is known to be `DI(a, b, r)`.
		 */
		def hasDI(a: IETerm, b: IETerm, r: SemRole) = isdi.contains(new IEPredDI(this, a, b, r))
		
		/**
		 * Returns if this term is known to be `DU(a, b, r)`.
		 */
		def hasDU(a: IETerm, b: IETerm, r: SemRole) = isdu.contains(new IEPredDU(this, a, b, r))
		
		/**
		 * Returns if this term is known to be `DE(a, b, r)`.
		 */
		def hasDE(a: IETerm, b: IETerm, r: SemRole) = isde.contains(new IEPredDE(this, a, b, r))
		
		/**
		 * Returns if we have `IEPreSL(this, a, slct)`.
		 */
		def aSL(a: IETerm, slct: Slction) = issl.contains(new IEPredSL(this, a, slct))
		
		/**
		 * Returns if we have `IEPreSL(h, this, slct)`.
		 */
		def hSL(h: IETerm, slct: Slction) = mksl.contains(new IEPredSL(h, this, slct))
		
		/**
		 * Returns all `IEPreSL(this, *, *)`.
		 */
		def isSL = issl.toSet
		
		/**
		 * Returns all `IEPreSL(*, this, *)`.
		 */
		def mkSL = mksl.toSet
		
		///////////////////////////////////////////////
		
	}
	
}
