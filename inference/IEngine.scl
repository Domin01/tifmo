package tifmo

import mylib.oneFromEach
import mylib.listPartitions
import knowledge.SemRole.SemRole
import scala.collection.mutable

package inference {
	/**
	 * The abstract class of a forward chaining inference engine for algebraic 
	 * forms. 
	 * 
	 * This class implements the forward chaining algorithm, provides the 
	 * infra structure for writing rules, and implements basic axioms of 
	 * relational algebra in a way that can avoid most of combinatorial explosions. 
	 */
	abstract class IEngine {
		
		private[this] var lastcounter = 0
		def getLastCount = lastcounter
		
		private[this] val tasks = mutable.Queue.empty[() => Unit]
		private[this] val mergePool = mutable.Set.empty[IETerm]
		private[this] val schedule = mutable.Queue.empty[IEPred]
		private[this] val constructQ = mutable.Queue.empty[() => Unit]
		
		/**
		 * Do forward chaining process. 
		 */
		def explore() {
			def loop1() {
				while (!tasks.isEmpty) {
					tasks.dequeue()()
				}
			}
			def loop2() {
				loop1()
				while (!mergePool.isEmpty) {
					val cache = mutable.Set.empty[IETerm]
					var most = 0
					var tomerge = null:Set[IETerm]
					for (x <- mergePool; if !cache.contains(x)) {
						val tmp = x.subSets intersect x.superSets
						cache ++= tmp
						if (tmp.size > most) {
							most = tmp.size
							tomerge = tmp
						}
					}
					mergePool --= tomerge
					merge(tomerge)
					
					System.err.println("merged " + tomerge.size + " elements to one.")
					
					loop1()
				}
			}
			def loop3() {
				loop2()
				while (!schedule.isEmpty) {
					schedule.dequeue().sched()
					loop2()
				}
			}
			
			loop3()
			while (!constructQ.isEmpty) {
				constructQ.dequeue()()
				loop3()
			}
			lastcounter = getCount
		}
		
		////////////////////////////////////////////////////
		
		private[this] def termPredInit(x: IETerm) {
			if (x.isW) {
				val predne = new IEPredNonEmpty(x)
				val predsub = new IEPredSubsume(x, x)
				x.kne.add(predne)
				x.assub.add(predsub)
				x.assuper.add(predsub)
				x.schedcache.add(predne)
				x.schedcache.add(predsub)
			} else {
				val predsub = new IEPredSubsume(x, x)
				x.assub.add(predsub)
				x.assuper.add(predsub)
				x.schedcache.add(predsub)
			}
		}
		
		private[this] val W = new IETerm(null, true, 0)
		termPredInit(W)
		
		private[this] var counter = 1
		def getCount = counter
		
		private[this] val WPool = mutable.Map((null:Set[SemRole], W))
		/**
		 * Get the W term of dimension `roles`.
		 */
		def getW(roles: Set[SemRole]) = WPool.getOrElseUpdate(roles, {
			val ret = new IETerm(roles, true, getCount)
			termPredInit(ret)
			counter += 1
			claimCP(ret, roles.map(r => (W, r)))
			ret
		})
		
		private[this] val anyTermPool = mutable.Set.empty[IETerm => Unit]
		/**
		 * Get a new non-W term.
		 */
		protected def newTerm(roles: Set[SemRole]) = {
			val term = new IETerm(roles, false, getCount)
			termPredInit(term)
			counter += 1
			anyTermPool.foreach(_(term))
			val w = getW(roles)
			for (x <- w.superSets) {
				applySubsume(term, x)
			}
			term
		}
		
		////////////////////////////////////////////////////
		
		/**
		 * Find a Cartesian product. If none, returns `null`.
		 */
		def findCP(comp: Set[(IETerm, SemRole)]) = {
			if (comp.size <= 1) {
				comp.head._1
			} else {
				val tmp = comp.minBy[Int](_._1.mkcps.size)._1.mkcps
				tmp.find(_.comp == comp) match {
					case Some(x) => x.head
					case None => null
				}
			}
		}
		
		/**
		 * Find a projection. If none, returns `null`.
		 */
		def findPI(compt: IETerm, headrs: Set[SemRole]) = {
			compt.mkpis.find(_.headrs == headrs) match {
				case Some(x) => x.head
				case None => null
			}
		}
		
		/**
		 * Find an intersection. If none, returns `null`.
		 */
		def findIN(comp: Set[IETerm]) = {
			val tmp = comp.minBy[Int](_.subSize).subSets
			tmp.find(_.hasIN(comp)) match {
				case Some(x) => x
				case None => null
			}
		}
		
		/**
		 * Find a completion. If none, returns `null`.
		 */
		def findComp(a: IETerm, tot: IETerm) = {
			a.mkcomp.find(x => x.a == a && x.tot == tot) match {
				case Some(x) => x.h
				case None => null
			}
		}
		
		/**
		 * Find a DI. If none, returns `null`.
		 */
		def findDI(a: IETerm, b: IETerm, r: SemRole) = {
			a.mkdi.find(x => x.a == a && x.b == b && x.r == r) match {
				case Some(x) => x.h
				case None => null
			}
		}
		
		/**
		 * Find a DU. If none, returns `null`.
		 */
		def findDU(a: IETerm, b: IETerm, r: SemRole) = {
			a.mkdu.find(x => x.a == a && x.b == b && x.r == r) match {
				case Some(x) => x.h
				case None => null
			}
		}
		
		/**
		 * Find a DE. If none, returns `null`.
		 */
		def findDE(a: IETerm, b: IETerm, r: SemRole) = {
			a.mkde.find(x => x.a == a && x.b == b && x.r == r) match {
				case Some(x) => x.h
				case None => null
			}
		}
		
		/**
		 * Find a SL. If none, returns `null`.
		 */
		def findSL(rs: Set[SemRole], sel: Set[(IETerm, IETerm, Slction)]) = {
			
			val (h, a, slct) = sel.head
			
			val cands = if (h == null) {
				for (x <- a.mkSL; if x.h.roles == rs && x.slct == slct) yield x.h
			} else {
				assert(a == null)
				for (x <- h.isSL; if x.a.roles == rs && x.slct == slct) yield x.a
			}
			
			cands.find(x => sel.tail.forall(y => {
				if (y._1 == null) {
					x.aSL(y._2, y._3)
				} else {
					x.hSL(y._1, y._3)
				}
			})) match {
				case Some(x) => x
				case None => null
			}
		}
		
		////////////////////////////////////////////////////
		
		/**
		 * Get Cartesian product.
		 */
		def getCP(comp: Set[(IETerm, SemRole)]) = {
			val fd = findCP(comp)
			if (fd != null) {
				fd
			} else {
				val roles = comp.flatMap(x => if (x._2 != null) Set(x._2) else x._1.roles)
				val ret = newTerm(roles)
				//println("new term " + ret + " is CP of " + comp)
				claimCP(ret, comp)
				ret
			}
		}
		
		/**
		 * Get projection.
		 */
		def getPI(compt: IETerm, headrs: Set[SemRole]) = {
			val fd = findPI(compt, headrs)
			if (fd != null) {
				fd
			} else {
				val roles = if (headrs.size == 1) null else headrs
				val ret = newTerm(roles)
				//println("new term " + ret + " is PI of " + compt + " to " + headrs)
				claimPI(ret, compt, if (headrs.size == 1) headrs.head else null)
				ret
			}
		}
		
		/**
		 * Get intersection.
		 */
		def getIN(comp: Set[IETerm], aux: Boolean = false) = {
			val fd = findIN(comp)
			if (fd != null) {
				if (!aux) claimIN(fd, comp, false)
				fd
			} else {
				val roles = comp.head.roles
				val ret = newTerm(roles)
				//println("new term " + ret + " is IN of " + comp)
				claimIN(ret, comp, aux)
				ret
			}
		}
		
		/**
		 * Get the term `tot \ a`. If `tot == null` then get the complement of `a`.
		 */
		def getComp(a: IETerm, tot: IETerm = null) = {
			val fd = findComp(a, tot)
			if (fd != null) {
				fd
			} else {
				val ret = newTerm(a.roles)
				claimComp(ret, a, tot)
				ret
			}
		}
		
		/**
		 * Get the term `DI(a, b, r)`.
		 */
		def getDI(a: IETerm, b: IETerm, r: SemRole) = {
			val fd = findDI(a, b, r)
			if (fd != null) {
				fd
			} else {
				val hrs = if (a.roles.size == 2) null else a.roles - r
				val ret = newTerm(hrs)
				claimDI(ret, a, b, r)
				ret
			}
		}
		
		/**
		 * Get the term `DU(a, b, r)`.
		 */
		def getDU(a: IETerm, b: IETerm, r: SemRole) = {
			val fd = findDU(a, b, r)
			if (fd != null) {
				fd
			} else {
				val hrs = if (a.roles.size == 2) null else a.roles - r
				val ret = newTerm(hrs)
				claimDU(ret, a, b, r)
				ret
			}
		}
		
		/**
		 * Get the term `DE(a, b, r)`.
		 */
		def getDE(a: IETerm, b: IETerm, r: SemRole) = {
			val fd = findDE(a, b, r)
			if (fd != null) {
				fd
			} else {
				val hrs = if (a.roles.size == 2) null else a.roles - r
				val ret = newTerm(hrs)
				claimDE(ret, a, b, r)
				ret
			}
		}
		
		
		private[this] val slctPool = mutable.Map.empty[Slction, mutable.Set[(IETerm, IETerm)]]
		def selBy(slct: Slction) = if (slctPool.contains(slct)) {
			slctPool(slct).toSet
		} else {
			Set.empty[(IETerm, IETerm)]
		}
		private[this] def slctAdd(pred: IEPredSL) {
			if (slctPool.contains(pred.slct)) {
				slctPool(pred.slct).add((pred.h, pred.a))
			} else {
				slctPool(pred.slct) = mutable.Set((pred.h, pred.a))
			}
		}
		def allSlct = slctPool.keySet
		/**
		 * Get selection.
		 */
		def getSL(rs: Set[SemRole], sel: Set[(IETerm, IETerm, Slction)]) = {
			val fd = findSL(rs, sel)
			if (fd != null) {
				fd
			} else {
				val ret = newTerm(rs)
				for ((h, a, slct) <- sel) {
					if (h == null) {
						claimSL(ret, a, slct)
					} else {
						claimSL(a, ret, slct)
					}
				}
				ret
			}
		}
		
		////////////////////////////////////////////////////
		
		def constructCP(comp: Set[(IETerm, SemRole)], args: List[FuncArg], 
				f: (IETermRef, List[FuncArg]) => Unit) {
			assert(comp.map(_._1).forall(x => x.ref.to == x))
			val dep = args.flatMap(_.terms).toSet
			assert(dep.forall(x => x.ref.to == x))
			val fd = findCP(comp)
			if (fd != null) {
				f(fd.ref, args)
			} else {
				constructQ.enqueue(() => {
					if (dep.forall(x => x.ref.to == x)) {
						val tm = getCP(comp.map(x => (x._1.ref.to, x._2)))
						f(tm.ref, args)
					}
				})
			}
		}
		
		def constructPI(compt: IETerm, headrs: Set[SemRole], args: List[FuncArg], 
				f: (IETermRef, List[FuncArg]) => Unit) {
			assert(compt.ref.to == compt)
			val dep = args.flatMap(_.terms).toSet
			assert(dep.forall(x => x.ref.to == x))
			val fd = findPI(compt, headrs)
			if (fd != null) {
				f(fd.ref, args)
			} else {
				constructQ.enqueue(() => {
					if (dep.forall(x => x.ref.to == x)) {
						val tm = getPI(compt.ref.to, headrs)
						f(tm.ref, args)
					}
				})
			}
		}
		
		def constructIN(comp: Set[IETerm], args: List[FuncArg], 
				f: (IETermRef, List[FuncArg]) => Unit) {
			assert(comp.forall(x => x.ref.to == x))
			val dep = args.flatMap(_.terms).toSet
			assert(dep.forall(x => x.ref.to == x))
			val fd = findIN(comp)
			if (fd != null) {
				f(fd.ref, args)
			} else {
				constructQ.enqueue(() => {
					if (dep.forall(x => x.ref.to == x)) {
						val tm = getIN(comp.map(_.ref.to), true)
						f(tm.ref, args)
					}
				})
			}
		}
		
		////////////////////////////////////////////////////
		
		protected def forAnyTerm(f: IETerm => Unit) {
			anyTermPool.add(f)
		}
		
		def ifNotEmpty(term: IETerm, args: List[FuncArg], f: (IEPredNonEmpty, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherNonEmpty(args, f)).initialize(term)
		}
		
		def foreachSuperset(term: IETerm, args: List[FuncArg], f: (IEPredSubsume, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherSub(args, f)).initialize(term)
		}
		
		def foreachSubset(term: IETerm, args: List[FuncArg], f: (IEPredSubsume, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherSuper(args, f)).initialize(term)
		}
		
		def foreachDisjoint(term: IETerm, args: List[FuncArg], f: (IEPredDisjoint, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherDisjoint(args, f)).initialize(term)
		}
		
		def foreachIsCP(term: IETerm, args: List[FuncArg], f: (IEPredCP, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherIsCP(args, f)).initialize(term)
		}
		
		def foreachMkCP(term: IETerm, args: List[FuncArg], f: (IEPredCP, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherMkCP(args, f)).initialize(term)
		}
		
		def foreachIsPI(term: IETerm, args: List[FuncArg], f: (IEPredPI, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherIsPI(args, f)).initialize(term)
		}
		
		def foreachMkPI(term: IETerm, args: List[FuncArg], f: (IEPredPI, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherMkPI(args, f)).initialize(term)
		}
		
		def foreachIsIN(term: IETerm, args: List[FuncArg], f: (IEPredIN, List[FuncArg]) => Unit) {
			assert(term.ref.to == term)
			(new WatcherIsIN(args, f)).initialize(term)
		}
		
		def forCPof(comp: Set[(IETerm, SemRole)], args: List[FuncArg], f: (IEPredCP, List[FuncArg]) => Unit) {
			comp.map(_._1).foreach(x => x.ref.to == x)
			(new ForCPof(args, f)).initialize(comp)
		}
		
		def ifSubsume(a: IETerm, b: IETerm, args: List[FuncArg], f: (IEPredSubsume, List[FuncArg]) => Unit) {
			assert(a.ref.to == a)
			assert(b.ref.to == b)
			(new IfSubsume(args, f)).initialize(a, b)
		}
		
		def ifDisjoint(a: IETerm, b: IETerm, args: List[FuncArg], f: (IEPredDisjoint, List[FuncArg]) => Unit) {
			assert(a.ref.to == a)
			assert(b.ref.to == b)
			(new IfDisjoint(args, f)).initialize(a, b)
		}
		
		////////////////////////////////////////////////////
		
		private[this] def merge(tomerge: Set[IETerm]) {
			assert(tomerge.size >= 2)
			
			val a = tomerge.find(_.isW) match {
				case Some(x) => x
				case None => {
					tomerge.minBy[Int](x => -x.iscps.size - x.mkcps.size - 
						x.isins.size - x.mkins.size - x.ispis.size - x.mkpis.size)
				}
			}
			val eqs = tomerge - a
			
			for (x <- eqs) {
				x.kne.toList.foreach(_.dispose())
				x.assub.toList.foreach(_.dispose())
				x.assuper.toList.foreach(_.dispose())
				x.djts.toList.foreach(_.dispose())
				x.schedcache.toList.foreach(_.unmark())
			}
			
			def replace(x: IETerm) = if (eqs.contains(x)) a else x
			
			var task = Nil:List[() => Unit]
			
			for (x <- eqs) {
				for (cp <- x.iscps) {
					val ncomp = cp.comp.map(y => (replace(y._1), y._2))
					if (!a.hasCP(ncomp)) {
						task = (() => claimCP(a, ncomp)) :: task
					}
				}
				for (cp <- x.mkcps) {
					val nhead = replace(cp.head)
					val ncomp = cp.comp.map(y => (replace(y._1), y._2))
					if (!nhead.hasCP(ncomp)) {
						task = (() => claimCP(nhead, ncomp)) :: task
					}
				}
				for (pi <- x.ispis) {
					val ncompt = replace(pi.compt)
					val ncompr = pi.compr
					if (!a.hasPI(ncompt, ncompr)) {
						task = (() => claimPI(a, ncompt, ncompr)) :: task
					}
				}
				for (pi <- x.mkpis) {
					val nhead = replace(pi.head)
					val ncompr = pi.compr
					if (!nhead.hasPI(a, ncompr)) {
						task = (() => claimPI(nhead, a, ncompr)) :: task
					}
				}
				for (in <- x.isins) {
					val ncomp = in.comp.map(replace(_))
					val naux = in.aux
					if (!a.isins.contains(new IEPredIN(a, ncomp, naux))) {
						task = (() => claimIN(a, ncomp, naux)) :: task
					}
				}
				for (in <- x.mkins) {
					val nhead = replace(in.head)
					val ncomp = in.comp.map(replace(_))
					val naux = in.aux
					if (!nhead.isins.contains(new IEPredIN(nhead, ncomp, naux))) {
						task = (() => claimIN(nhead, ncomp, naux)) :: task
					}
				}
				for (comp <- x.iscomp) {
					val na = replace(comp.a)
					val ntot = replace(comp.tot)
					if (!a.hasComp(na, ntot)) {
						task = (() => claimComp(a, na, ntot)) :: task
					}
				}
				for (comp <- x.mkcomp) {
					val nh = replace(comp.h)
					val na = replace(comp.a)
					val ntot = replace(comp.tot)
					if (!nh.hasComp(na, ntot)) {
						task = (() => claimComp(nh, na, ntot)) :: task
					}
				}
				for (di <- x.isdi) {
					val na = replace(di.a)
					val nb = replace(di.b)
					val nr = di.r
					if (!a.hasDI(na, nb, nr)) {
						task = (() => claimDI(a, na, nb, nr)) :: task
					}
				}
				for (di <- x.mkdi) {
					val nh = replace(di.h)
					val na = replace(di.a)
					val nb = replace(di.b)
					val nr = di.r
					if (!nh.hasDI(na, nb, nr)) {
						task = (() => claimDI(nh, na, nb, nr)) :: task
					}
				}
				for (du <- x.isdu) {
					val na = replace(du.a)
					val nb = replace(du.b)
					val nr = du.r
					if (!a.hasDU(na, nb, nr)) {
						task = (() => claimDU(a, na, nb, nr)) :: task
					}
				}
				for (du <- x.mkdu) {
					val nh = replace(du.h)
					val na = replace(du.a)
					val nb = replace(du.b)
					val nr = du.r
					if (!nh.hasDI(na, nb, nr)) {
						task = (() => claimDU(nh, na, nb, nr)) :: task
					}
				}
				for (de <- x.isde) {
					val na = replace(de.a)
					val nb = replace(de.b)
					val nr = de.r
					if (!a.hasDE(na, nb, nr)) {
						task = (() => claimDE(a, na, nb, nr)) :: task
					}
				}
				for (de <- x.mkde) {
					val nh = replace(de.h)
					val na = replace(de.a)
					val nb = replace(de.b)
					val nr = de.r
					if (!nh.hasDE(na, nb, nr)) {
						task = (() => claimDE(nh, na, nb, nr)) :: task
					}
				}
				for (sl <- x.issl) {
					val na = replace(sl.a)
					val nslct = sl.slct
					if (!a.aSL(na, nslct)) {
						task = (() => claimSL(a, na, nslct)) :: task
					}
				}
				for (sl <- x.mksl) {
					val nh = replace(sl.h)
					val na = replace(sl.a)
					val nslct = sl.slct
					if (!nh.aSL(na, nslct)) {
						task = (() => claimSL(nh, na, nslct)) :: task
					}
				}
			}
			for (x <- eqs) {
				x.iscps.toList.foreach(_.dispose())
				x.mkcps.toList.foreach(_.dispose())
				x.ispis.toList.foreach(_.dispose())
				x.mkpis.toList.foreach(_.dispose())
				x.isins.toList.foreach(_.dispose())
				x.mkins.toList.foreach(_.dispose())
				x.iscomp.toList.foreach(_.dispose())
				x.mkcomp.toList.foreach(_.dispose())
				x.isdi.toList.foreach(_.dispose())
				x.mkdi.toList.foreach(_.dispose())
				x.isdu.toList.foreach(_.dispose())
				x.mkdu.toList.foreach(_.dispose())
				x.isde.toList.foreach(_.dispose())
				x.mkde.toList.foreach(_.dispose())
				x.issl.toList.foreach(x => {
					slctPool(x.slct).remove((x.h, x.a))
					x.dispose()
				})
				x.mksl.toList.foreach(x => {
					slctPool(x.slct).remove((x.h, x.a))
					x.dispose()
				})
			}
			
			for (x <- eqs) {
				x.disposers.toList.foreach(_())
			}
			
			for (x <- eqs) {
				x.neTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.subTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.superTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.djtTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.iscpTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.mkcpTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.ispiTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.mkpiTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
				x.isinTriggers.toList.foreach(tg => {
					tg.change(a)
					task = (() => tg.guard.locate()) :: task
				})
			}
			
			for (x <- eqs) {
				assert(x.kne.isEmpty)
				assert(x.assub.isEmpty)
				assert(x.assuper.isEmpty)
				assert(x.djts.isEmpty)
				assert(x.iscps.isEmpty)
				assert(x.mkcps.isEmpty)
				assert(x.ispis.isEmpty)
				assert(x.mkpis.isEmpty)
				assert(x.isins.isEmpty)
				assert(x.mkins.isEmpty)
				
				assert(x.iscomp.isEmpty)
				assert(x.mkcomp.isEmpty)
				assert(x.isdi.isEmpty)
				assert(x.mkdi.isEmpty)
				assert(x.isdu.isEmpty)
				assert(x.mkdu.isEmpty)
				assert(x.isde.isEmpty)
				assert(x.mkde.isEmpty)
				assert(x.issl.isEmpty)
				assert(x.mksl.isEmpty)
				
				assert(x.disposers.isEmpty)
				
				assert(x.neTriggers.isEmpty)
				assert(x.subTriggers.isEmpty)
				assert(x.superTriggers.isEmpty)
				assert(x.djtTriggers.isEmpty)
				assert(x.iscpTriggers.isEmpty)
				assert(x.mkcpTriggers.isEmpty)
				assert(x.ispiTriggers.isEmpty)
				assert(x.mkpiTriggers.isEmpty)
				assert(x.isinTriggers.isEmpty)
			}
			
			for (x <- eqs) {
				x.ref.t = a
			}
			
			task.foreach(_())
		}
		
		////////////////////////////////////////////////////
		
		private[this] def applyNonEmpty(a: IETerm) {
			val tmp = new IEPredNonEmpty(a)
			if (tmp.apply()) {
				tasks.enqueue(() => {
					var task = Nil:List[() => Unit]
					for (pi <- a.ispis) {
						task = (() => claimNonEmpty(pi.compt)) :: task
					}
					for (pi <- a.mkpis) {
						task = (() => claimNonEmpty(pi.head)) :: task
					}
					for (cp <- a.iscps) {
						task = (() => cp.comp.map(_._1).foreach(claimNonEmpty(_))) :: task
					}
					for (cp <- a.mkcps) {
						if (cp.comp.map(_._1).forall(_.knownNE)) {
							task = (() => claimNonEmpty(cp.head)) :: task
						}
					}
					task.foreach(_())
				})
				schedule.enqueue(tmp)
				if (a.disjointTo(a)) {
					contradict(a)
				}
			}
		}
		/**
		 * Claim a term to be non-empty.
		 */
		def claimNonEmpty(a: IETerm) {
			if (!a.knownNE) {
				for (x <- a.superSets) {
					applyNonEmpty(x)
				}
			}
		}
		
		private[this] def applyDisjoint(a: IETerm, b: IETerm) {
			val tmp = new IEPredDisjoint(a, b)
			if (tmp.apply()) {
				tasks.enqueue(() => {
					var task = Nil:List[() => Unit]
					if (a == b) {
						for (api <- a.ispis) {
							task = (() => claimDisjoint(api.compt, api.compt)) :: task
						}
						for (x <- a.mkcps.map(_.head)) {
							task = (() => claimDisjoint(x, x)) :: task
						}
					} else {
						for (api <- a.ispis; bpi <- b.ispis; if api.compr == bpi.compr && api.compt.roles == bpi.compt.roles) {
							task = (() => claimDisjoint(api.compt, bpi.compt)) :: task
						}
						for (xcp <- a.mkcps; ycp <- b.mkcps; if xcp.head.roles == ycp.head.roles && !(xcp.comp.filter(_._1 == a).map(_._2) intersect ycp.comp.filter(_._1 == b).map(_._2)).isEmpty) {
							task = (() => claimDisjoint(xcp.head, ycp.head)) :: task
						}
					}
					task.foreach(_())
				})
				schedule.enqueue(tmp)
				if (a == b && a.knownNE) {
					contradict(a)
				}
			}
		}
		/**
		 * Claim two terms to be disjoint.
		 */
		def claimDisjoint(a: IETerm, b: IETerm) {
			assert(a.roles == b.roles)
			if (!a.disjointTo(b)) {
				if (a == b) {
					val tmp = a.subSets.toList
					for (tl <- tmp.tails; if !tl.isEmpty; x = tl.head; y <- tl) {
						applyDisjoint(x, y)
					}
				} else {
					for (x <- a.subSets; y <- b.subSets) {
						applyDisjoint(x, y)
					}
				}
			}
		}
		
		private[this] def applySubsume(a: IETerm, b: IETerm) {
			val tmp = new IEPredSubsume(a, b)
			if (tmp.apply()) {
				if (a.hasSub(b)) mergePool.add(a)
				tasks.enqueue(() => {
					var task = Nil:List[() => Unit]
					for (in <- b.mkins) {
						if (in.comp.forall(_.hasSub(a))) {
							task = (() => claimSubsume(a, in.head)) :: task
						}
					}
					for (in <- a.mkins intersect b.mkins; if !in.aux) {
						task = (() => claimIN(in.head, in.comp, in.aux)) :: task
					}
					task.foreach(_())
				})
				schedule.enqueue(tmp)
			}
		}
		/**
		 * Claim term `a` to be a subset of term `b`.
		 */
		def claimSubsume(a: IETerm, b: IETerm) {
			assert(a.roles == b.roles)
			if (!a.hasSuper(b)) {
				val bsup = b.superSets
				for (x <- a.subSets; if !x.hasSuper(b)) {
					for (y <- bsup) {
						applySubsume(x, y)
					}
				}
				if (a.knownNE) {
					claimNonEmpty(b)
				}
				for (y <- b.disjointSets) {
					claimDisjoint(a, y)
				}
			}
		}
		
		private[this] def applyCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
			val tmp = new IEPredCP(h, t)
			if (tmp.apply()) {
				val mincps = t.minBy[Int](_._1.mkcps.size)._1.mkcps
				var flag = false
				for (cp <- mincps; if cp != tmp && cp.comp == t) {
					flag = true
					claimSubsume(h, cp.head)
					claimSubsume(cp.head, h)
				}
				if (!flag) {
					tasks.enqueue(() => {
						var task = Nil:List[() => Unit]
						if (h.knownNE) {
							task = (() => t.map(_._1).foreach(claimNonEmpty(_))) :: task
						} else if (t.forall(_._1.knownNE)) {
							task = (() => claimNonEmpty(h)) :: task
						}
						if (t.filter(_._1.isW).size <= 1) {
							for ((x, r) <- t; y <- x.disjointSets; cp <- y.mkcps; cph = cp.head; if cph.roles == h.roles && cp.comp.contains((y, r))) {
								task = (() => claimDisjoint(h, cph)) :: task
							}
						}
						task.foreach(_())
					})
					schedule.enqueue(tmp)
				}
			}
		}
		/**
		 * Claim term `h` to be the Cartesian product of terms in `t`
		 */
		def claimCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
			assert(t.forall(x => (x._1.roles == null) ^ (x._2 == null)))
			
			if (t.size == 1) {
				claimSubsume(h, t.head._1)
				claimSubsume(t.head._1, h)
			} else {
				assert(t.size >= 2)
				assert(h.roles != null)
				assert(h.roles.size == (0 /: t)((x, y) => x + (if (y._2 != null) 1 else y._1.roles.size)))
				assert(h.roles == t.flatMap(x => if (x._2 != null) Set(x._2) else x._1.roles))
				
				var task = Nil:List[() => Unit]
				def addCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
					
					def addCPhkCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
						
						for (cp <- t.minBy[Int](_._1.mkcps.size)._1.mkcps; if t.subsetOf(cp.comp) && t.size != cp.comp.size) {
							val ncomp = (cp.comp -- t) + ((h, null))
							addCP(cp.head, ncomp)
						}
						
						val cands = mutable.Map.empty[Set[(IETerm, SemRole)], (IETerm, SemRole)]
						cands ++= t.map(x => (Set(x), x))
						for (cp <- t.flatMap(_._1.mkcps)) {
							if (cp.comp.subsetOf(t) && t.size != cp.comp.size) {
								cands(cp.comp) = (cp.head, null)
							}
						}
						for (p <- listPartitions[(IETerm, SemRole)](t, cands.keys)) {
							val ncomp = p.map(cands(_)).toSet
							if (!h.hasCP(ncomp)) {
								task = (() => applyCP(h, ncomp)) :: task
							}
						}
						
						val ll = for ((x, r) <- t) yield {
							Set((x, r)) :: x.iscps.toList.map(_.comp)
						}
						for (l <- oneFromEach[Set[(IETerm, SemRole)]](ll)) {
							val ncomp = l.toSet.flatten
							if (!h.hasCP(ncomp) && ncomp != t) {
								task = (() => applyCP(h, ncomp)) :: task
							}
						}
					}
					
					if (!h.hasCP(t)) {
						addCPhkCP(h, t)
						for (cp <- h.mkcps) {
							val ncomp = (cp.comp - ((h, null))) ++ t
							if (!cp.head.hasCP(ncomp)) {
								addCPhkCP(cp.head, ncomp)
							}
						}
					}
				}
				addCP(h, t)
				task.foreach(_())
			}
		}
		
		private[this] def applyPI(h: IETerm, t: IETerm, r: SemRole) {
			val tmp = new IEPredPI(h, t, r)
			if (tmp.apply()) {
				var flag = false
				for (pi <- t.mkpis; if pi != tmp && pi.headrs == tmp.headrs) {
					flag = true
					claimSubsume(h, pi.head)
					claimSubsume(pi.head, h)
				}
				if (!flag) {
					tasks.enqueue(() => {
						if (h.knownNE) {
							claimNonEmpty(t)
						} else if (t.knownNE) {
							claimNonEmpty(h)
						}
						for (x <- h.disjointSets; pi <- x.ispis; if r == pi.compr && t.roles == pi.compt.roles) {
							claimDisjoint(t, pi.compt)
						}
					})
					schedule.enqueue(tmp)
				}
			}
		}
		/**
		 * Claim term `h` to be the projection of term `t` into role `r`
		 */
		def claimPI(h: IETerm, t: IETerm, r: SemRole) {
			assert((h.roles == null) ^ (r == null))
			assert((if (r != null) Set(r) else h.roles).subsetOf(t.roles))
			if (r == null && t.roles.size == h.roles.size) {
				claimSubsume(h, t)
				claimSubsume(t, h)
			} else {
				var task = Nil:List[() => Unit]
				def addPI(h: IETerm, t: IETerm, r: SemRole) {
					
					def addPIhkPI(h: IETerm, t: IETerm, r: SemRole) {
						
						val hrs = if (r == null) h.roles else Set(r)
						
						for (pi <- t.mkpis) {
							if (pi.headrs.subsetOf(hrs) && pi.headrs.size != hrs.size) {
								addPI(pi.head, h, pi.compr)
							}
						}
						
						task = (() => applyPI(h, t, r)) :: task
						for (pi <- t.mkpis) {
							if (hrs.subsetOf(pi.headrs) && pi.headrs.size != hrs.size) {
								if (!h.hasPI(pi.head, r)) {
									task = (() => applyPI(h, pi.head, r)) :: task
								}
							}
						}
						
						for (pi <- t.ispis) {
							if (!h.hasPI(pi.compt, r)) {
								task = (() => applyPI(h, pi.compt, r)) :: task
							}
						}
					}
					
					if (!h.hasPI(t, r)) {
						addPIhkPI(h, t, r)
						for (pi <- h.mkpis) {
							if (!pi.head.hasPI(t, pi.compr)) {
								addPIhkPI(pi.head, t, pi.compr)
							}
						}
					}
				}
				addPI(h, t, r)
				task.foreach(_())
			}
		}
		
		private[this] def applyIN(h: IETerm, t: Set[IETerm], aux: Boolean) {
			def esssub(x: Set[IETerm], y: Set[IETerm]) = x.subsetOf(y.flatMap(z => z.subSets intersect z.superSets))
			h.isins.filter(x => esssub(t, x.comp)).foreach(_.dispose())
			val tmp = new IEPredIN(h, t, aux)
			tmp.apply()
			tasks.enqueue(() => {
				val subs = t.minBy[Int](_.subSize).subSets.filter(x => t.forall(_.hasSub(x)))
				subs.foreach(claimSubsume(_, h))
			})
			if (!aux) schedule.enqueue(tmp)
		}
		/**
		 * Claim term `h` to be the intersection of terms `t`
		 */
		def claimIN(h: IETerm, t: Set[IETerm], aux: Boolean = false) {
			assert(t.forall(_.roles == h.roles))
			
			t.foreach(claimSubsume(h, _))
			
			def squeeze(t: Set[IETerm], norm: Set[IETerm] = null) = {
				val tmp = for (x <- t; if !t.exists(y => y.hasSuper(x) && !x.hasSuper(y))) yield {
					x.superSets intersect x.subSets
				}
				tmp.map(x => {
					if (norm == null) {
						x.head
					} else {
						val comm = (norm intersect x)
						if (comm.isEmpty) x.head else comm.head
					}
				})
			}
			
			def addINhkIN(h: IETerm, t: Set[IETerm], aux: Boolean) {
				
				def addINReduce(h: IETerm, t: Set[IETerm], aux: Boolean) = {
					var ret = Nil:List[Set[IETerm]]
					val comp = squeeze(t)
					if (comp.size > 1) {
						val fil = for {
							in <- h.isins
							sq = squeeze(in.comp, comp)
							if sq.subsetOf(comp)
						} yield ((sq, in.aux))
						if (fil.isEmpty) {
							applyIN(h, comp, aux)
							if (!aux) ret = comp :: ret
						} else if (!aux) {
							for (x <- fil; if x._2 && !fil.exists(y => y != x && y._1.subsetOf(x._1))) {
								if (x._1.size > 1) {
									applyIN(h, x._1, false)
									ret = x._1 :: ret
								} else {
									claimSubsume(x._1.head, h)
								}
							}
						}
					} else {
						claimSubsume(comp.head, h)
					}
					ret
				}
				
				if (h.isins.isEmpty) {
					val comp = squeeze(t)
					if (comp.size > 1) {
						applyIN(h, comp, aux)
						for (in <- h.mkins.toList) {
							in.dispose()
							addINReduce(in.head, in.comp - h ++ comp, in.aux)
						}
					} else {
						claimSubsume(comp.head, h)
					}
				} else {
					val ncomps = addINReduce(h, t, aux)
					if (!ncomps.isEmpty) {
						val whole = h.superSets.filter(x => x.isins.isEmpty)
						for (sub <- h.subSets; if !h.hasSuper(sub)) {
							for (in <- sub.isins.toList; if !in.aux) {
								val (yes, no) = in.comp.partition(whole.contains(_))
								if (!yes.isEmpty) {
									ncomps.foreach(x => addINReduce(sub, no ++ x, false))
								}
							}
						}
					}
				}
				
			}
			
			val mt = squeeze(t)
			if (mt.size == 1) {
				claimSubsume(mt.head, h)
			} else {
				val ll = mt.map(x => if (x.isins.isEmpty) {
						Set((Set(x), false))
					} else {
						x.isins.map(x => (x.comp, x.aux)).toSet
					})
				for (l <- oneFromEach[(Set[IETerm], Boolean)](ll)) {
					val comp = (Set.empty[IETerm] /: l)(_ ++ _._1)
					val laux = aux || l.exists(_._2)
					addINhkIN(h, comp, laux)
				}
			}
		}
		
		/**
		 * Claim `h = tot \ a`. If `tot == null` then `h` is set to the complement of `a`.
		 */
		def claimComp(h: IETerm, a: IETerm, tot: IETerm = null) {
			assert(h.roles == a.roles)
			assert(tot == null || tot.roles == h.roles)
			if ((new IEPredComp(h, a, tot)).apply()) {
				claimDisjoint(h, a)
				if (tot != null) claimSubsume(h, tot)
				applyComp(h, a, tot)
			}
		}
		
		/**
		 * Claim `h = DI(a, b, r)`.
		 */
		def claimDI(h: IETerm, a: IETerm, b: IETerm, r: SemRole) {
			assert(b.roles == null)
			assert(a.roles.contains(r))
			assert(h.roles == (if (a.roles.size == 2) null else a.roles - r))
			if ((new IEPredDI(h, a, b, r)).apply()) {
				claimSubsume(h, getPI(a, a.roles - r))
				val hr = if (h.roles == null) (a.roles - r).head else null
				claimSubsume(getCP(Set((h, hr), (b, r))), a)
				applyDI(h, a, b, r)
			}
		}
		
		/**
		 * Claim `h = DU(a, b, r)`.
		 */
		def claimDU(h: IETerm, a: IETerm, b: IETerm, r: SemRole) {
			assert(b.roles == null)
			assert(a.roles.contains(r))
			assert(h.roles == (if (a.roles.size == 2) null else a.roles - r))
			if ((new IEPredDU(h, a, b, r)).apply()) {
				val pia = getPI(a, a.roles - r)
				val hr = if (h.roles == null) (a.roles - r).head else null
				val bw = getCP(Set((b, r), (getW(h.roles), hr)))
				val hcompl = getPI(getIN(Set(bw, a)), a.roles - r)
				val tot = getCP(Set((pia, hr), (getW(null), r)))
				claimDI(h, getComp(a, tot), b, r)
				claimComp(h, hcompl, pia)
			}
		}
		
		/**
		 * Claim `h = DE(a, b, r)`.
		 */
		def claimDE(h: IETerm, a: IETerm, b: IETerm, r: SemRole) {
			assert(b.roles == null)
			assert(a.roles.contains(r))
			assert(h.roles == (if (a.roles.size == 2) null else a.roles - r))
			if ((new IEPredDE(h, a, b, r)).apply()) {
				claimSubsume(h, getPI(a, a.roles - r))
				val hr = if (h.roles == null) (a.roles - r).head else null
				claimIN(getCP(Set((h, hr), (b, r))), Set(getCP(Set((h, hr), (getW(null), r))), a))
				applyDE(h, a, b, r)
			}
		}
		
		/**
		 * Claim `IEPredSL(h, a, slct)`.
		 */
		def claimSL(h: IETerm, a: IETerm, slct: Slction) {
			val tmp = new IEPredSL(h, a, slct)
			if (tmp.apply()) {
				slct.applySL(h, a, this)
				slctAdd(tmp)
			}
		}
		
		////////////////////////////////////////////////////
		
		protected[this] def contradict(a: IETerm): Unit
		protected[this] def applyComp(h: IETerm, a: IETerm, tot: IETerm): Unit
		protected[this] def applyDI(h: IETerm, a: IETerm, b: IETerm, r: SemRole): Unit
		protected[this] def applyDE(h: IETerm, a: IETerm, b: IETerm, r: SemRole): Unit
		
	}
	
	/**
	 * Interface for implementing a selection operator.
	 */
	abstract class Slction extends Serializable {
		/**
		 * Definition process for a selection. Write your own axioms here.
		 * 
		 * @param h The new term corresponding to the selection.
		 * @param a The term being selected.
		 * @param ie The inference engine.
		 */
		def applySL(h: IETerm, a: IETerm, ie: IEngine): Unit
	}
	
}
