package tifmo

import mylib.oneFromEach
import mylib.listPartitions
import knowledge.SemRole.SemRole
import scala.collection.mutable
import scala.util.Sorting

package inference {
	/**
	 * The abstract class of a forward chaining inference engine for algebraic 
	 * forms. 
	 * 
	 * This class implements the forward chaining algorithm, provides the 
	 * infra structure for writing rules, and implements basic axioms of 
	 * relational algebra in a way that can avoid most of combinatorial explosions. 
	 */
	abstract class IEngine {
		
		private[this] val W = new IETerm(null, true, 0)
		(new IEPredNonEmpty(W)).apply()
		(new IEPredSubsume(W, W)).apply()
		
		private[this] var counter = 1
		def getCount = counter
		
		private[this] val WPool = mutable.Map((null:Set[SemRole], W))
		/**
		 * Get the W term of dimension `roles`.
		 */
		def getW(roles: Set[SemRole]) = {
			if (WPool.contains(roles)) {
				WPool(roles)
			} else {
				val ret = new IETerm(roles, true, counter)
				counter += 1
				(new IEPredNonEmpty(ret)).apply()
				(new IEPredSubsume(ret, ret)).apply()
				claimCP(ret, roles.map(r => (W, r)))
				WPool(roles) = ret
				ret
			}
		}
		
		private[this] val anyTermPool = mutable.Set.empty[(IETerm, List[Any]) => Set[IETerm] => Unit]
		/**
		 * Get a new non-W term.
		 */
		protected def newTerm(roles: Set[SemRole]) = {
			val term = new IETerm(roles, false, counter)
			counter += 1
			anyTermPool.foreach(_(term, Nil)(Set.empty[IETerm]))
			applySubsume(term, term)
			val w = getW(roles)
			for (x <- w.superSets) {
				applySubsume(term, x)
			}
			term
		}
		/**
		 * Get Cartesian product.
		 */
		def getCP(comp: Set[(IETerm, SemRole)]) = {
			assert(comp.size >= 1)
			if (comp.size == 1) {
				comp.head._1
			} else {
				val cps = comp.minBy[Int](_._1.mkcps.size)._1.mkcps
				cps.find(_.comp == comp) match {
					case Some(x) => x.head
					case None => {
						val roles = comp.flatMap(x => if (x._2 != null) Set(x._2) else x._1.roles)
						val ret = newTerm(roles)
						//println("new term " + ret + " is CP of " + comp)
						claimCP(ret, comp)
						ret
					}
				}
			}
		}
		/**
		 * Get projection.
		 */
		def getPI(compt: IETerm, headrs: Set[SemRole]) = {
			compt.mkpis.find(_.headrs == headrs) match {
				case Some(x) => x.head
				case None => {
					val roles = if (headrs.size == 1) null else headrs
					val ret = newTerm(roles)
					//println("new term " + ret + " is PI of " + compt + " to " + headrs)
					claimPI(ret, compt, if (headrs.size == 1) headrs.head else null)
					ret
				}
			}
		}
		/**
		 * Get intersection.
		 */
		def getIN(comp: Set[IETerm], aux: Boolean = false) = {
			val whole = comp.flatMap(_.superSets.filter(_.isins.isEmpty))
			val minsub = comp.minBy[Int](_.subSize).subSets
			minsub.find(x => comp.forall(x.hasSuper(_)) && {
				whole.contains(x) || {
					x.isins.find(_.comp.subsetOf(whole)) match {
						case Some(y) => {
							if (!aux && y.aux) applyIN(x, y.comp, false)
							true
						}
						case None => false
					}
				}
			}) match {
				case Some(x) => x
				case None => {
					val roles = comp.head.roles
					val ret = newTerm(roles)
					//println("new term " + ret + " is IN of " + comp)
					claimIN(ret, comp, aux)
					ret
				}
			}
		}
		
		///////////////////////////////////////////////////////////////
		
		private[this] def applyNonEmpty(a: IETerm) {
			val tmp = new IEPredNonEmpty(a)
			if (tmp.apply()) {
				triggers.enqueue(() => {
					val amkpil = a.mkpis.map(_.head).toList
					val aispil = a.ispis.map(_.compt).toList
					val amkcpl = a.mkcps.toList
					val aiscpl = a.iscps.flatMap(_.comp.map(_._1)).toList
					val al = a.neTriggers.toList
					amkpil.foreach(x => claimNonEmpty(x))
					aispil.foreach(x => claimNonEmpty(x))
					for (cp <- amkcpl) {
						if (cp.comp.forall(_._1.knownNE)) {
							claimNonEmpty(cp.head)
						}
					}
					aiscpl.foreach(x => claimNonEmpty(x))
					al.foreach(x => x.fire())
				})
				if (a.disjointTo(a)) {
					contradict(a)
				}
			}
		}
		/**
		 * Claim a term to be non-empty.
		 */
		def claimNonEmpty(a: IETerm) {
			if (!a.knownNE) {
				var task = Nil:List[() => Unit]
				for (x <- a.superSets; if !x.knownNE) {
					task = (() => applyNonEmpty(x)) :: task
				}
				task.foreach(_())
			}
		}
		
		private[this] def applyDisjoint(a: IETerm, b: IETerm) {
			val tmp = new IEPredDisjoint(a, b)
			if (tmp.apply()) {
				triggers.enqueue(() => {
					if (a == b) {
						val api = a.asPI
						val acpl = a.mkcps.map(_.head).toList
						val al = a.djtTriggers.toList
						api.foreach(x => claimDisjoint(x._1, x._1))
						acpl.foreach(x => claimDisjoint(x, x))
						al.foreach(x => x.fire(b))
					} else {
						val api = a.asPI
						val bpi = b.asPI
						val acpl = a.mkcps.toList
						val bcpl = b.mkcps.toList
						val al = a.djtTriggers.toList
						val bl = b.djtTriggers.toList
						for ((x, r) <- api; (y, rr) <- bpi; if r == rr && x.roles == y.roles) {
							claimDisjoint(x, y)
						}
						for (xcp <- acpl; ycp <- bcpl; if xcp.head.roles == ycp.head.roles && !(xcp.comp.filter(_._1 == a).map(_._2) intersect ycp.comp.filter(_._1 == b).map(_._2)).isEmpty) {
							claimDisjoint(xcp.head, ycp.head)
						}
						al.foreach(x => x.fire(b))
						bl.foreach(x => x.fire(a))
					}
				})
				if (a == b && a.knownNE) {
					contradict(a)
				}
			}
		}
		/**
		 * Claim two terms to be disjoint.
		 */
		def claimDisjoint(a: IETerm, b: IETerm) {
			assert(a.roles == b.roles)
			if (!a.disjointTo(b)) {
				var task = Nil:List[() => Unit]
				if (a == b) {
					for (tl <- a.subSets.tails; if !tl.isEmpty; x = tl.head; y <- tl) {
						if (!x.disjointTo(y)) {
							task = (() => applyDisjoint(x, y)) :: task
						}
					}
				} else {
					for (x <- a.subSets; y <- b.subSets) {
						if (!x.disjointTo(y)) {
							task = (() => applyDisjoint(x, y)) :: task
						}
					}
				}
				task.foreach(_())
			}
		}
		
		private[this] def applySubsume(a: IETerm, b: IETerm) {
			val tmp = new IEPredSubsume(a, b)
			if (tmp.apply()) {
				triggers.enqueue(() => {
					var task = Nil:List[() => Unit]
					for (x <- a.mkcps; y <- b.mkcps; if x.roleMap.keySet == y.roleMap.keySet) {
						if (x.roleMap.keys.forall(k => x.roleMap(k).hasSuper(y.roleMap(k)))) {
							task = (() => claimSubsume(x.head, y.head)) :: task
						}
					}
					for (in <- b.mkins) {
						if (in.comp.forall(_.hasSub(a))) {
							task = (() => claimSubsume(a, in.head)) :: task
						}
					}
					if (a.isins.isEmpty) {
						for (in <- b.mkins) {
							if (in.comp.contains(a)) {
								task = (() => claimIN(in.head, in.comp, in.aux)) :: task
							}
						}
					}
					/*
					if (b.isins.isEmpty) {
						val whole = a.superSets.filter(_.isins.isEmpty)
						for (x <- b.mkins.filter(!_.aux).map(_.head).filter(_.hasSuper(a))) {
							val tocovs = x.isins.filter(y => !y.aux && y.comp.contains(b)).map(y => {
								val (yes, no) = y.comp.partition(whole.contains(_))
								(no, Set(yes))
							}).toSet
							for (y <- x.calcIN(tocovs); yy = y + a; if yy.size >= 2) {
								for (z <- x.isinTriggers) {
									task = (() => z.fire(yy)) :: task
								}
							}
						}
					}
					*/
					val al = a.subTriggers.toList
					val bl = b.superTriggers.toList
					al.foreach(_.fire(b))
					bl.foreach(_.fire(a))
					task.foreach(_())
				})
				if (a.hasSub(b)) {
					mergePool.add(a.ref)
				}
			}
		}
		/**
		 * Claim term `a` to be a subset of term `b`.
		 */
		def claimSubsume(a: IETerm, b: IETerm) {
			assert(a.roles == b.roles)
			if (!a.hasSuper(b)) {
				var task = Nil:List[() => Unit]
				for (x <- a.subSets; if !x.hasSuper(b)) {
					for (y <- b.superSets; if !x.hasSuper(y)) {
						task = (() => applySubsume(x, y)) :: task
					}
				}
				task.foreach(_())
				if (a.knownNE) {
					claimNonEmpty(b)
				}
				for (y <- b.disjointSets) {
					claimDisjoint(a, y)
				}
			}
		}
		
		private[this] def findAllCP(ll: Set[Set[(IETerm, SemRole)]]) = {
			val sll = Sorting.stableSort[Set[(IETerm, SemRole)], Int](ll.toList, _.size).toList
			val kk = oneFromEach.map[(IETerm, SemRole), (Set[IETerm], Set[(IETerm, SemRole)])](sll, null, (x, y) => {
				if (x == null) {
					(y._1.mkcps.map(_.head).toSet, Set(y))
				} else {
					val tmp = y._1.mkcps.map(_.head)
					(x._1.filter(tmp.contains(_)), x._2 + y)
				}
			}, _._1.isEmpty)
			kk.flatMap(x => x._1.filter(y => y.hasCP(x._2)))
		}
		private[this] def applyCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
			val tmp = new IEPredCP(h, t)
			if (tmp.apply()) {
				triggers.enqueue(() => {
					var task = Nil:List[() => Unit]
					if (h.knownNE) {
						t.foreach(x => task = (() => claimNonEmpty(x._1)) :: task)
					} else if (t.forall(_._1.knownNE)) {
						task = (() => claimNonEmpty(h)) :: task
					}
					if (t.filter(_._1.isW).size <= 1) {
						val llsuper = t.map(x => x._1.superSets.map(y => (y, x._2)))
						for (x <- findAllCP(llsuper)) {
							task = (() => claimSubsume(h, x)) :: task
						}
						val llsub = t.map(x => x._1.subSets.map(y => (y, x._2)))
						for (x <- findAllCP(llsub)) {
							task = (() => claimSubsume(x, h)) :: task
						}
						for ((x, r) <- t; y <- x.disjointSets; cp <- y.mkcps; cph = cp.head; if cph.roles == h.roles && cp.comp.contains((y, r))) {
							task = (() => claimDisjoint(h, cph)) :: task
						}
					}
					val hl = h.iscpTriggers.toList
					val tl = t.map(_._1).toList.flatMap(_.mkcpTriggers)
					task.foreach(_())
					hl.foreach(x => x.fire(t))
					tl.foreach(x => x.fire(h, t))
				})
				val dups = t.map(_._1).minBy[Int](_.mkcps.size).mkcps.filter(_.comp == t).toSet - tmp
				if (!dups.isEmpty) {
					for (dup <- dups) {
						claimSubsume(h, dup.head)
						claimSubsume(dup.head, h)
					}
				}
			}
		}
		/**
		 * Claim term `h` to be the Cartesian product of terms in `t`
		 */
		def claimCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
			assert(t.forall(x => (x._1.roles == null) ^ (x._2 == null)))
			
			if (t.size == 1) {
				claimSubsume(h, t.head._1)
				claimSubsume(t.head._1, h)
			} else {
				assert(t.size >= 2)
				assert(h.roles != null)
				assert(h.roles.size == (0 /: t)((x, y) => x + (if (y._2 != null) 1 else y._1.roles.size)))
				assert(h.roles == t.flatMap(x => if (x._2 != null) Set(x._2) else x._1.roles))
				
				var task = Nil:List[() => Unit]
				def addCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
					
					def addCPhkCP(h: IETerm, t: Set[(IETerm, SemRole)]) {
						
						for (cp <- t.minBy[Int](_._1.mkcps.size)._1.mkcps; if t.subsetOf(cp.comp) && t.size != cp.comp.size) {
							val ncomp = (cp.comp -- t) + ((h, null))
							addCP(cp.head, ncomp)
						}
						
						val cands = mutable.Map.empty[Set[(IETerm, SemRole)], (IETerm, SemRole)]
						cands ++= t.map(x => (Set(x), x))
						for (cp <- t.flatMap(_._1.mkcps)) {
							if (cp.comp.subsetOf(t) && t.size != cp.comp.size) {
								cands(cp.comp) = (cp.head, null)
							}
						}
						for (p <- listPartitions[(IETerm, SemRole)](t, cands.keys)) {
							val ncomp = p.map(cands(_)).toSet
							if (!h.hasCP(ncomp)) {
								task = (() => applyCP(h, ncomp)) :: task
							}
						}
						
						val ll = for ((x, r) <- t) yield {
							if (r == null) x.asCP + Set((x, null)) else Set(Set((x, r)))
						}
						for (l <- oneFromEach[Set[(IETerm, SemRole)]](ll)) {
							val ncomp = l.toSet.flatten
							if (!h.hasCP(ncomp) && ncomp != t) {
								task = (() => applyCP(h, ncomp)) :: task
							}
						}
					}
					
					if (!h.hasCP(t)) {
						addCPhkCP(h, t)
						for (cp <- h.mkcps) {
							val ncomp = (cp.comp - ((h, null))) ++ t
							if (!cp.head.hasCP(ncomp)) {
								addCPhkCP(cp.head, ncomp)
							}
						}
					}
				}
				
				//System.err.println("claim CP start.")
				
				addCP(h, t)
				task.foreach(_())
				
				//System.err.println("claim CP end.")
			}
		}
		
		private[this] def applyPI(h: IETerm, t: IETerm, r: SemRole) {
			val tmp = new IEPredPI(h, t, r)
			if (tmp.apply()) {
				triggers.enqueue(() => {
					val hl = h.ispiTriggers.toList
					val tl = t.mkpiTriggers.toList
					val djtpi = h.disjointSets.flatMap(_.asPI)
					if (h.knownNE) {
						claimNonEmpty(t)
					} else if (t.knownNE) {
						claimNonEmpty(h)
					}
					for ((x, rr) <- djtpi; if r == rr && t.roles == x.roles) {
						claimDisjoint(t, x)
					}
					hl.foreach(x => x.fire(t, r))
					tl.foreach(x => x.fire(h, r))
				})
				val dups = t.mkpis.filter(_.headrs == tmp.headrs).toSet - tmp
				if (!dups.isEmpty) {
					for (dup <- dups) {
						claimSubsume(h, dup.head)
						claimSubsume(dup.head, h)
					}
				}
			}
		}
		/**
		 * Claim term `h` to be the projection of term `t` into role `r`
		 */
		def claimPI(h: IETerm, t: IETerm, r: SemRole) {
			assert((h.roles == null) ^ (r == null))
			assert((if (r != null) Set(r) else h.roles).subsetOf(t.roles))
			
			if (r == null && t.roles.size == h.roles.size) {
				claimSubsume(h, t)
				claimSubsume(t, h)
			} else {
				var task = Nil:List[() => Unit]
				def addPI(h: IETerm, t: IETerm, r: SemRole) {
					
					def addPIhkPI(h: IETerm, t: IETerm, r: SemRole) {
						
						val hrs = if (r == null) h.roles else Set(r)
						
						for (pi <- t.mkpis) {
							if (pi.headrs.subsetOf(hrs) && pi.headrs.size != hrs.size) {
								addPI(pi.head, h, pi.compr)
							}
						}
						
						task = (() => applyPI(h, t, r)) :: task
						for (pi <- t.mkpis) {
							if (hrs.subsetOf(pi.headrs) && pi.headrs.size != hrs.size) {
								if (!h.hasPI(pi.head, r)) {
									task = (() => applyPI(h, pi.head, r)) :: task
								}
							}
						}
						
						for ((compt, compr) <- t.asPI) {
							if (!h.hasPI(compt, r)) {
								task = (() => applyPI(h, compt, r)) :: task
							}
						}
					}
					
					if (!h.hasPI(t, r)) {
						addPIhkPI(h, t, r)
						for (pi <- h.mkpis) {
							if (!pi.head.hasPI(t, pi.compr)) {
								addPIhkPI(pi.head, t, pi.compr)
							}
						}
					}
				}
				addPI(h, t, r)
				task.foreach(_())
			}
		}
		
		private[this] def squeeze(t: Set[IETerm]) = {
			val fil = t.filter(x => !t.exists(y => y.hasSuper(x) && !x.hasSuper(y)))
			fil.map(x => fil.filter(y => y.hasSuper(x) && y.hasSub(x))).map(_.head)
		}
		//private[this] def multi(fil: Set[IETerm]) = {
		//	fil.map(x => fil.filter(y => y.hasSuper(x) && y.hasSub(x))).size > 1
		//}
		private[this] def applyIN(h: IETerm, t: Set[IETerm], aux: Boolean) {
			h.isins.filter(x => t.subsetOf(x.comp)).foreach(_.dispose())
			//if (!multi(t)) {
			if (t.size == 1) {
				claimSubsume(t.head, h)
			} else {
				val subs = t.minBy[Int](_.subSize).subSets.filter(x => t.forall(_.hasSub(x)))
				subs.foreach(claimSubsume(_, h))
				val tmp = new IEPredIN(h, t, aux)
				if (tmp.apply()) {
					if (!aux) {
						/*
						triggers.enqueue(() => {
							val hl = h.isinTriggers.toList
							for (x <- h.calcIN(Set((t, Set.empty[Set[IETerm]]))); if x.size >= 2) {
								hl.foreach(_.fire(x))
							}
						})
						*/
						triggers.enqueue(() => {
							h.isinTriggers.toList.foreach(_.fire(t))
						})
					}
				}
			}
		}
		/**
		 * Claim term `h` to be the intersection of terms `t`
		 */
		def claimIN(h: IETerm, t: Set[IETerm], aux: Boolean = false) {
			assert(t.forall(_.roles == h.roles))
			
			t.foreach(claimSubsume(h, _))
			
			def addINhkIN(h: IETerm, t: Set[IETerm], aux: Boolean) {
				
				def addINReduce(h: IETerm, t: Set[IETerm], aux: Boolean) = {
					val comp = squeeze(t)
					//if (multi(comp)) {
					if (comp.size > 1) {
					//val csize = comp.map(x => comp.filter(y => y.hasSuper(x) && y.hasSub(x))).size
					//if (csize > 9) {
					//	false
					//} else if (csize > 1) {
						
						if (!aux) {
							for (in <- h.isins.toList; if in.aux && in.comp.subsetOf(comp)) {
								val sq = squeeze(in.comp)
								if (!h.isins.exists(_.comp.subsetOf(sq))) {
									applyIN(h, sq, false)
								}
							}
						}
						
						if (!h.isins.exists(_.comp.subsetOf(comp))) {
							val faux = aux && h.isins.forall(x => x.aux || !comp.subsetOf(x.comp))
							applyIN(h, comp, faux)
							true
						} else {
							false
						}
					} else {
						claimSubsume(comp.head, h)
						false
					}
				}
				
				if (addINReduce(h, t, aux)) {
					if (h.isins.isEmpty) {
						for (in <- h.mkins.toList) {
							in.dispose()
							addINReduce(in.head, (in.comp - h) ++ t, in.aux)
						}
					} else {
						
						if (!aux) {
						
							val whole = h.superSets.filter(x => !h.hasSub(x) && x.isins.isEmpty)
							for (sub <- h.subSets; if !h.hasSuper(sub)) {
//								for (in <- sub.isins.toList) {
								for (in <- sub.isins.toList; if !in.aux) {
									val (yes, no) = in.comp.partition(whole.contains(_))
									if (!yes.isEmpty) {
										//addINReduce(sub, no ++ t, aux || in.aux)
										addINReduce(sub, no ++ t, false)
									}
								}
							}
							
						}
						
						
					}
				}
			}
			val mt = squeeze(t)
			//if (!multi(mt)) {
			if (mt.size == 1) {
				claimSubsume(mt.head, h)
			} else {
				val ll = mt.map(x => if (x.isins.isEmpty) {
						Set((Set(x), false))
					} else {
						x.isins.map(x => (x.comp, x.aux)).toSet
					})
				
				//System.err.println("claim IN start: " + ll.toList.map(_.size))
				
				for (l <- oneFromEach[(Set[IETerm], Boolean)](ll)) {
					val comp = (Set.empty[IETerm] /: l)(_ ++ _._1)
					val laux = aux || l.exists(_._2) || comp.size > 7
					addINhkIN(h, comp, laux)
				}
				
				//System.err.println("claim IN end.")
			}
		}
		
		////////////////////////////////////////////////////////////
		
		private[this] var triggers = mutable.Queue.empty[() => Unit]
		
		private[this] val mergePool = mutable.Set.empty[IETermRef]
		private[this] def selectOneInEquiv(a: IETermRef) = {
			val eqa = a.to.superSets intersect a.to.subSets
			eqa.find(_.isW) match {
				case Some(x) => (x, eqa)
				case None => {
					val tmp = eqa.minBy[Int](x => -x.iscps.size - x.mkcps.size - 
						x.isins.size - x.mkins.size - x.ispis.size - x.mkpis.size)
					(tmp, eqa)
				}
			}
		}
		private[this] def mergeEquivToOne(eqs: Set[IETerm], a: IETerm) {
			assert(!eqs.contains(a))
			
			assert(eqs.forall(_.knownNE == a.knownNE))
			if (a.knownNE) {
				eqs.foreach(_.kne.dispose())
			}
			for (x <- eqs) {
				x.assub.toList.foreach(_.dispose())
				x.assuper.toList.foreach(_.dispose())
				x.djts.toList.foreach(_.dispose())
			}
			
			def replace(x: IETerm) = if (eqs.contains(x)) a else x
			
			var task = Nil:List[() => Unit]
			
			for (x <- eqs) {
				for (cp <- x.iscps) {
					val ncomp = cp.comp.map(y => (replace(y._1), y._2))
					if (!a.hasCP(ncomp)) {
						task = (() => claimCP(a, ncomp)) :: task
					}
				}
				for (cp <- x.mkcps) {
					val nhead = replace(cp.head)
					val ncomp = cp.comp.map(y => (replace(y._1), y._2))
					if (!nhead.hasCP(ncomp)) {
						task = (() => claimCP(nhead, ncomp)) :: task
					}
				}
				for (pi <- x.ispis) {
					val ncompt = replace(pi.compt)
					val ncompr = pi.compr
					if (!a.hasPI(ncompt, ncompr)) {
						task = (() => claimPI(a, ncompt, ncompr)) :: task
					}
				}
				for (pi <- x.mkpis) {
					val nhead = replace(pi.head)
					val ncompr = pi.compr
					if (!nhead.hasPI(a, ncompr)) {
						task = (() => claimPI(nhead, a, ncompr)) :: task
					}
				}
				for (in <- x.isins) {
					val ncomp = in.comp.map(replace(_))
					val naux = in.aux
					if (!a.isins.contains(new IEPredIN(a, ncomp, naux))) {
						task = (() => claimIN(a, ncomp, naux)) :: task
					}
				}
				for (in <- x.mkins) {
					val nhead = replace(in.head)
					val ncomp = in.comp.map(replace(_))
					val naux = in.aux
					if (!nhead.isins.contains(new IEPredIN(nhead, ncomp, naux))) {
						task = (() => claimIN(nhead, ncomp, naux)) :: task
					}
				}
			}
			for (x <- eqs) {
				x.iscps.toList.foreach(_.dispose())
				x.mkcps.toList.foreach(_.dispose())
				x.ispis.toList.foreach(_.dispose())
				x.mkpis.toList.foreach(_.dispose())
				x.isins.toList.foreach(_.dispose())
				x.mkins.toList.foreach(_.dispose())
			}
			
			for (x <- eqs) {
				x.ref.t = a
			}
			
			for (x <- eqs) {
				for (sp <- x.specifics) {
					val nsp = sp.change(eqs, a)
					if (nsp != null && nsp.isNew) {
						task = (() => nsp.fire()) :: task
					}
				}
			}
			
			for (x <- eqs) {
				x.disposers.toList.foreach(_())
			}
			
			for (x <- eqs) {
				assert(x.kne == null)
				assert(x.neTriggers.isEmpty)
				assert(x.assub.isEmpty)
				assert(x.subTriggers.isEmpty)
				assert(x.assuper.isEmpty)
				assert(x.superTriggers.isEmpty)
				assert(x.djts.isEmpty)
				assert(x.djtTriggers.isEmpty)
				assert(x.iscps.isEmpty)
				assert(x.iscpTriggers.isEmpty)
				assert(x.mkcps.isEmpty)
				assert(x.mkcpTriggers.isEmpty)
				assert(x.ispis.isEmpty)
				assert(x.ispiTriggers.isEmpty)
				assert(x.mkpis.isEmpty)
				assert(x.mkpiTriggers.isEmpty)
				assert(x.isins.isEmpty)
				assert(x.isinTriggers.isEmpty)
				assert(x.mkins.isEmpty)
				assert(x.specifics.isEmpty)
				assert(x.disposers.isEmpty)
			}
			
			task.foreach(_())
		}
		
		private[this] var lastcounter = 0
		def getLastCount = lastcounter
		
		private[this] val constructQ = mutable.Queue.empty[() => Unit]
		
		/**
		 * Do forward chaining process. 
		 */
		def explore() {
			def loop1() {
				while (!triggers.isEmpty) {
					triggers.dequeue()()
				}
			}
			def loop2() {
				loop1()
				while (!mergePool.isEmpty) {
					val tmp = mergePool.head
					mergePool.remove(tmp)
					val (a, eqa) = selectOneInEquiv(tmp)
					if (eqa.size >= 2) {
						mergeEquivToOne(eqa - a, a)
						
						System.err.println("Merged " + eqa.size + " terms to one. Total: " + getCount)
						
						loop1()
					}
				}
			}
			loop2()
			while (!constructQ.isEmpty) {
				constructQ.dequeue()()
				loop2()
			}
			lastcounter = getCount
		}
		
		///////////////////////////////////////////////////////////////
		
		protected def contradict(a: IETerm): Unit
		
		protected def forAnyTerm(f: (IETerm, List[Any]) => Set[IETerm] => Unit) {
			anyTermPool.add(f)
		}
		
		def conclude(args: List[Any], f: (List[Any]) => Unit)(dep: Set[IETerm]) {
			f(args)
		}
		
		def forSpecific(terms: List[IETerm], args: List[Any], 
				f: (List[IETerm], List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(terms.forall(x => x.ref.to == x))
			assert(dep.forall(x => x.ref.to == x))
			val sp = new SpecificFunc(terms, args, f, dep)
			if (sp.isNew) {
				sp.fire()
			}
		}
		
		def constructCP(comp: Set[(IETerm, SemRole)], args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(dep.forall(x => x.ref.to == x))
			assert(comp.size >= 1)
			if (comp.size == 1) {
				f(comp.head._1, args)(dep)
			} else {
				val cps = comp.minBy[Int](_._1.mkcps.size)._1.mkcps
				cps.find(_.comp == comp) match {
					case Some(x) => f(x.head, args)(dep)
					case None => {
						val compref = comp.map(x => (x._1.ref, x._2))
						constructQ.enqueue(() => {
							if (dep.forall(x => x.ref.to == x)) {
								val tm = getCP(compref.map(x => (x._1.to, x._2)))
								f(tm, args)(dep)
							}
						})
					}
				}
			}
		}
		
		def constructPI(compt: IETerm, headrs: Set[SemRole], args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(dep.forall(x => x.ref.to == x))
			compt.mkpis.find(_.headrs == headrs) match {
				case Some(x) => f(x.head, args)(dep)
				case None => {
					val comptref = compt.ref
					constructQ.enqueue(() => {
						if (dep.forall(x => x.ref.to == x)) {
							val tm = getPI(comptref.to, headrs)
							f(tm, args)(dep)
						}
					})
				}
			}
		}
		
		def constructIN(comp: Set[IETerm], args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(dep.forall(x => x.ref.to == x))
			val minsub = comp.minBy[Int](_.subSize).subSets
			minsub.find(_.hasIN(comp)) match {
				case Some(x) => f(x, args)(dep)
				case None => {
					val compref = comp.map(_.ref)
					constructQ.enqueue(() => {
						if (dep.forall(x => x.ref.to == x)) {
							val tm = getIN(compref.map(_.to), true)
							f(tm, args)(dep)
						}
					})
				}
			}
		}
		
		def forCPof(comp: Set[(IETerm, SemRole)], args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(comp.forall(x => (x._1.roles == null) ^ (x._2 == null)))
			assert(comp.flatMap(x => if (x._2 != null) Set(x._2) else x._1.roles).size == 
				(0 /: comp)((x, y) => x + (if (y._2 != null) 1 else y._1.roles.size)))
			assert(comp.forall(x => x._1.ref.to == x._1))
			assert(dep.forall(x => x.ref.to == x))
			val cps = comp.minBy[Int](_._1.mkcps.size)._1.mkcps
			cps.find(_.comp == comp) match {
				case Some(x) => f(x.head, args)(dep ++ comp.map(_._1))
				case None => new TriggerMkCPIf(comp, args, f, dep ++ comp.map(_._1))
			}
		}
		
		def forPIof(compt: IETerm, headrs: Set[SemRole], args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(headrs.subsetOf(compt.roles) && headrs != compt.roles)
			assert(compt.ref.to == compt)
			assert(dep.forall(x => x.ref.to == x))
			compt.mkpis.find(_.headrs == headrs) match {
				case Some(x) => f(x.head, args)(dep + compt)
				case None => new TriggerMkPIIf(compt, headrs, args, f, dep + compt)
			}
		}
		
		def ifNotEmpty(term: IETerm, args: List[Any], 
				f: (List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			if (term.knownNE) f(args)(dep + term) else new TriggerNE(term, args, f, dep + term)
		}
		
		def ifSubsume(a: IETerm, b: IETerm, args: List[Any], 
				f: (List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(a.roles == b.roles)
			assert(a.ref.to == a)
			assert(b.ref.to == b)
			assert(dep.forall(x => x.ref.to == x))
			if (a.hasSuper(b)) f(args)((dep + a) + b) else new TriggerSubIf(a, b, args, f, (dep + a) + b)
		}
		
		def ifDisjoint(a: IETerm, b: IETerm, args: List[Any], 
				f: (List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(a.roles == b.roles)
			assert(a.ref.to == a)
			assert(b.ref.to == b)
			assert(dep.forall(x => x.ref.to == x))
			if (a.disjointTo(b)) f(args)((dep + a) + b) else new TriggerDjtIf(a, b, args, f, (dep + a) + b)
		}
		
		def foreachSuperset(term: IETerm, args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerSub(term, args, f, dep + term)
			if (tg.isNew) {
				for (x <- term.superSets) {
					f(x, args)(dep + term)
				}
			}
		}
		
		def foreachSubset(term: IETerm, args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerSuper(term, args, f, dep + term)
			if (tg.isNew) {
				for (x <- term.subSets) {
					f(x, args)(dep + term)
				}
			}
		}
		
		def foreachDisjoint(term: IETerm, args: List[Any], 
				f: (IETerm, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerDjt(term, args, f, dep + term)
			if (tg.isNew) {
				for (x <- term.disjointSets) {
					f(x, args)(dep + term)
				}
			}
		}
		
		def foreachIsCP(term: IETerm, args: List[Any], 
				f: (Set[(IETerm, SemRole)], List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.roles != null)
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerIsCP(term, args, f, dep + term)
			if (tg.isNew) {
				for (x <- term.asCP) {
					f(x, args)(dep + term)
				}
			}
		}
		
		def foreachMkCP(term: IETerm, args: List[Any], 
				f: (IETerm, Set[(IETerm, SemRole)], List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerMkCP(term, args, f, dep + term)
			if (tg.isNew) {
				for (cp <- term.mkcps.toList) {
					f(cp.head, cp.comp, args)(dep + term)
				}
			}
		}
		
		def foreachIsPI(term: IETerm, args: List[Any], 
				f: (IETerm, SemRole, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerIsPI(term, args, f, dep + term)
			if (tg.isNew) {
				for ((x, r) <- term.asPI) {
					f(x, r, args)(dep + term)
				}
			}
		}
		
		def foreachMkPI(term: IETerm, args: List[Any], 
				f: (IETerm, SemRole, List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.roles != null)
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerMkPI(term, args, f, dep + term)
			if (tg.isNew) {
				for (pi <- term.mkpis.toList) {
					f(pi.head, pi.compr, args)(dep + term)
				}
			}
		}
		/*
		def foreachIsIN(term: IETerm, args: List[Any], 
				f: (Set[IETerm], List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tocovs = term.isins.filter(!_.aux).map(x => (x.comp, Set.empty[Set[IETerm]])).toSet
			val tg = new TriggerIsIN(term, args, f, dep + term)
			if (tg.isNew) {
				for (x <- term.calcIN(tocovs); if x.size >= 2) {
					f(x, args)(dep + term)
				}
			}
		}
		*/
		def foreachIsIN(term: IETerm, args: List[Any], 
				f: (Set[IETerm], List[Any]) => Set[IETerm] => Unit)(dep: Set[IETerm]) {
			assert(term.ref.to == term)
			assert(dep.forall(x => x.ref.to == x))
			val tg = new TriggerIsIN(term, args, f, dep + term)
			if (tg.isNew) {
				for (x <- term.isins.toList; if !x.aux) {
					f(x.comp, args)(dep + term)
				}
			}
		}
	}
}
