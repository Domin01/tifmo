package tifmo

import stree.STree
import stree.TraceInfo
import stree.Align
import stree.PI
import stree.Term
import stree.WORD
import stree.IR
import stree.PO
import knowledge.EnWord
import knowledge.SemRole.SemRole

import resource.EnPolarity

package proc {
	
	object featureEnglish {
		
		def apply(tr: List[TraceInfo]) = {
			
			val racc = new Array[Double](5)
			val pacc = new Array[Double](5)
			
			//var relacc = null:String
			//var confiacc = Double.MaxValue
			var cacc = false
			for (t <- tr.tail; rdiff = t.rpartAfter - t.rpartBefore; pdiff = t.ppartAfter - t.ppartBefore) {
				
				val tah = t.aligns.head
				/*
				if (tah.confidence < confiacc || (tah.confidence == confiacc && tah.category < relacc)) {
					confiacc = tah.confidence
					relacc = tah.category
				}
				*/
				if (rdiff != 0 || pdiff != 0.0) {
					val confi = new Array[Double](5)
					//relacc match {
					//if (cacc) {
					//	confi(4) = -1.0
					//} else {
						tah.category match {
							case "e-SIM" => confi(0) = tah.confidence
							case "d-SUPER" => confi(1) = tah.confidence - 0.1
							case "c-RELATION" => confi(2) = tah.confidence - 0.1
							case "b-SUB" => confi(3) = tah.confidence - 0.1
							case "a-CONTRA" => {
								cacc = true
								confi(4) = -1.0
							}
							case _ => throw new Exception("weird category!")
						}
					//}
					for (i <- 0 until 5) {
						racc(i) += confi(i) * rdiff
						pacc(i) += confi(i) * pdiff
					}
				}
			}
			(racc, pacc)
		}
	}
}
