package tifmo

import java.util.Properties

import edu.stanford.nlp.pipeline.StanfordCoreNLP
import edu.stanford.nlp.pipeline.Annotation
import edu.stanford.nlp.ling.CoreAnnotations._
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation
import edu.stanford.nlp.dcoref.CorefCoreAnnotations.CorefClusterIdAnnotation
import edu.stanford.nlp.ling.IndexedWord
import edu.stanford.nlp.semgraph.SemanticGraph
import edu.stanford.nlp.semgraph.SemanticGraphEdge

import knowledge.SemRole
import knowledge.SemRole.SemRole
import knowledge.EnDoc
import knowledge.EnWord
import stree.PreNode
import stree.STree
import stree.Qtfier
import stree.SelNum
import stree.SelSup

import scala.collection.mutable
import scala.collection.JavaConversions._

package proc {
	
	object mkSTreeEnglish {
		
		private[this] val props = new Properties
		props.put("annotators", "tokenize, ssplit, pos, lemma, ner, parse, dcoref")
		private[this] val pipeline = new StanfordCoreNLP(props)
		
		def apply(text: String) = {
			
			val doc = new EnDoc(text)
			
			val document = new Annotation(text)
			pipeline.annotate(document)
			
			var spll = Nil:List[List[Set[(EnWord, String, String, EnWord)]]]
			doc.waa = (for (sentence <- document.get(classOf[SentencesAnnotation])) yield {
				
				val sidx = sentence.get(classOf[SentenceIndexAnnotation])
				
				val wa = (for (token <- sentence.get(classOf[TokensAnnotation])) yield {
					val idx = token.get(classOf[IndexAnnotation]) - 1
					val surf = token.get(classOf[TextAnnotation])
					val pos = token.get(classOf[PartOfSpeechAnnotation])
					val ner = token.get(classOf[NamedEntityTagAnnotation])
					val lem = if (ner == "DATE" || ner == "TIME") {
						token.get(classOf[NormalizedNamedEntityTagAnnotation])
					} else {
						token.get(classOf[LemmaAnnotation])
					}
					val cid = {
						val tmp = token.get(classOf[CorefClusterIdAnnotation])
						if (tmp == null) null else tmp.toString
					}
						
					new EnWord(doc, sidx, idx, surf, pos, ner, lem, cid, true)
				}).toArray
				
				val parse = sentence.get(classOf[CollapsedDependenciesAnnotation])
				
				spll = split(parse, wa) :: spll
				
				wa
			}).toArray
			
			val pnll = for (spl <- spll; (sp, i) <- spl.zipWithIndex; tmp = annotate(someof(whref(copulahead(sp)))); if !tmp.isEmpty) yield {
				for (x <- tmp; cid = x.word.asInstanceOf[EnWord].cid; if cid != null && x.word.sign) {
					x.coref = cid + "&" + i
				}
				if (i == 0) tmp.last.updateCoref = true
				tmp
			}
			
			doc.stree = new STree(pnll.reverse.flatten)
			
			doc.stree
		}
		
		private[this] def split(parse: SemanticGraph, wa: Array[EnWord]) = {
			
			def recurX(y: IndexedWord, pool: mutable.Set[SemanticGraphEdge]) {
				for (e <- parse.edgeIterable) {
					if (e.getGovernor == y) {
						if (pool.add(e)) recurX(e.getDependent, pool)
					}
				}
			}
			
			var checklst = {
				var root = null:IndexedWord
				try {
					root = parse.getFirstRoot
				} catch {
					case e: Exception => {}
				}
				if (root == null) {
					Nil
				} else {
					val tmp = mutable.Set.empty[SemanticGraphEdge]
					recurX(root, tmp)
					if (tmp.isEmpty) {
						Nil
					} else {
						List((tmp.toSet, root))
					}
				}
			}
			var retlst = Nil:List[Set[(EnWord, String, String, EnWord)]]
			
			while (!checklst.isEmpty) {
				val (tocheck, curroot) = checklst.head
				checklst = checklst.tail
				tocheck.find(x => x.getRelation.getShortName == "conj") match {
					case Some(x) => {
						def recur(y: IndexedWord, pool: mutable.Set[SemanticGraphEdge], eq: Boolean = false) {
							for (e <- tocheck) {
								if ((e.getGovernor eq y) || (!eq && e.getGovernor == y)) {
									if (pool.add(e)) recur(e.getDependent, pool)
								}
							}
						}
						def descendEdge(y: IndexedWord) = {
							val ret = mutable.Set.empty[SemanticGraphEdge]
							recur(y, ret)
							ret.toSet
						}
						def descendEdgeEq(y: IndexedWord) = {
							val ret = mutable.Set.empty[SemanticGraphEdge]
							recur(y, ret, x.getDependent == x.getGovernor)
							ret.toSet
						}
						val depsub = descendEdgeEq(x.getDependent)
						val govsub = descendEdge(x.getGovernor)
						val slim = tocheck -- govsub
						val govpar = parse.getParent(x.getGovernor)
						val s1 = if (govpar == null) {
							assert(slim.isEmpty)
							(depsub, x.getDependent)
						} else {
							val paredge = parse.getEdge(govpar, x.getGovernor)
							val tmp = ((slim ++ depsub) - paredge) + (new SemanticGraphEdge(paredge.getGovernor, x.getDependent, paredge.getRelation, paredge.getWeight, paredge.isExtra))
							(tmp, curroot)
						}
						val s2 = (slim ++ ((govsub -- depsub) - x), curroot)
						checklst = s1 :: s2 :: checklst
					}
					case None => {
						val tmp = for (x <- tocheck) yield {
							(wa(x.getGovernor.get(classOf[IndexAnnotation]) - 1), x.getRelation.getShortName, x.getRelation.getSpecific, wa(x.getDependent.get(classOf[IndexAnnotation]) - 1))
						}
						retlst = (tmp + ((null, "root", "root", wa(curroot.get(classOf[IndexAnnotation]) - 1)))) :: retlst
					}
				}
			}
			retlst
		}
		
		private[this] def copulahead(dep: Set[(EnWord, String, String, EnWord)]) = {
			
			var ret = dep
			
			for ((p, rel, spc, c) <- dep; if rel == "cop") {
				
				ret = ret - ((p, rel, spc, c)) + ((c, "dobj", spc, p))
				
				for ((pp, rrel, sspc, cc) <- dep; if cc == p) {
					ret = ret - ((pp, rrel, sspc, cc)) + ((pp, rrel, sspc, c))
				}
				for ((pp, rrel, sspc, cc) <- dep; if (rrel == "nsubj" || rrel == "csubj") && pp == p) {
					ret = ret - ((pp, rrel, sspc, cc)) + ((c, "dobj", (if (p.mypos == "J") "cop-J" else "cop"), cc))
				}
			}
			
			ret
		}
		
		private[this] def whref(dep: Set[(EnWord, String, String, EnWord)]) = {
			
			var ret = dep
			
			def findPreviousNN(x: EnWord) = {
				val sent = x.doc.waa(x.sidx)
				if (x.idx >= 1) {
					if (sent(x.idx - 1).pos == "IN") {
						if (x.idx >= 2) {
							if (sent(x.idx - 2).pos == ",") {
								if (x.idx >= 3) {
									if (sent(x.idx - 3).pos.matches("NN.*") || sent(x.idx - 3).pos == "PRB") {
										sent(x.idx - 3)
									} else {
										null
									}
								} else {
									null
								}
							} else {
								if (sent(x.idx - 2).pos.matches("NN.*") || sent(x.idx - 2).pos == "PRB") {
									sent(x.idx - 2)
								} else {
									null
								}
							}
						} else {
							null
						}
					} else {
						if (sent(x.idx - 1).pos == ",") {
							if (x.idx >= 2) {
								if (sent(x.idx - 2).pos.matches("NN.*") || sent(x.idx - 2).pos == "PRB") {
									sent(x.idx - 2)
								} else {
									null
								}
							} else {
								null
							}
						} else {
							if (sent(x.idx - 1).pos.matches("NN.*") || sent(x.idx - 1).pos == "PRB") {
								sent(x.idx - 1)
							} else {
								null
							}
						}
					}
				} else {
					null
				}
			}
			
			val sensi = Set("nsubj", "dobj", "prep", "nsubjpass")
			for ((p, rel, spc, c) <- dep) {
				if (c.pos.matches("W.+") && sensi.contains(rel)) {
					
					val ref = findPreviousNN(c)
					if (ref != null && dep.exists(_._4 == ref)) {
						
						ret = ret - ((p, rel, spc, c))
						ret = ret.filter(_._4 != p)
						
						ret = ret + ((ref, "R" + rel, spc, p))
						
					}
				}
			}
			
			ret
		}
		
		private[this] def someof(dep: Set[(EnWord, String, String, EnWord)]) = {
			
			var ret = dep
			
			for ((p, rel, spc, c) <- dep; if rel == "prep" && spc == "of") {
				if (p.lem == "some" || p.lem == "most") {
					ret = ret - ((p, rel, spc, c))
					for ((pp, rrel, sspc, cc) <- dep; if cc == p) {
						ret = ret - ((pp, rrel, sspc, cc)) + ((pp, rrel, sspc, c))
					}
				}
				if (p.lem == "all") {
					ret = ret - ((p, rel, spc, c)) + ((c, "det", spc, p))
					for ((pp, rrel, sspc, cc) <- dep; if cc == p) {
						ret = ret - ((pp, rrel, sspc, cc)) + ((pp, rrel, sspc, c))
					}
				}
				if (p.lem == "none") {
					ret = ret - ((p, rel, spc, c)) + ((c, "det", spc, p))
					for ((pp, rrel, sspc, cc) <- dep; if cc == p) {
						ret = ret - ((pp, rrel, sspc, cc)) + ((pp, rrel, sspc, c))
					}
				}
				if (p.lem.matches("-?[0-9\\.]+")) {
					ret = ret - ((p, rel, spc, c)) + ((c, "num", spc, p))
					for ((pp, rrel, sspc, cc) <- dep; if cc == p) {
						ret = ret - ((pp, rrel, sspc, cc)) + ((pp, rrel, sspc, c))
					}
				}
			}
			
			ret
		}
		
		private[this] def annotate(dep: Set[(EnWord, String, String, EnWord)]) = {
			
			val pnpool = mutable.Map.empty[EnWord, PreNode]
			def getNode(x: EnWord) = {
				if (pnpool.contains(x)) {
					pnpool(x)
				} else {
					val ret = new PreNode
					ret.word = x
					if (x.mypos != "D" && x.lem.matches("-?[0-9\\.]+")) {
						ret.sel = ret.sel + (new SelNum(Set(x.lem)))
					} else if (x.pos == "JJS") {
						ret.sel = ret.sel + (new SelSup(x.lemmas + x.lem))
					}
					pnpool(x) = ret
					ret
				}
			}
			
			var recroot = null:PreNode
			for ((p, rel, spc, c) <- dep) {
				if (rel == "root") {
					recroot = getNode(c)
				} else if (c.mypos == "D" && {
					val tmp = c.getContext(0, 2)
					tmp.length == 2 && tmp(1).mypos == "D" && c.lem == tmp(1).lem
				}) {
					// do nothing.
				} else {
					val (np, nc) = (getNode(p), getNode(c))
					val nci = c.idx
					rel match {
						case "Rnsubj" => {
							nc.outr = SemRole.SBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "Rprep" => {
							if (c.mypos == "N" && p.mypos == "N") {
								if (spc == "as") {
									nc.outr = SemRole.ARG
								} else {
									nc.outr = SemRole.POSS
								}
							} else {
								nc.outr = SemRole.IOBJ
							}
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "Rdobj" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "Rnsubjpass" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "abbrev" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "acomp" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "advcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "advmod" => {
							if (c.lem == "most" && p.pos == "JJ") {
								val nword = new EnWord(p.doc, p.sidx, p.idx, c.surf + " " + p.surf, "JJS", p.ner, p.lem, p.cid, p.sign)
								np.word = nword
							} else {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.THG, nc, nci)
							}
						}
						case "agent" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "amod" => {
							nc.outr = SemRole.ARG
							if (p.mypos == "N") {
								np.addChild(SemRole.POSS, nc, nci)
							} else {
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "appos" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "ccomp" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "csubj" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "csubjpass" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "dep" => {
							nc.outr = if (c.mypos == "V") SemRole.THG else SemRole.ARG
							if (p.mypos == "V") {
								np.addChild(SemRole.THG, nc, nci)
							} else {
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "det" => {
							if (p.lem == "all" || p.lem == "every" || p.lem == "each") {
								np.qtfier = Qtfier.ALL
							} else if (p.lem == "no" || p.lem == "none") {
								np.qtfier = Qtfier.NO
							}
						}
						case "dobj" => {
							if (spc == "cop-J") {
								nc.outr = SemRole.POSS
							} else if (spc == "cop") {
								nc.outr = SemRole.ARG
								if (c.ner == "O") nc.qtfier = Qtfier.ALL
							} else {
								nc.outr = SemRole.ARG
							}
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "infmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "iobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "neg" => {
							np.word = np.word.asInstanceOf[EnWord].reverse
						}
						case "nn" => {
							if (c.mypos == "D") {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.TIME, nc, nci)
							} else {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "npadvmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "nsubj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "nsubjpass" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "num" => {
							if (c.mypos == "D") {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.TIME, nc, nci)
							} else {
								//np.qtfier = Qtfier.EXACTLY
								np.sel = np.sel + (new SelNum(Set(c.lem)))
							}
						}
						case "number" => {
							if (c.lem.matches("-?[0-9\\.]+")) {
								np.sel = np.sel + (new SelNum(Set(c.lem)))
							} else {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "parataxis" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.THG, nc, nci)
						}
						case "partmod" => {
							nc.outr = if (c.pos == "VBN") SemRole.OBJ else SemRole.SBJ
							val tmp = if (p.mypos == "V") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "pobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "poss" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.POSS, nc, nci)
						}
						case "predet" => {
							if (p.lem == "all") {
								np.qtfier = Qtfier.ALL
							}
						}
						case "prep" => {
							nc.outr = SemRole.ARG
							if (c.mypos == "D") {
								// we should add more to recognize
								 // relations like before, after, since, from, to, ...
								np.addChild(SemRole.TIME, nc, nci)
							} else if (c.mypos == "N" && p.mypos == "N") {
								if (spc == "as") {
									np.addChild(SemRole.ARG, nc, nci)
								} else {
									np.addChild(SemRole.POSS, nc, nci)
								}
							} else {
								np.addChild(SemRole.IOBJ, nc, nci)
							}
						}
						case "prepc" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "prt" => {
							val nword = new EnWord(p.doc, p.sidx, p.idx, p.surf + " " + c.surf, p.pos, p.ner, p.lem + " " + c.lem, p.cid, p.sign)
							np.word = nword
						}
						case "purpcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.AIM, nc, nci)
						}
						case "rcmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "rel" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "tmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.TIME, nc, nci)
						}
						case "xcomp" => {
							nc.outr = SemRole.SBJ
							val tmp = if (p.mypos == "V") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "xsubj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case _ => {}
					}
				}
			}
			
			var lnodes = Nil:List[PreNode]
			def recur(x: PreNode) {
				lnodes = x :: lnodes
				// eliminate multiple quantifiers at one role. this is ad hoc!!!
				val rcpool = mutable.Map.empty[SemRole, Set[PreNode]]
				for ((r, c) <- x.sortedChildren; if c.qtfier != null) {
					if (rcpool.contains(r)) {
						rcpool(r) = rcpool(r) + c
					} else {
						rcpool(r) = Set(c)
					}
				}
				for ((r, cs) <- rcpool; if cs.size >= 2) {
					cs.foreach(_.qtfier = null)
				}
				//////////////////////////////////////////
				// delete "contradiction"s
				val conpool = mutable.Set.empty[PreNode]
				val iobjs = x.sortedChildren.filter(y => y._1 == SemRole.IOBJ && y._2.qtfier == null && y._2.outr == SemRole.ARG).toSet
				for (ss <- iobjs.subsets(2)) {
					val a = ss.head
					val b = (ss - a).head
					if (a._2.word.asInstanceOf[EnWord].antonymTo(b._2.word.asInstanceOf[EnWord])) {
						conpool.add(a._2)
						conpool.add(b._2)
					}
				}
				conpool.foreach(x.deleteChild(SemRole.IOBJ, _))
				///////////////////////////////////////////
				for ((r, c) <- x.sortedChildren) {
					recur(c)
				}
			}
			if (recroot != null) {
				if (!recroot.word.sign && !recroot.sortedChildren.isEmpty) {
					val lastr = recroot.sortedChildren.last._1
					if (!recroot.sortedChildren.exists(x => x._1 == lastr && x._2.qtfier != null)) {
						recroot.word = recroot.word.asInstanceOf[EnWord].reverse
						recroot.rootNeg = true
					}
				}
				recur(recroot)
			}
			lnodes
		}
	}
}
