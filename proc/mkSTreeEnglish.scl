package tifmo

import java.util.Properties

import edu.stanford.nlp.pipeline.StanfordCoreNLP
import edu.stanford.nlp.pipeline.Annotation
import edu.stanford.nlp.ling.CoreAnnotations._
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation
import edu.stanford.nlp.dcoref.CorefCoreAnnotations.CorefClusterIdAnnotation
import edu.stanford.nlp.ling.IndexedWord
import edu.stanford.nlp.semgraph.SemanticGraph
import edu.stanford.nlp.semgraph.SemanticGraphEdge

import knowledge.SemRole
import knowledge.SemRole.SemRole
import knowledge.EnDoc
import knowledge.EnWord
import stree.PreNode
import stree.STree
import stree.Qtfier
import stree.SelNum

import scala.collection.mutable
import scala.collection.JavaConversions._

package proc {
	
	object mkSTreeEnglish {
		
		private[this] val props = new Properties
		props.put("annotators", "tokenize, ssplit, pos, lemma, ner, parse, dcoref")
		private[this] val pipeline = new StanfordCoreNLP(props)
		
		def apply(text: String) = {
			
			val doc = new EnDoc(text)
			
			val document = new Annotation(text)
			pipeline.annotate(document)
			
			var spll = Nil:List[List[Set[(EnWord, String, String, EnWord)]]]
			doc.waa = (for (sentence <- document.get(classOf[SentencesAnnotation])) yield {
				
				val sidx = sentence.get(classOf[SentenceIndexAnnotation])
				
				val wa = (for (token <- sentence.get(classOf[TokensAnnotation])) yield {
					
					val idx = token.get(classOf[IndexAnnotation]) - 1
					val surf = token.get(classOf[TextAnnotation])
					val pos = token.get(classOf[PartOfSpeechAnnotation])
					val ner = token.get(classOf[NamedEntityTagAnnotation])
					val lem = if (ner == "DATE" || ner == "TIME") {
						token.get(classOf[NormalizedNamedEntityTagAnnotation])
					} else {
						token.get(classOf[LemmaAnnotation])
					}
					val cid = {
						val tmp = token.get(classOf[CorefClusterIdAnnotation])
						if (tmp == null) null else tmp.toString
					}
						
					new EnWord(doc, sidx, idx, surf, pos, ner, lem, cid, true)
				}).toArray
				
				val parse = sentence.get(classOf[CollapsedDependenciesAnnotation])
				
				spll = split(parse, wa) :: spll
				
				wa
			}).toArray
			
			val pnll = for (spl <- spll; (sp, i) <- spl.zipWithIndex) yield {
				val tmp = annotate(sp)
				for (x <- tmp; cid = x.word.asInstanceOf[EnWord].cid; if cid != null && x.word.sign) {
					x.coref = cid + "&" + i
				}
				tmp
			}
			
			doc.stree = new STree(pnll.reverse.flatten)
			
			doc.stree
		}
		
		private[this] def split(parse: SemanticGraph, wa: Array[EnWord]) = {
			
			var checklst = {
				val edges = parse.edgeIterable.toSet
				var root = null:IndexedWord
				try {
					root = parse.getFirstRoot
				} catch {
					case e: Exception => {}
				}
				if (root == null || edges.isEmpty) {
					Nil
				} else {
					List((edges, root))
				}
			}
			var retlst = Nil:List[Set[(EnWord, String, String, EnWord)]]
			
			while (!checklst.isEmpty) {
				val (tocheck, curroot) = checklst.head
				checklst = checklst.tail
				tocheck.find(x => x.getRelation.getShortName == "conj") match {
					case Some(x) => {
						def recur(y: IndexedWord, pool: mutable.Set[SemanticGraphEdge], eq: Boolean = false) {
							for (e <- tocheck) {
								if ((e.getGovernor eq y) || (!eq && e.getGovernor == y)) {
									if (pool.add(e)) recur(e.getDependent, pool)
								}
							}
						}
						def descendEdgeEq(y: IndexedWord) = {
							val ret = mutable.Set.empty[SemanticGraphEdge]
							recur(y, ret, x.getDependent == x.getGovernor)
							ret.toSet
						}
						def descendEdge(y: IndexedWord) = {
							val ret = mutable.Set.empty[SemanticGraphEdge]
							recur(y, ret)
							ret.toSet
						}
						val depsub = descendEdgeEq(x.getDependent)
						val govsub = descendEdge(x.getGovernor)
						val slim = tocheck -- govsub
						val govpar = parse.getParent(x.getGovernor)
						val s1 = if (govpar == null) {
							assert(slim.isEmpty)
							(depsub, x.getDependent)
						} else {
							val paredge = parse.getEdge(govpar, x.getGovernor)
							val tmp = ((slim ++ depsub) - paredge) + (new SemanticGraphEdge(paredge.getGovernor, x.getDependent, paredge.getRelation, paredge.getWeight, paredge.isExtra))
							(tmp, curroot)
						}
						val s2 = (slim ++ ((govsub -- depsub) - x), curroot)
						checklst = s1 :: s2 :: checklst
					}
					case None => {
						val tmp = for (x <- tocheck) yield {
							(wa(x.getGovernor.get(classOf[IndexAnnotation]) - 1), x.getRelation.getShortName, x.getRelation.getSpecific, wa(x.getDependent.get(classOf[IndexAnnotation]) - 1))
						}
						retlst = (tmp + ((null, "root", "root", wa(curroot.get(classOf[IndexAnnotation]) - 1)))) :: retlst
					}
				}
			}
			retlst
		}
		
		private[this] def annotate(dep: Set[(EnWord, String, String, EnWord)]) = {

			val pnpool = mutable.Map.empty[EnWord, PreNode]
			def getNode(x: EnWord) = {
				if (pnpool.contains(x)) {
					pnpool(x)
				} else {
					val ret = new PreNode
					ret.word = x
					if (x.ner == "NUMBER") ret.slction = new SelNum(x.lem)
					pnpool(x) = ret
					ret
				}
			}
			
			var recroot = null:PreNode
			for ((p, rel, spc, c) <- dep) {
				if (rel == "root") {
					recroot = getNode(c)
				} else if (c.mypos == "D" && {
					val tmp = c.getContext(0, 2)
					tmp.length == 2 && tmp(1).mypos == "D" && c.lem == tmp(1).lem
				}) {
					// do nothing.
				} else {
					val (np, nc) = (getNode(p), getNode(c))
					val nci = c.idx
					rel match {
						case "abbrev" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "acomp" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "advcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "advmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "agent" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "amod" => {
							nc.outr = SemRole.ARG
							if (p.mypos == "N") {
								np.addChild(SemRole.POSS, nc, nci)
							} else {
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "appos" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "ccomp" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "csubj" => {
							nc.outr = SemRole.THG
							val tmp = if (p.mypos == "V") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "csubjpass" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "dep" => {
							nc.outr = if (c.mypos == "V") SemRole.THG else SemRole.ARG
							if (p.mypos == "V") {
								np.addChild(SemRole.THG, nc, nci)
							} else {
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "det" => {
							if (p.lem == "all" || p.lem == "every" || p.lem == "each") {
								np.qtfier = Qtfier.ALL
							} else if (p.lem == "no") {
								np.qtfier = Qtfier.NO
							}
						}
						case "dobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "infmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "iobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "neg" => {
							np.word = np.word.asInstanceOf[EnWord].reverse
						}
						case "nn" => {
							if (c.mypos == "D") {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.TIME, nc, nci)
							} else {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "npadvmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "nsubj" => {
							nc.outr = SemRole.ARG
							val tmp = if (p.mypos == "V") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "nsubjpass" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "num" => {
							if (c.mypos == "D") {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.TIME, nc, nci)
							} else {
								np.qtfier = Qtfier.EXACTLY
								np.slction = new SelNum(c.lem)
							}
						}
						case "number" => {
							if (p.mypos == "N") {
								np.qtfier = Qtfier.EXACTLY
								np.slction = new SelNum(c.lem)
							} else {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.ARG, nc, nci)
							}
						}
						case "parataxis" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.THG, nc, nci)
						}
						case "partmod" => {
							nc.outr = if (c.surf.length >= 3 && c.surf.substring(c.surf.length - 3, c.surf.length) == "ing") SemRole.SBJ else SemRole.OBJ
							val tmp = if (p.mypos == "V") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "pobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "poss" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.POSS, nc, nci)
						}
						case "predet" => {
							if (p.lem == "all") {
								np.qtfier = Qtfier.ALL
							}
						}
						case "prep" => {
							nc.outr = SemRole.ARG
							if (c.mypos == "D") {
								// we should add more to recognize
								 // relations like before, after, since, from, to, ...
								np.addChild(SemRole.TIME, nc, nci)
							} else if (c.mypos == "N" && p.mypos == "N" && spc == "as") {
								np.addChild(SemRole.ARG, nc, nci)
							} else {
								np.addChild(SemRole.IOBJ, nc, nci)
							}
						}
						case "prepc" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "prt" => {
							val nword = new EnWord(p.doc, p.sidx, p.idx, p.surf + " " + c.surf, p.pos, p.ner, p.lem + " " + c.lem, p.cid, p.sign)
							np.word = nword
						}
						case "purpcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.AIM, nc, nci)
						}
						case "rcmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "rel" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "tmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.TIME, nc, nci)
						}
						case "xcomp" => {
							nc.outr = SemRole.SBJ
							val tmp = if (p.mypos == "V") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "xsubj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case _ => {}
					}
				}
			}
			
			var lnodes = Nil:List[PreNode]
			def recur(x: PreNode) {
				lnodes = x :: lnodes
				// eliminate multiple quantifiers at one role. this is ad hoc!!!
				val rcpool = mutable.Map.empty[SemRole, Set[PreNode]]
				for ((r, c) <- x.sortedChildren; if c.qtfier != null) {
					if (rcpool.contains(r)) {
						rcpool(r) = rcpool(r) + c
					} else {
						rcpool(r) = Set(c)
					}
				}
				for ((r, cs) <- rcpool; if cs.size >= 2) {
					cs.foreach(_.qtfier = null)
				}
				//////////////////////////////////////////
				for ((r, c) <- x.sortedChildren) {
					recur(c)
				}
			}
			if (recroot != null) recur(recroot)
			lnodes
		}
	}
}
