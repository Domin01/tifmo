package tifmo

import java.util.Properties

import edu.stanford.nlp.pipeline.StanfordCoreNLP
import edu.stanford.nlp.pipeline.Annotation
import edu.stanford.nlp.ling.CoreAnnotations._
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation
import edu.stanford.nlp.dcoref.CorefCoreAnnotations.CorefClusterIdAnnotation
import edu.stanford.nlp.semgraph.SemanticGraph
import edu.stanford.nlp.semgraph.SemanticGraphEdge

import knowledge.SemRole
import knowledge.SemRole.SemRole
import knowledge.EnWord
import stree.PreNode
import stree.STree
import stree.Qtfier
//import stree.Qtfier.Qtfier
import stree.SelNum

import scala.collection.mutable
import scala.collection.JavaConversions._

package proc {
	
	object mkSTreeEnglish {
		
		private[this] val props = new Properties
		props.put("annotators", "tokenize, ssplit, pos, lemma, ner, regexner, parse, dcoref")
		private[this] val pipeline = new StanfordCoreNLP(props)
		
		def apply(text: String) = {
			
			val document = new Annotation(text)
			pipeline.annotate(document)
			
			var pnrll = Nil:List[List[PreNode]]
			val waa = (for (sentence <- document.get(classOf[SentencesAnnotation])) yield {
				
				val sidx = sentence.get(classOf[SentenceIndexAnnotation])
				
				val wa = (for (token <- sentence.get(classOf[TokensAnnotation])) yield {
					
					val idx = token.get(classOf[IndexAnnotation]) - 1
					val surf = token.get(classOf[TextAnnotation])
					val pos = token.get(classOf[PartOfSpeechAnnotation])
					val ner = token.get(classOf[NamedEntityTagAnnotation])
					val lex = token.get(classOf[LemmaAnnotation])
					val nm = token.get(classOf[NormalizedNamedEntityTagAnnotation])
					val cid = {
						val tmp = token.get(classOf[CorefClusterIdAnnotation])
						if (tmp == null) null else tmp.toString
					}
						
					new EnWord(sidx, idx, surf, pos, ner, lex, nm, cid, true)
				}).toArray
				
				val parse = sentence.get(classOf[CollapsedDependenciesAnnotation])
				pnrll = split(parse, wa).map(annotate(_)) ::: pnrll
				
				wa
			}).toArray
			
			(new STree(pnrll.reverse.flatten), waa)
		}
		
		private[this] def split(parse: SemanticGraph, wa: Array[EnWord]) = {
			
			var checklst = List(parse.edgeIterable.toSet)
			var retlst = Nil:List[Set[(EnWord, String, EnWord)]]
			
			while (!checklst.isEmpty) {
				val tocheck = checklst.head
				checklst = checklst.tail
				tocheck.find(x => x.getRelation.getShortName == "conj") match {
					case Some(x) => {
						
						val depdes = parse.descendants(x.getDependent)
						val depsub = tocheck.filter(y => depdes.contains(y.getGovernor))
						
						val govdes = parse.descendants(x.getGovernor)
						val govsub = tocheck.filter(y => govdes.contains(y.getGovernor))
						
						val slim = tocheck -- govsub
						
						val paredge = parse.getEdge(parse.getParent(x.getGovernor), x.getGovernor)
						
						val s1 = ((slim ++ depsub) - paredge) + (new SemanticGraphEdge(paredge.getGovernor, x.getDependent, paredge.getRelation, paredge.getWeight, paredge.isExtra))
						val s2 = slim ++ ((govsub -- depsub) - x)
						checklst = s1 :: s2 :: checklst
					}
					case None => {
						val tmp = for (x <- tocheck) yield {
							(wa(x.getGovernor.get(classOf[IndexAnnotation]) - 1), x.getRelation.getShortName, wa(x.getDependent.get(classOf[IndexAnnotation]) - 1))
						}
						retlst = (tmp + ((null, "root", wa(parse.getFirstRoot.get(classOf[IndexAnnotation]) - 1)))) :: retlst
					}
				}
			}
			retlst
		}
		
		private[this] def annotate(dep: Set[(EnWord, String, EnWord)]) = {

			val pnpool = mutable.Map.empty[EnWord, PreNode]
			def getNode(x: EnWord) = {
				if (pnpool.contains(x)) {
					pnpool(x)
				} else {
					val ret = new PreNode
					ret.word = x
					ret.coref = x.cid
					pnpool(x) = ret
					ret
				}
			}
			
			var recroot = null:PreNode
			for ((p, rel, c) <- dep) {
				if (rel == "root") {
					recroot = getNode(c)
				} else {
					val (np, nc) = (getNode(p), getNode(c))
					val nci = c.idx
					rel match {
						case "abbrev" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "acomp" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "advcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "advmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "agent" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "amod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.POSS, nc, nci)
						}
						case "appos" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "ccomp" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "csubj" => {
							nc.outr = SemRole.THG
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "csubjpass" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "dep" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "det" => {
							if (p.lex == "all" || p.lex == "every" || p.lex == "each") {
								np.qtfier = Qtfier.ALL
							} else if (p.lex == "no") {
								np.qtfier = Qtfier.NO
							}
						}
						case "dobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "infmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "iobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "neg" => {
							np.word = np.word.neg
						}
						case "nn" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "npadvmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "nsubj" => {
							nc.outr = SemRole.ARG
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "nsubjpass" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "num" => {
							if (c.ner == "DATE") {
								nc.outr = SemRole.ARG
								np.addChild(SemRole.TIME, nc, nci)
							} else {
								np.qtfier = Qtfier.EXACTLY
								np.slction = new SelNum(c.lex)
							}
						}
						case "parataxis" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.THG, nc, nci)
						}
						case "partmod" => {
							nc.outr = if (c.surf.length >= 3 && c.surf.substring(c.surf.length - 3, c.surf.length) == "ing") SemRole.SBJ else SemRole.OBJ
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "pobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "poss" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.POSS, nc, nci)
						}
						case "predet" => {
							if (p.lex == "all") {
								np.qtfier = Qtfier.ALL
							}
						}
						case "prep" => {
							nc.outr = SemRole.ARG
							if (c.ner == "DATE") {
								np.addChild(SemRole.TIME, nc, nci)
							} else {
								np.addChild(SemRole.IOBJ, nc, nci)
							}
						}
						case "prepc" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "prt" => {
							val nword = new EnWord(p.sidx, p.idx, p.surf + " " + c.surf, p.pos, p.ner, p.lex + " " + c.lex, p.nm, p.cid, p.sign)
							np.word = nword
						}
						case "purpcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.AIM, nc, nci)
						}
						case "rcmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "rel" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "tmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.TIME, nc, nci)
						}
						case "xcomp" => {
							nc.outr = SemRole.SBJ
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "xsubj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case _ => {}
					}
				}
			}
			
			var lnodes = Nil:List[PreNode]
			def recur(x: PreNode) {
				lnodes = x :: lnodes
				// eliminate multiple quantifiers at one role. this is ad hoc!!!
				val rcpool = mutable.Map.empty[SemRole, Set[PreNode]]
				for ((r, c) <- x.sortedChildren; if c.qtfier != null) {
					if (rcpool.contains(r)) {
						rcpool(r) = rcpool(r) + c
					} else {
						rcpool(r) = Set(c)
					}
				}
				for ((r, cs) <- rcpool; if cs.size >= 2) {
					cs.foreach(_.qtfier = null)
				}
				//////////////////////////////////////////
				for ((r, c) <- x.sortedChildren) {
					recur(c)
				}
			}
			if (recroot != null) recur(recroot)
			lnodes
		}
	}
}
