package tifmo

import edu.stanford.nlp.process.DocumentPreprocessor
import edu.stanford.nlp.process.Morphology
import edu.stanford.nlp.ling.HasWord
import edu.stanford.nlp.ling.TaggedWord
import edu.stanford.nlp.ling.CoreAnnotations.AnswerAnnotation
import edu.stanford.nlp.ie.crf.CRFClassifier
import edu.stanford.nlp.tagger.maxent.MaxentTagger
import edu.stanford.nlp.parser.lexparser.LexicalizedParser
import edu.stanford.nlp.trees.PennTreebankLanguagePack
import edu.stanford.nlp.trees.TreeGraphNode

import knowledge.SemRole
import knowledge.SemRole.SemRole
import knowledge.EnWord
import stree.PreNode
import stree.STree
import stree.Qtfier
import stree.Qtfier.Qtfier
import stree.SelNum

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer
import scala.collection.JavaConversions._

package proc {

	object mkSTreeEnglish {
		
		private[this] val ner = CRFClassifier.getClassifierNoExceptions("edu/stanford/nlp/classifiers/english.all.3class.distsim.crf.ser.gz")
		private[this] val tagger = new MaxentTagger("edu/stanford/nlp/models/postagger/english-bidirectional-distsim.tagger")
		private[this] val lp = LexicalizedParser.loadModel("edu/stanford/nlp/models/lexparser/englishPCFG.ser.gz")
		private[this] val tlp = new PennTreebankLanguagePack
		private[this] val gsf = tlp.grammaticalStructureFactory
		private[this] val ANSWER = (new AnswerAnnotation).getClass.asInstanceOf[java.lang.Class[Nothing]]
		
		def sentSeg(raw: String): Array[java.util.List[HasWord]] = {
			val norm = biun.normalize(raw)
			val sr = new java.io.StringReader(norm)
			val dp = new DocumentPreprocessor(sr)
			dp.iterator.toArray
		}
		
		def chunking(sent: java.util.List[HasWord]): ArrayBuffer[EnWord] = {
			val labels = ner.classifySentence(sent)
			val ret = ArrayBuffer.empty[EnWord]
			var acat = null:String
			var aword = null:String
			for (cl <- labels) {
				val cat = cl.get(ANSWER).toString
				if (cat == "O" || cat != acat) {
					if (aword != null) {
						ret += new EnWord(aword, acat, true)
					}
					acat = cat
					aword = cl.word
				} else {
					aword = aword + " " + cl.word
				}
			}
			if (aword != null) {
				ret += new EnWord(aword, acat, true)
			}
			ret
		}
		
		def tagging(lew: ArrayBuffer[EnWord]): java.util.List[TaggedWord] = {
			val sent = for (ew <- lew) yield {
				assert(ew.sign)
				new edu.stanford.nlp.ling.Word(ew.surf)
			}
			val ret = tagger.tagSentence(sent)
			for (i <- 0 until lew.length) {
				lew(i).pos = ret.get(i).tag
				lew(i).lex = Morphology.lemmaStatic(lew(i).surf, lew(i).pos, lew(i).ner == "O")
			}
			ret
		}
		
		//def coref() {}
		
		def dep(sent: java.util.List[TaggedWord]): Set[(TreeGraphNode, String, TreeGraphNode)] = {
			val parse = lp.apply(sent)
			val gs = gsf.newGrammaticalStructure(parse)
			val dct = gs.typedDependenciesCollapsedTree.toSet
			for (td <- dct) yield {
				(td.gov, td.reln.toString, td.dep)
			}
		}
		
		
		
		
		
		private[this] def trimUnder(s: String) = {
			val i = s.indexOf("_")
			if (i == -1) s else s.substring(0, i)
		}
		/*
		private[this] def getSubDeps(dep: Iterable[(EnWord, String, EnWord)], n: EnWord) = {
			val subnodes = mutable.Set(n)
			val ret = mutable.Set.empty[(EnWord, String, EnWord)]
			var hadnew = true
			while(hadnew) {
				hadnew = false
				for ((p, rel, c) <- dep) {
					if (p != null && subnodes.contains(p) && subnodes.add(c)) {
						ret.add((p, rel, c))
						hadnew = true
					}
				}
			}
			ret.toSet
		}
		*/
		private[this] def getSubDeps(dep: Iterable[(TreeGraphNode, String, TreeGraphNode)], n: TreeGraphNode) = {
			val subnodes = mutable.Set(n)
			val ret = mutable.Set.empty[(TreeGraphNode, String, TreeGraphNode)]
			var hadnew = true
			while(hadnew) {
				hadnew = false
				for ((p, rel, c) <- dep) {
					if (subnodes.contains(p) && subnodes.add(c)) {
						ret.add((p, rel, c))
						hadnew = true
					}
				}
			}
			ret.toSet
		}
		def split(dep: Set[(TreeGraphNode, String, TreeGraphNode)], lew: ArrayBuffer[EnWord]): List[Set[(EnWord, String, EnWord)]] = {
			var checklst = List(dep)
			var retlst = Nil:List[Set[(EnWord, String, EnWord)]]
			while (!checklst.isEmpty) {
				val tocheck = checklst.head
				checklst = checklst.tail
				tocheck.find(x => trimUnder(x._2) == "conj") match {
					case Some(x) => {
						val depsub = getSubDeps(tocheck, x._3)
						val govsub = getSubDeps(tocheck, x._1)
						val slim = tocheck -- govsub
						val paredge = tocheck.find(_._3 == x._1) match {
							case Some(y) => y
							case None => throw new Exception("no parent of conj!!!")
						}
						val s1 = ((slim ++ depsub) - paredge) + ((paredge._1, paredge._2, x._3))
						val s2 = slim ++ ((govsub -- depsub) - x)
						checklst = s1 :: s2 :: checklst
					}
					case None => {
						val tmp = for ((p, rel, c) <- tocheck) yield {
							if (rel == "root") {
								(null, rel, lew(c.index - 1))
							} else {
								(lew(p.index - 1), rel, lew(c.index - 1))
							}
						}
						retlst = tmp :: retlst
					}
				}
			}
			retlst
		}
		/*
		def split(dep: Set[(EnWord, String, EnWord)]): List[Set[(EnWord, String, EnWord)]] = {
			var checklst = List(dep)
			var retlst = Nil:List[Set[(EnWord, String, EnWord)]]
			while (!checklst.isEmpty) {
				val tocheck = checklst.head
				checklst = checklst.tail
				tocheck.find(x => trimUnder(x._2) == "conj") match {
					case Some(x) => {
						val depsub = getSubDeps(tocheck, x._3)
						val govsub = getSubDeps(tocheck, x._1)
						val slim = tocheck -- govsub
						val paredge = tocheck.find(_._3 == x._1) match {
							case Some(y) => y
							case None => throw new Exception("no parent of conj!!!")
						}
						val s1 = ((slim ++ depsub) - paredge) + ((paredge._1, paredge._2, x._3))
						val s2 = slim ++ ((govsub -- depsub) - x)
						checklst = s1 :: s2 :: checklst
					}
					case None => {
						retlst = tocheck :: retlst
					}
				}
			}
			retlst
		}
		*/
		def annotate(dep: Set[(EnWord, String, EnWord)]): List[PreNode] = {
			
			val pnpool = mutable.Map.empty[EnWord, PreNode]
			def getNode(x: EnWord) = {
				if (pnpool.contains(x)) {
					pnpool(x)
				} else {
					val ret = new PreNode
					ret.word = x
					pnpool(x) = ret
					ret
				}
			}
			
			var recroot = null:PreNode
			for ((p, rel, c) <- dep) {
				if (rel == "root") {
					recroot = getNode(c)
				} else {
					val (np, nc) = (getNode(p), getNode(c))
					val nci = c.wi
					trimUnder(rel) match {
						case "abbrev" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "acomp" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "advcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "advmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "agent" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case "amod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.POSS, nc, nci)
						}
						case "appos" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "ccomp" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "csubj" => {
							nc.outr = SemRole.THG
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "csubjpass" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "dep" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "det" => {
							if (p.lex == "all" || p.lex == "every" || p.lex == "each") {
								np.qtfier = Qtfier.ALL
							} else if (p.lex == "no") {
								np.qtfier = Qtfier.NO
							}
						}
						case "dobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "infmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "iobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "neg" => {
							np.word = np.word.neg
						}
						case "nn" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "npadvmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.THG, nc, nci)
						}
						case "nsubj" => {
							nc.outr = SemRole.ARG
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "nsubjpass" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "num" => {
							np.qtfier = Qtfier.EXACTLY
							np.slction = new SelNum(c.lex)
						}
						case "parataxis" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.THG, nc, nci)
						}
						case "partmod" => {
							nc.outr = if (c.surf.length >= 3 && c.surf.substring(c.surf.length - 3, c.surf.length) == "ing") SemRole.SBJ else SemRole.OBJ
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "pobj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "poss" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.POSS, nc, nci)
						}
						case "predet" => {
							if (p.lex == "all") {
								np.qtfier = Qtfier.ALL
							}
						}
						case "prep" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "prepc" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.IOBJ, nc, nci)
						}
						case "prt" => {
							val nword = new EnWord(p.surf + " " + c.surf, "O", p.sign)
							nword.pos = p.pos
							nword.si = p.si
							nword.wi = p.wi
							nword.lex = p.lex + " " + c.lex
							np.word = nword
						}
						case "purpcl" => {
							nc.outr = SemRole.THG
							np.addChild(SemRole.AIM, nc, nci)
						}
						case "rcmod" => {
							nc.outr = SemRole.OBJ
							np.addChild(SemRole.ARG, nc, nci)
						}
						case "rel" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.OBJ, nc, nci)
						}
						case "tmod" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.TIME, nc, nci)
						}
						case "xcomp" => {
							nc.outr = SemRole.SBJ
							val tmp = if (p.pos.substring(0, 2) == "VB") SemRole.SBJ else SemRole.ARG
							np.addChild(tmp, nc, nci)
						}
						case "xsubj" => {
							nc.outr = SemRole.ARG
							np.addChild(SemRole.SBJ, nc, nci)
						}
						case _ => {}
					}
				}
			}
			
			var lnodes = Nil:List[PreNode]
			def recur(x: PreNode) {
				lnodes = x :: lnodes
				// eliminate multiple quantifiers at one role. this is ad hoc!!!
				val rcpool = mutable.Map.empty[SemRole, Set[PreNode]]
				for ((r, c) <- x.sortedChildren; if c.qtfier != null) {
					if (rcpool.contains(r)) {
						rcpool(r) = rcpool(r) + c
					} else {
						rcpool(r) = Set(c)
					}
				}
				for ((r, cs) <- rcpool; if cs.size >= 2) {
					cs.foreach(_.qtfier = null)
				}
				//////////////////////////////////////////
				for ((r, c) <- x.sortedChildren) {
					recur(c)
				}
			}
			if (recroot != null) recur(recroot)
			lnodes
		}
		
		def wordsArray(raw: String): Array[ArrayBuffer[EnWord]] = {
			val sents = sentSeg(raw)
			val ewaa = for (si <- 0 until sents.length) yield {
				val wa = chunking(sents(si))
				for (wi <- 0 until wa.length) {
					wa(wi).si = si
					wa(wi).wi = wi
				}
				wa
			}
			ewaa.toArray
		}
		
		def apply(ewaa: Array[ArrayBuffer[EnWord]]): STree = {
			//coref
			val pnl = (for (lew <- ewaa.toList) yield {
				val spl = split(dep(tagging(lew)), lew)
				(for (sp <- spl) yield {
					annotate(sp)
				}).flatten
			}).flatten
			new STree(pnl)
		}
		
		def apply(raw: String): STree = {
			val ewaa = wordsArray(raw)
			apply(ewaa)
		}
	}
}
