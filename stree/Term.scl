package tifmo

import knowledge.SemRole.SemRole
import knowledge.WordInfo
import inference.IETerm
import inference.IETermRef
import inference.IEBasic
import inference.Slction
import scala.collection.mutable

package stree {
	
	class Path(val acc: PI, val src: List[PI]) extends Serializable {
		
		@transient private[this] var lger = null:List[Path]
		private[stree] def longer_=(x: List[Path]) {
			assert(lger == null)
			lger = x
		}
		def longer = lger
		
		//def roughMatchOne(pi: PI) = src.exists(_.roughMatch(pi))
		def collidWord = src.init.exists(x => x.term.word == src.last.term.word) //&& x.intoR == src.last.intoR)
		
		override def toString = src.map(_.term.word).mkString("", " | ", "")
	}
	
	sealed abstract class Item extends Serializable {
		def term: Term
		def intoR: SemRole
		
		@transient protected[this] var itmr = null:IETermRef
		def ietmref = itmr
		
		def setup(ie: IEBasic, ne: Boolean): Unit
		def clear(): Unit
	}
	
	case class SL(item: Item, sel: Set[Slction]) extends Item {
		assert(item != null)
		assert(!sel.isEmpty)
		
		def term = item.term
		def intoR = item.intoR
		
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				item.setup(ie, ne)
				itmr = ie.getSL(item.ietmref.to.roles, sel.map((null:IETerm, item.ietmref.to, _))).ref
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
		def clear() {
			itmr = null
			item.clear()
		}
	}
	
	case class PI(term: Term, intoR: SemRole) extends Item {
		assert(term != null)
		assert(intoR != null)
		
		def veryRoughMatch(that: PI) = {
			(ietmref.to.superSets intersect that.ietmref.to.superSets).exists(!_.isW)
		}
		
		@transient private[this] var pcst = null:IETermRef
		def roughMatch(that: PI) = pcst.to.hasSub(that.ietmref.to)
		
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				val cst = ie.getConstant(term.word)
				pcst = if (cst.roles == null) cst.ref else ie.getPI(cst, Set(intoR)).ref
				term.setup(ie, ne)
				itmr = if (term.ietmref.to.roles == null) {
					term.ietmref
				} else {
					ie.getPI(term.ietmref.to, Set(intoR)).ref
				}
				if (ie.getCount - ie.getLastCount > 50) {
					ie.explore()
				}
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
		def clear() {
			itmr = null
		}
		
		@transient lazy val paths: List[Path] = {
			
			def construct(x: Term): (Term, List[List[(Term, Path)]]) = x match {
				case WORD(word) => (x, Nil)
				case IR(core, sats) => {
					val (a, l) = construct(core)
					val retl = (for ((r, itm) <- sats.toList; if itm.isInstanceOf[PI]) yield {
						val pi = itm.asInstanceOf[PI]
						for (p <- pi.paths; if p.src.length <= 5) yield {
							(IR(a, Set((r, p.acc))), p)
						}
					}) ::: l.map(_.map(y => (IR(y._1, Set.empty[(SemRole, Item)]), y._2)))
					(IR(a, Set.empty[(SemRole, Item)]), retl)
				}
				case PO(tm, r) => {
					val (a, l) = construct(tm)
					(PO(a, r), l.map(_.map(y => (PO(y._1, r), y._2))))
				}
				case DI(tm, arg, r) => {
					val (a, l) = construct(tm)
					(PO(a, r), l.map(_.map(y => (PO(y._1, r), y._2))))
				}
				case DU(tm, arg, r) => {
					val (a, l) = construct(tm)
					(PO(a, r), l.map(_.map(y => (PO(y._1, r), y._2))))
				}
				case DE(tm, arg, r) => {
					val (a, l) = construct(tm)
					(PO(a, r), l.map(_.map(y => (PO(y._1, r), y._2))))
				}
			}
			
			val (a, l) = construct(term)
			val start = new Path(PI(a, intoR), List(this))
			val pll = l.map(_.map(y => {
				(new Path(PI(y._1, intoR), this :: y._2.src), y._2)
			}))
			for (pl <- pll; (hgp, p) <- pl) {
				hgp.longer = p.longer.filter(_.src.length <= 5).map(x => pl.find(_._2 == x) match {
					case Some((lhp, lp)) => lhp
					case None => throw new Exception("weird path!!")
				})
			}
			start.longer = pll.map(_.head._1)
			start :: pll.flatMap(_.map(_._1))
		}
		
		@transient override lazy val hashCode = ("PI", term, intoR).hashCode
	}
	
	
	sealed abstract class Term extends Serializable {
		def word: WordInfo
		@transient protected[this] var itmr = null:IETermRef
		def ietmref = itmr
		def clear() { itmr = null }
		def setup(ie: IEBasic, ne: Boolean): Unit
	}
	
	case class WORD(word: WordInfo) extends Term {
		assert(word != null)
		
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				itmr = ie.getConstant(word).ref
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
	}
	
	case class IR(core: Term, sats: Set[(SemRole, Item)]) extends Term {
		assert(core != null)
		assert(sats.forall(x => x._1 != null && x._2 != null))
		
		def word = core.word
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				core.setup(ie, ne)
				sats.foreach(_._2.setup(ie, ne))
				itmr = {
					val coretm = core.ietmref.to
					val side = if (coretm.roles == null) {
						sats.map(_._2.ietmref.to)
					} else if (coretm.roles.size == 2) {
						sats.map(x => ie.getCP(Set((x._2.ietmref.to, x._1), (ie.getW(null), (coretm.roles - x._1).head))))
					} else {
						sats.map(x => ie.getCP(Set((x._2.ietmref.to, x._1), (ie.getW(coretm.roles - x._1), null))))
					}
					ie.getIN(side + coretm).ref
				}
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
	}
	
	case class PO(term: Term, dropR: SemRole) extends Term {
		assert(term != null)
		assert(dropR != null)
		
		def word = term.word
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				term.setup(ie, ne)
				itmr = ie.getPI(term.ietmref.to, term.ietmref.to.roles - dropR).ref
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
	}
	
	case class DI(term: Term, arg: Item, r: SemRole) extends Term {
		assert(term != null)
		assert(arg != null)
		assert(r != null)
		
		def word = term.word
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				term.setup(ie, ne)
				arg.setup(ie, false)
				itmr = ie.getDI(term.ietmref.to, arg.ietmref.to, r).ref
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
	}
	
	case class DU(term: Term, arg: Item, r: SemRole) extends Term {
		assert(term != null)
		assert(arg != null)
		assert(r != null)
		
		def word = term.word
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				term.setup(ie, ne)
				arg.setup(ie, false)
				itmr = ie.getDU(term.ietmref.to, arg.ietmref.to, r).ref
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
	}
	
	case class DE(term: Term, arg: Item, r: SemRole) extends Term {
		assert(term != null)
		assert(arg != null)
		assert(r != null)
		
		def word = term.word
		def setup(ie: IEBasic, ne: Boolean) {
			if (ietmref == null) {
				term.setup(ie, ne)
				arg.setup(ie, ne)
				itmr = ie.getDE(term.ietmref.to, arg.ietmref.to, r).ref
			}
			if (ne) ie.claimNonEmpty(ietmref.to)
		}
	}
}
