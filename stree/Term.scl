package tifmo

import knowledge.SemRole.SemRole
import knowledge.WordInfo
import inference.IETerm
import inference.IETermRef
import inference.IEBasic
import inference.Slction
import scala.collection.mutable

package stree {
	
	class Path(val acc: PI, val src: List[PI]) extends Serializable {
		
		@transient private[this] var lger = null:List[Path]
		private[stree] def longer_=(x: List[Path]) {
			assert(lger == null)
			lger = x
		}
		def longer = lger
		
		override def toString = src.map(_.term.word).mkString("", " | ", "")
	}
	
	class PI(val term: Term, val intoR: SemRole) extends Serializable {
		assert(term != null)
		assert(intoR != null)
		
		@transient private[this] var pcst = null:IETermRef
		private def piconst = pcst
		@transient private[this] var itmr = null:IETermRef
		def ietmref = itmr
		def roughMatch(that: PI) = {
			that.piconst != null && ietmref.to.hasSuper(that.piconst.to)
		}
		def veryRoughMatch(that: PI) = {
			(ietmref.to.superSets intersect that.ietmref.to.superSets).exists(!_.isW)
		}
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				term.setup(ie)
				itmr = if (term.ietmref.to.roles == null) {
					term.ietmref
				} else {
					ie.getPI(term.ietmref.to, Set(intoR)).ref
				}
				def constpi(w: WordInfo, r: SemRole) = {
					val pre = ie.getConstant(w)
					if (pre.roles == null) pre else ie.getPI(pre, Set(r))
				}
				pcst = if (term.word.isStopwd) {
					val inpool = mutable.Set.empty[IETerm]
					def recur(x: Term, r: SemRole) {
						x match {
							case WORD(word) => {}
							case IR(core, sats) => {
								for ((rr, pi) <- sats; if rr == r) {
									if (pi.term.word.isStopwd) {
										recur(pi.term, pi.intoR)
									} else {
										inpool.add(constpi(pi.term.word, pi.intoR))
									}
								}
								recur(core, r)
							}
							case PO(tm, rr) => { recur(tm, r) }
							case DI(tm, arg, rr) => recur(tm, r)
							case DU(tm, arg, rr) => recur(tm, r)
							case DE(tm, arg, rr) => recur(tm, r)
							case SL(tm, sel) => recur(tm, r)
						}
					}
					if (inpool.isEmpty) null else ie.getIN(inpool.toSet).ref
				} else {
					constpi(term.word, intoR).ref
				}
				if (ie.getCount - ie.getLastCount > 50) {
					//println("# of terms: " + ie.getCount)
					ie.explore()
				}
			}
		}
		def clear() {
			pcst = null
			itmr = null
		}
		
		@transient lazy val paths: List[Path] = {
			
			def construct(x: Term): (Term, List[List[(Term, Path)]]) = x match {
				case IR(core, sats) => {
					val (a, l) = construct(core)
					val retl = (for ((r, pi) <- sats.toList) yield {
						for (p <- pi.paths; if p.src.length <= 5) yield {
							(IR(a, Set((r, p.acc))), p)
						}
					}) ::: l.map(_.map(y => (IR(y._1, Set.empty[(SemRole, PI)]), y._2)))
					(IR(a, Set.empty[(SemRole, PI)]), retl)
				}
				case PO(tm, r) => {
					val (a, l) = construct(tm)
					(PO(a, r), l.map(_.map(y => (PO(y._1, r), y._2))))
				}
				case DI(tm, arg, r) => {
					val (a, l) = construct(tm)
					(DI(a, arg, r), l.map(_.map(y => (DI(y._1, arg, r), y._2))))
				}
				case _ => (x, Nil)
			}
			
			val (a, l) = construct(term)
			val start = new Path(new PI(a, intoR), List(this))
			val pll = l.map(_.map(y => {
				val acc = new PI(y._1, intoR)
				(new Path(acc, this :: y._2.src), y._2)
			}))
			for (pl <- pll; (hgp, p) <- pl) {
				hgp.longer = p.longer.filter(_.src.length <= 5).map(x => pl.find(_._2 == x) match {
					case Some((lhp, lp)) => lhp
					case None => throw new Exception("weird path!!")
				})
			}
			start.longer = pll.map(_.head._1)
			start :: pll.flatMap(_.map(_._1))
		}
		
		override def equals(a: Any) = {
			if (a.isInstanceOf[PI]) {
				val that = a.asInstanceOf[PI]
				term == that.term && intoR == that.intoR
			} else {
				false
			}
		}
		override lazy val hashCode = (("PI", term, intoR)).hashCode
		override def toString = "PI[" + intoR + "](" + term + ")"
	}
	
	sealed abstract class Term extends Serializable {
		def word: WordInfo
		@transient protected[this] var itmr = null:IETermRef
		def ietmref = itmr
		def clear() { itmr = null }
		def setup(ie: IEBasic): Unit
	}
	
	case class WORD(word: WordInfo) extends Term {
		assert(word != null)
		
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				itmr = ie.getConstant(word).ref
			}
		}
	}
	
	case class IR(core: Term, sats: Set[(SemRole, PI)]) extends Term {
		assert(core != null)
		assert(sats.forall(x => x._1 != null && x._2 != null))
		
		def word = core.word
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				core.setup(ie)
				sats.foreach(_._2.setup(ie))
				itmr = {
					val coretm = core.ietmref.to
					val side = if (coretm.roles == null) {
						sats.map(_._2.ietmref.to)
					} else if (coretm.roles.size == 2) {
						sats.map(x => ie.getCP(Set((x._2.ietmref.to, x._1), (ie.getW(null), (coretm.roles - x._1).head))))
					} else {
						sats.map(x => ie.getCP(Set((x._2.ietmref.to, x._1), (ie.getW(coretm.roles - x._1), null))))
					}
					ie.getIN(side + coretm).ref
				}
			}
		}
	}
	
	case class PO(term: Term, dropR: SemRole) extends Term {
		assert(term != null)
		assert(dropR != null)
		
		def word = term.word
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				term.setup(ie)
				itmr = ie.getPI(term.ietmref.to, term.ietmref.to.roles - dropR).ref
			}
		}
	}
	
	case class DI(term: Term, arg: PI, r: SemRole) extends Term {
		assert(term != null)
		assert(arg != null)
		assert(r != null)
		
		def word = term.word
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				term.setup(ie)
				arg.setup(ie)
				itmr = ie.getDI(term.ietmref.to, arg.ietmref.to, r).ref
			}
		}
	}
	
	case class DU(term: Term, arg: PI, r: SemRole) extends Term {
		assert(term != null)
		assert(arg != null)
		assert(r != null)
		
		def word = term.word
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				term.setup(ie)
				arg.setup(ie)
				itmr = ie.getDU(term.ietmref.to, arg.ietmref.to, r).ref
			}
		}
	}
	
	case class DE(term: Term, arg: PI, r: SemRole) extends Term {
		assert(term != null)
		assert(arg != null)
		assert(r != null)
		
		def word = term.word
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				term.setup(ie)
				arg.setup(ie)
				itmr = ie.getDE(term.ietmref.to, arg.ietmref.to, r).ref
			}
		}
	}
	
	case class SL(term: Term, sel: Slction) extends Term {
		assert(term != null)
		assert(sel != null)
		
		def word = term.word
		def setup(ie: IEBasic) {
			if (ietmref == null) {
				term.setup(ie)
				itmr = ie.getSL(term.ietmref.to, sel).ref
			}
		}
	}
}
