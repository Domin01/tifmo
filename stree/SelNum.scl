package tifmo

import inference.Slction
import inference.IETerm
import inference.IETermRef
import inference.IEBasic
import scala.collection.mutable

package stree {
	
	private[stree] class SelNumRule(ie: IEBasic) {
		
		private[this] var pool = mutable.Set.empty[(IETermRef, IETermRef)]
		
		private[this] val rSL0 = (args: List[Any]) => args match {
			case (sup:IETerm) :: (h:IETerm) :: (a:IETerm) :: Nil => {
				pool.find(_._2.to == sup) match {
					case Some((stmr, tmr)) => {
						ie.claimSubsume(stmr.to, h)
						ie.claimSubsume(h, stmr.to)
					}
					case None => {}
				}
			}
			case _ => throw new Exception("rSL0 error!")
		}
		private[this] val rSL1 = (sup: IETerm, args: List[Any]) => ie.conclude(sup :: args, rSL0)_
		private[this] val rSL2 = (args: List[Any]) => args match {
			case (h:IETerm) :: (a:IETerm) :: Nil => {
				ie.foreachSuperset(a, args, rSL1)_
			}
			case _ => throw new Exception("rSL2 error!")
		}
		private[this] val rSL3 = (ha: List[IETerm], args: List[Any]) => (dep: Set[IETerm]) => ha match {
			case (h:IETerm) :: (a:IETerm) :: Nil => {
				ie.ifNotEmpty(h, h :: a :: args, rSL2)(dep + a)
			}
			case _ => throw new Exception("rSL3 error!")
		}
		
		private[stree] def claim(h: IETerm, a: IETerm) {
			pool.add((h.ref, a.ref))
			ie.forSpecific(List(h, a), Nil, rSL3)(Set.empty[IETerm])
		}
	}
	
	case class SelNum(num: String) extends Slction {
		
		private[this] var rhelper = null:SelNumRule
		private def ruleHelper = rhelper
		
		def genStr(tmstr: String) = {
			"SelNum[" + num + "](" + tmstr + ")"
		}
		
		def claimSL(h: IETerm, a: IETerm, ie: IEBasic, sls: List[(IETermRef, Slction, IETermRef)]) {
			rhelper = sls.find(_._2 == this) match {
				case Some((hr, sl, tr)) => sl.asInstanceOf[SelNum].ruleHelper
				case None => new SelNumRule(ie)
			}
			ruleHelper.claim(h, a)
		}
	}
}
