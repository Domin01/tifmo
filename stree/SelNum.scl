package tifmo

import inference.Slction
import inference.IETerm
import inference.IEngine
import inference.FuncArg
import inference.FAConversion
import inference.IEPredNonEmpty
import inference.IEPredSubsume

package stree {
	
	class SelNum(private val nums: Set[String]) extends Slction with FAConversion {
		
		def applySL(h: IETerm, a: IETerm, ie: IEngine) {
				ie.claimSubsume(h, a)
				var task = Nil:List[() => Unit]
				for ((xh, xa) <- ie.selBy(this); if xh.knownNE && xa.hasSuper(a)) {
					task = (() => ie.claimSubsume(h, xh)) :: task
					task = (() => ie.claimSubsume(xh, h)) :: task
				}
				task.foreach(_())
				ie.ifNotEmpty(h, List(this, a, ie), SelNum.rSLNum1)
		}
		
		override def equals(a: Any) = {
			if (a.isInstanceOf[SelNum]) {
				val that = a.asInstanceOf[SelNum]
				!(nums intersect that.nums).isEmpty
			} else {
				false
			}
		}
		override def hashCode = "SelNum".hashCode
		override def toString = "SelNum[" + nums.mkString("", ",", "") + "]"
	}
	
	object SelNum extends FAConversion {
		
		val rSLNum0 = (sub: IEPredSubsume, args: List[FuncArg]) => args match {
			case FuncArg(slct:Slction) :: FuncArg(h:IETerm) :: FuncArg(ie:IEngine) :: Nil => {
				val fd = ie.findSL(h.roles, Set((null:IETerm, sub.superset, slct)))
				if (fd != null) {
					ie.claimSubsume(fd, h)
					ie.claimSubsume(h, fd)
				}
			}
			case _ => throw new Exception("rSLNum0 error!")
		}
		
		val rSLNum1 = (ne: IEPredNonEmpty, args: List[FuncArg]) => args match {
			case FuncArg(slct:Slction) :: FuncArg(a:IETerm) :: FuncArg(ie:IEngine) :: Nil => {
				ie.foreachSuperset(a, List(slct, ne.term, ie), rSLNum0)
			}
			case _ => throw new Exception("rSLNum1 error!")
		}
		
	}
	
}
