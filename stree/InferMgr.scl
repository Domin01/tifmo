package tifmo

import knowledge.SemRole.SemRole
import knowledge.WordInfo
import inference.IEBasic
import scala.collection.mutable

package stree {
	
	class InferMgr(hypo: STree) {
		
		private[this] var premTree = Nil:List[STree]
		def addPremise(stree: STree) {
			premTree = stree :: premTree
		}
		
		private[this] var premAtom = Nil:List[AtomSt]
		def addPremise(atomst: AtomSt) {
			premAtom = atomst :: premAtom
		}
		
		private[this] var hypernyms = Nil:List[(WordInfo, WordInfo)]
		def addHypernym(sub: WordInfo, hyper: WordInfo) {
			hypernyms = (sub, hyper) :: hypernyms
		}
		def addSynonym(x: WordInfo, y: WordInfo) {
			addHypernym(x, y)
			addHypernym(y, x)
		}
		def addAntonym(x: WordInfo, y: WordInfo) {
			assert(x.sign && y.sign)
			addSynonym(x.neg, y)
			addSynonym(y.neg, x)
		}
		
		private[this] var exclusives = Nil:List[(WordInfo, WordInfo)]
		def addExclusive(x: WordInfo, y: WordInfo) {
			exclusives = (x, y) :: exclusives
		}
		
		private[this] var schemas = Nil:List[Schema]
		def addSchema(s: Schema) {
			schemas = s :: schemas
		}
		
		private[this] val lexRoleMap = mutable.Map.empty[String, Set[SemRole]]
		private[this] val setLexRoles = (lex: String, rs: Set[SemRole]) => {
			if (lexRoleMap.contains(lex)) {
				lexRoleMap(lex) = lexRoleMap(lex) ++ rs
			} else {
				lexRoleMap(lex) = rs
			}
		}
		private[this] val getLexRoles = lexRoleMap(_)
		
		private[this] def allocateRoles() {
			premAtom.foreach(_.demandRoles(setLexRoles))
			premTree.foreach(_.streeNodeList.foreach(n => {
				if (!n.word.isPronoun) setLexRoles(n.word.lex, n.execorder.toSet)
			}))
			hypo.streeNodeList.foreach(n => {
				if (!n.word.isPronoun) setLexRoles(n.word.lex, n.execorder.toSet)
			})
			schemas.foreach(_.demandRoles(setLexRoles))
			for ((a, b) <- hypernyms) {
				setLexRoles(a.lex, Set.empty[SemRole])
				setLexRoles(b.lex, Set.empty[SemRole])
			}
			for ((a, b) <- exclusives) {
				setLexRoles(a.lex, Set.empty[SemRole])
				setLexRoles(b.lex, Set.empty[SemRole])
			}
			val tmp = lexRoleMap.toMap
			for ((a, b) <- hypernyms) {
				setLexRoles(a.lex, tmp(b.lex))
				setLexRoles(b.lex, tmp(a.lex))
			}
			for ((a, b) <- exclusives) {
				setLexRoles(a.lex, tmp(b.lex))
				setLexRoles(b.lex, tmp(a.lex))
			}
		}
		
		def trace(confidence: (Align) => Double, threshold: Double) = {
			
			allocateRoles()
			val pre = premAtom ::: premTree.flatMap(_.meaning(getLexRoles))
			val aim = hypo.meaning(getLexRoles)
			
			val piPool = mutable.Set.empty[PI]
			val slPoolT = mutable.Set.empty[SL]
			val slPoolH = mutable.Set.empty[SL]
			def extract(st: AtomSt, slpool: mutable.Set[SL]) {
				def recur(x: Term) {
					x match {
						case WORD(word) => {}
						case IR(core, sats) => {
							recur(core)
							sats.foreach(y => {
								piPool.add(y._2)
								recur(y._2.term)
							})
						}
						case PO(tm, r) => recur(tm)
						case DI(tm, arg, r) => {
							recur(tm)
							piPool.add(arg)
							recur(arg.term)
						}
						case DU(tm, arg, r) => {
							recur(tm)
							piPool.add(arg)
							recur(arg.term)
						}
						case DE(tm, arg, r) => {
							recur(tm)
							piPool.add(arg)
							recur(arg.term)
						}
						case xsl @ SL(tm, sel) => {
							slpool.add(xsl)
							recur(tm)
						}
					}
				}
				st match {
					case NonEmpty(a) => {
						piPool.add(a)
						recur(a.term)
					}
					case Subsume(a, b) => {
						piPool.add(a)
						piPool.add(b)
						recur(a.term)
						recur(b.term)
					}
					case Disjoint(a, b) => {
						piPool.add(a)
						piPool.add(b)
						recur(a.term)
						recur(b.term)
					}
				}
			}
			pre.foreach(extract(_, slPoolT))
			aim.foreach(extract(_, slPoolH))
			val sch = (for (s <- schemas; pi <- piPool) yield {
				s(pi)
			}).flatten
			sch.foreach(extract(_, slPoolT))
			
			val (neT, neH) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			val (subLower, subUpper) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			val (djtLower, djtUpper) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			def sepPrem(st: AtomSt) {
				st match {
					case NonEmpty(a) => neT.add(a)
					case Subsume(a, b) => {
						subUpper.add(a)
						subLower.add(b)
					}
					case Disjoint(a, b) => {
						djtUpper.add(a)
						djtUpper.add(b)
					}
				}
			}
			pre.foreach(sepPrem(_))
			sch.foreach(sepPrem(_))
			def sepHypo(st: AtomSt) {
				st match {
					case NonEmpty(a) => neH.add(a)
					case Subsume(a, b) => {
						subLower.add(a)
						subUpper.add(b)
					}
					case Disjoint(a, b) => {
						djtLower.add(a)
						djtLower.add(b)
					}
				}
			}
			aim.foreach(sepHypo(_))
			
			val target = {
				val tmp1 = Align.genTargetPI(djtLower, djtUpper, Nil)
				val tmp2 = Align.genTargetPI(subLower, subUpper, tmp1)
				val tmp3 = {
					def sepSel(sl: SL, selnumpool: mutable.Map[SelNum, Set[Term]]) {
						sl.sel match {
							case sn @ SelNum(num) => {
								if (selnumpool.contains(sn)) {
									selnumpool(sn) = selnumpool(sn) + sl.term
								} else {
									selnumpool(sn) = Set(sl.term)
								}
							}
							case _ => {}
						}
					}
					val selnumPoolT = mutable.Map.empty[SelNum, Set[Term]]
					val selnumPoolH = mutable.Map.empty[SelNum, Set[Term]]
					slPoolT.foreach(sepSel(_, selnumPoolT))
					slPoolH.foreach(sepSel(_, selnumPoolH))
					(tmp2 /: (selnumPoolT.keySet intersect selnumPoolH.keySet))((tmp, k) => {
						Align.genTargetTM(selnumPoolT(k), selnumPoolH(k), tmp)
					})
				}
				Align.genTargetPI(neT.toSet, neH.toSet, tmp3)
			}
			
			val part = hypo.partial
			
			val ie = new IEBasic
			for (k <- lexRoleMap.keys) {
				val rs = if (lexRoleMap(k).size <= 1) null else lexRoleMap(k)
				ie.newConstant(k, rs)
			}
			for ((x, y) <- hypernyms) {
				val xtm = ie.getConstant(x.lex).to
				val ytm = ie.getConstant(y.lex).to
				if (xtm.roles == null && ytm.roles == null) {
					ie.claimSubsume(xtm, ytm)
				} else if (xtm.roles != null && ytm.roles != null) {
					val crs = xtm.roles intersect ytm.roles
					if (!crs.isEmpty) {
						val atm = if (crs == xtm.roles) xtm else ie.getPI(xtm, crs)
						val btm = if (crs == ytm.roles) ytm else ie.getPI(ytm, crs)
						ie.claimSubsume(atm, btm)
					}
				}
			}
			for ((x, y) <- exclusives) {
				val xtm = ie.getConstant(x.lex).to
				val ytm = ie.getConstant(y.lex).to
				if (xtm.roles == null && ytm.roles == null) {
					ie.claimDisjoint(xtm, ytm)
				} else if (xtm.roles != null && ytm.roles != null) {
					val crs = xtm.roles intersect ytm.roles
					if (!crs.isEmpty) {
						val atm = if (crs == xtm.roles) xtm else ie.getPI(xtm, crs)
						val btm = if (crs == ytm.roles) ytm else ie.getPI(ytm, crs)
						ie.claimDisjoint(atm, btm)
					}
				}
			}
			pre.foreach(_.clear())
			sch.foreach(_.clear())
			aim.foreach(_.clear())
			part.foreach(_._1.clear())
			pre.foreach(_.claim(ie))
			sch.foreach(_.claim(ie))
			slPoolT.foreach(x => ie.claimNonEmpty(x.term.ietmref.to))
			for ((xs, ys) <- target) {
				for (x <- xs) {
					x.setup(ie)
					x.paths.foreach(_.acc.setup(ie))
				}
				for (y <- ys) {
					y.setup(ie)
					y.paths.foreach(_.acc.setup(ie))
				}
			}
			part.foreach(_._1.setup(ie))
			
			println("partial: " + part.map(_._2).sum)
			//part.foreach(x => {
			//	println(" weight: " + x._2)
			//	println(" " + x._1)
			//})
			println("-----------")
			
			def loop() {
				
				ie.explore()
				
				println("proved: " + part.filter(_._1.check).map(_._2).sum)
				println("contradiction: " + ie.hasContra())
				
				if (!part.forall(_._1.check)) {
					val (neTsb, neHsb) = target.head
					val ptgt = (piPool.filter(_.ietmref.to.knownNE).toSet, neHsb.filter(!_.ietmref.to.knownNE)) :: target.tail
					val tmp = Align.all(ptgt)
					tmp.foreach(x => x.assign(confidence(x)))
					val fil = tmp.filter(_.score > threshold)
					if (!fil.isEmpty) {
						var score = threshold
						var chosen = null:List[Align]
						for (x <- fil) {
							if (x.score > score) {
								score = x.score
								chosen = List(x)
							} else if (x.score == score) {
								chosen = x :: chosen
							}
						}
						
						println("Alignments: ")
						chosen.foreach(println(_))
						println("-----------")
						
						for (x <- chosen) {
							val (a, b) = x.piPair
							Subsume(a, b).claim(ie)
						}
						loop()
					}
				}
			}
			loop()
		}
	}
}
