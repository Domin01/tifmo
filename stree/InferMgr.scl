package tifmo

import knowledge.SemRole.SemRole
import knowledge.WordInfo
import inference.IEBasic
import scala.collection.mutable

package stree {
	
	class InferMgr(hypo: STree) {
		
		private[this] var premTree = Nil:List[STree]
		def addPremise(stree: STree) {
			premTree = stree :: premTree
		}
		
		private[this] var premAtom = Nil:List[AtomSt]
		def addPremise(atomst: AtomSt) {
			premAtom = atomst :: premAtom
		}
		
		private[this] var hypernyms = Nil:List[(WordInfo, WordInfo)]
		def addHypernym(sub: WordInfo, hyper: WordInfo) {
			hypernyms = (sub, hyper) :: hypernyms
		}
		def addSynonym(x: WordInfo, y: WordInfo) {
			addHypernym(x, y)
			addHypernym(y, x)
		}
		/*
		private[this] var exclusives = Nil:List[(WordInfo, WordInfo)]
		def addExclusive(x: WordInfo, y: WordInfo) {
			exclusives = (x, y) :: exclusives
		}
		*/
		private[this] var schemas = Nil:List[Schema]
		def addSchema(s: Schema) {
			schemas = s :: schemas
		}
		
		private[this] val lexRoleMap = mutable.Map.empty[String, Set[SemRole]]
		private[this] val setLexRoles = (lex: String, rs: Set[SemRole]) => {
			if (lexRoleMap.contains(lex)) {
				lexRoleMap(lex) = lexRoleMap(lex) ++ rs
			} else {
				lexRoleMap(lex) = rs
			}
		}
		val getLexRoles = lexRoleMap(_)
		
		def allocateRoles() {
			premAtom.foreach(_.demandRoles(setLexRoles))
			premTree.foreach(_.streeNodeList.foreach(n => {
				setLexRoles(n.word.lex, n.execorder.toSet)
			}))
			hypo.streeNodeList.foreach(n => {
				setLexRoles(n.word.lex, n.execorder.toSet)
			})
			for ((a, b) <- hypernyms) {
				setLexRoles(a.lex, Set.empty[SemRole])
				setLexRoles(b.lex, Set.empty[SemRole])
			}
			/*
			for ((a, b) <- exclusives) {
				setLexRoles(a.lex, Set.empty[SemRole])
				setLexRoles(b.lex, Set.empty[SemRole])
			}
			*/
			val tmp = lexRoleMap.toMap
			for ((a, b) <- hypernyms) {
				setLexRoles(a.lex, tmp(b.lex))
				setLexRoles(b.lex, tmp(a.lex))
			}
			/*
			for ((a, b) <- exclusives) {
				setLexRoles(a.lex, tmp(b.lex))
				setLexRoles(b.lex, tmp(a.lex))
			}
			*/
		}
		
		def trace(confiFunc: (Align) => Double, threshold: Double) = {
			
			//allocateRoles()
			
			val pre = premAtom ::: premTree.flatMap(_.meaning(getLexRoles))
			val aim = hypo.meaning(getLexRoles)
			//val part = hypo.partial
			val props = hypo.nonTrivialProps
			val rpart = hypo.rolePartial
			val ppart = hypo.pathPartial
			
			pre.foreach(_.clear())
			aim.foreach(_.clear())
			//part.foreach(_._1.clear())
			props.foreach(_.clear())
			rpart.foreach(_._1.clear())
			ppart.foreach(_._1.clear())
			
			val ie = new IEBasic
			for (k <- lexRoleMap.keys) {
				val rs = if (lexRoleMap(k).size <= 1) null else lexRoleMap(k)
				ie.newConstant(k, rs)
			}
			for ((x, y) <- hypernyms) {
				val xtm = ie.getConstant(x)
				val ytm = ie.getConstant(y)
				if (xtm.roles == null && ytm.roles == null) {
					ie.claimSubsume(xtm, ytm)
				} else if (xtm.roles != null && ytm.roles != null) {
					val crs = xtm.roles intersect ytm.roles
					if (!crs.isEmpty) {
						val atm = if (crs == xtm.roles) xtm else ie.getPI(xtm, crs)
						val btm = if (crs == ytm.roles) ytm else ie.getPI(ytm, crs)
						ie.claimSubsume(atm, btm)
					}
				}
			}
			/*
			for ((x, y) <- exclusives) {
				val xtm = ie.getConstant(x)
				val ytm = ie.getConstant(y)
				if (xtm.roles == null) {
					if (ytm.roles == null) {
						ie.claimDisjoint(xtm, ytm)
					} else {
						for (r <- ytm.roles) {
							ie.claimDisjoint(xtm, ie.getPI(ytm, Set(r)))
						}
					}
				} else {
					if (ytm.roles == null) {
						for (r <- xtm.roles) {
							ie.claimDisjoint(ytm, ie.getPI(xtm, Set(r)))
						}
					} else {
						for (r <- xtm.roles intersect ytm.roles) {
							ie.claimDisjoint(ie.getPI(xtm, Set(r)), ie.getPI(ytm, Set(r)))
						}
					}
				}
			}
			*/
			pre.foreach(_.claim(ie))
			aim.foreach(_.setup(ie))
			//part.foreach(_._1.setup(ie))
			props.foreach(_.setup(ie))
			rpart.foreach(_._1.setup(ie))
			ppart.foreach(_._1.setup(ie))
			
			val (tgt, selT, selH) = Align.genTarget(pre, aim)
			
			// add some additional conditions about selections here
			selT.foreach(x => ie.claimNonEmpty(x.term.ietmref.to))
			
			ie.explore()
			
			var pretask = Nil:List[AtomSt]
			for (sch <- schemas; (xs, ys) <- tgt; x <- xs; y <- ys) {
				sch.prePair(x, y) match {
					case Some((a, b)) => pretask = Subsume(a, b) :: pretask
					case None => {}
				}
			}
			pretask.foreach(_.claim(ie))
			
			var fulltask = Nil:List[AtomSt]
			for (sch <- schemas; (xs, ys) <- tgt; x <- xs; y <- ys) {
				sch.fullPair(x, y) match {
					case Some((a, b)) => {
						//println("schema: " + a.term.word + " " + b.term.word)
						fulltask = Subsume(a, b) :: fulltask
					}
					case None => {}
				}
			}
			fulltask.foreach(_.claim(ie))
			
			for ((xs, ys) <- tgt) {
				for (x <- xs) {
					x.paths.foreach(_.acc.setup(ie))
				}
				for (y <- ys) {
					y.paths.foreach(_.acc.setup(ie))
				}
			}
			
			val propnum = props.length
			val rweight = STree.roleWeight(hypo.streeNodeList)
			val pweight = STree.pathWeight(hypo.streeNodeList)
			
			val propsInit = props.filter(_.check).length
			val rpartInit = rpart.filter(_._1.check).map(_._2).sum
			val ppartInit = ppart.filter(_._1.check).map(_._2).sum
			
			//val totnum = part.map(_._2).sum
			//val provedInit = part.filter(_._1.check).map(_._2).sum
			
			val contraInit = ie.hasContra()
			
			//println("partial: " + part.map(_._2).sum)
			//println("-----------")
			
			//var ret = List(new TraceInfo(totnum, provedInit, contraInit, Nil, provedInit, contraInit))
			var ret = List(new TraceInfo(propnum, rweight, pweight, 
				propsInit, rpartInit, ppartInit, contraInit, Nil, 
				propsInit, rpartInit, ppartInit, contraInit))
			def loop() {
				
				val propsBefore = props.filter(_.check).length
				val rpartBefore = rpart.filter(_._1.check).map(_._2).sum
				val ppartBefore = ppart.filter(_._1.check).map(_._2).sum
				
				//val provedBefore = part.filter(_._1.check).map(_._2).sum
				
				val contraBefore = ie.hasContra(true)
				
				//println("proved: " + provedBefore)
				//println("contradiction: " + contraBefore)
				
				//if (!part.forall(_._1.check)) {
				if (propsBefore < propnum) {
					
					val (piT, neH) = tgt.head
					val ptgt = (piT.filter(_.ietmref.to.knownNE), neH) :: tgt.tail
					
					val tmp = Align.all(ptgt)
					tmp.foreach(x => x.assign(confiFunc(x)))
					val fil = tmp.filter(_.score > threshold)
					
					if (!fil.isEmpty) {
						var score = threshold
						var chosen = null:List[Align]
						for (x <- fil) {
							if (x.score > score) {
								score = x.score
								chosen = List(x)
							} else if (x.score == score) {
								chosen = x :: chosen
							}
						}
						
						//println("Alignments: ")
						//val msgs = chosen.map(_.toString).toSet
						//msgs.foreach(println(_))
						//println("-----------")
						
						for (x <- chosen) {
							val (a, b) = x.piPair
							Subsume(a, b).claim(ie)
						}
						
						val propsAfter = props.filter(_.check).length
						val rpartAfter = rpart.filter(_._1.check).map(_._2).sum
						val ppartAfter = ppart.filter(_._1.check).map(_._2).sum
						
						//val provedAfter = part.filter(_._1.check).map(_._2).sum
						
						val contraAfter = ie.hasContra()
						
						//ret = new TraceInfo(totnum, provedBefore, contraBefore, chosen, provedAfter, contraAfter) :: ret
						ret = new TraceInfo(propnum, rweight, pweight, 
							propsBefore, rpartBefore, ppartBefore, contraBefore, chosen, 
							propsAfter, rpartAfter, ppartAfter, contraAfter) :: ret
						
						loop()
					}
				}
			}
			loop()
			ret.reverse
		}
	}
}
