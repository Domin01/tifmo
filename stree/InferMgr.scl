package tifmo

import knowledge.SemRole.SemRole
import knowledge.WordInfo
import inference.IEBasic
import scala.collection.mutable

package stree {
	
	class InferMgr(hypo: STree) {
		
		private[this] var premTree = Nil:List[STree]
		def addPremise(stree: STree) {
			premTree = stree :: premTree
		}
		
		private[this] var premAtom = Nil:List[AtomSt]
		def addPremise(atomst: AtomSt) {
			premAtom = atomst :: premAtom
		}
		
		private[this] var hypernyms = Nil:List[(WordInfo, WordInfo)]
		def addHypernym(sub: WordInfo, hyper: WordInfo) {
			hypernyms = (sub, hyper) :: hypernyms
		}
		def addSynonym(x: WordInfo, y: WordInfo) {
			addHypernym(x, y)
			addHypernym(y, x)
		}
		
		private[this] var schemas = Nil:List[Schema]
		def addSchema(s: Schema) {
			schemas = s :: schemas
		}
		
		private[this] val lexRoleMap = mutable.Map.empty[String, Set[SemRole]]
		private[this] val setLexRoles = (lex: String, rs: Set[SemRole]) => {
			if (lexRoleMap.contains(lex)) {
				lexRoleMap(lex) = lexRoleMap(lex) ++ rs
			} else {
				lexRoleMap(lex) = rs
			}
		}
		val getLexRoles = lexRoleMap(_)
		
		def allocateRoles() {
			premAtom.foreach(_.demandRoles(setLexRoles))
			premTree.foreach(_.demandRoles(setLexRoles))
			hypo.demandRoles(setLexRoles)
			for ((a, b) <- hypernyms) {
				setLexRoles(a.lex, Set.empty[SemRole])
				setLexRoles(b.lex, Set.empty[SemRole])
			}
			val tmp = lexRoleMap.toMap
			for ((a, b) <- hypernyms) {
				setLexRoles(a.lex, tmp(b.lex))
				setLexRoles(b.lex, tmp(a.lex))
			}
		}
		
		def trace(confiFunc: (Align) => (Double, String), threshold: Double, patience: Int) = {
			
			//allocateRoles()
			
			val pre = premAtom ::: premTree.flatMap(_.meaning(getLexRoles))
			val aim = hypo.meaning(getLexRoles)
			val props = hypo.nonTrivialProps
			val rpart = hypo.rolePartial
			val ppart = hypo.pathPartial
			
			pre.foreach(_.clear())
			aim.foreach(_.clear())
			props.foreach(_.clear())
			rpart.foreach(_._1.clear())
			ppart.foreach(_._1.clear())
			
			val ie = new IEBasic
			for (k <- lexRoleMap.keys) {
				val rs = if (lexRoleMap(k).size <= 1) null else lexRoleMap(k)
				ie.newConstant(k, rs)
			}
			for ((x, y) <- hypernyms) {
				val xtm = ie.getConstant(x)
				val ytm = ie.getConstant(y)
				if (xtm.roles == null && ytm.roles == null) {
					ie.claimSubsume(xtm, ytm)
				} else if (xtm.roles != null && ytm.roles != null) {
					val crs = xtm.roles intersect ytm.roles
					if (!crs.isEmpty) {
						val atm = if (crs == xtm.roles) xtm else ie.getPI(xtm, crs)
						val btm = if (crs == ytm.roles) ytm else ie.getPI(ytm, crs)
						ie.claimSubsume(atm, btm)
					}
				}
			}
			
			// claim NE first: deliver the NE label faster so as to eliminate more CP dups
			for (x <- pre; if x.isInstanceOf[NonEmpty]) {
				x.claim(ie)
			}
			for (x <- pre; if !x.isInstanceOf[NonEmpty]) {
				x.claim(ie)
			}
			aim.foreach(_.setup(ie))
			props.foreach(_.setup(ie))
			rpart.foreach(_._1.setup(ie))
			ppart.foreach(_._1.setup(ie))
			
			System.err.println("Condition explore. over.")
			
			val tgt = Align.genTarget(pre, aim)
			
			/*
			var pretask = Nil:List[AtomSt]
			for (sch <- schemas; (xs, ys) <- tgt; x <- xs; y <- ys) {
				sch.prePair(x, y) match {
					case Some((a, b)) => pretask = Subsume(a, b) :: pretask
					case None => {}
				}
			}
			pretask.foreach(_.claim(ie))
			*/
			var fulltask = Nil:List[AtomSt]
			for (sch <- schemas; (xs, ys) <- tgt; x <- xs; y <- ys) {
				sch.fullPair(x, y) match {
					case Some((a, b)) => {
						fulltask = Subsume(a, b) :: fulltask
					}
					case None => {}
				}
			}
			fulltask.foreach(_.claim(ie))
			
			for ((xs, ys) <- tgt) {
				for (x <- xs) {
					x.paths.foreach(_.acc.setup(ie, false))
				}
				for (y <- ys) {
					y.paths.foreach(_.acc.setup(ie, false))
				}
			}
			val presbs = for (x <- Align.pre(tgt); (a, b) = x.piPair) yield {
				Subsume(a, b)
			}
			presbs.foreach(_.claim(ie))
			
			System.err.println("target generation & schema matching & preAlign. over")
			
			val propnum = props.length
			val rweight = STree.roleWeight(hypo.streeNodeList)
			val pweight = STree.pathWeight(hypo.streeNodeList)
			
			val propsInit = props.filter(_.check).length
			val rpartInit = rpart.filter(_._1.check).map(_._2).sum
			val ppartInit = ppart.filter(_._1.check).map(_._2).sum
			
			val contraInit = ie.hasContra()
			
			var ret = List(new TraceInfo(propnum, rweight, pweight, 
				propsInit, rpartInit, ppartInit, contraInit, Nil, 
				propsInit, rpartInit, ppartInit, contraInit))
			var allalgns = Nil:List[Align]
			var invain = 0
			def loop() {
				
				val propsBefore = props.filter(_.check).length
				val rpartBefore = rpart.filter(_._1.check).map(_._2).sum
				val ppartBefore = ppart.filter(_._1.check).map(_._2).sum
				
				val contraBefore = ie.hasContra(true)
				
				if (propsBefore < propnum) {
					
					val allalgs = Align.all(tgt)
					
					val tmp = allalgs.par
					
					System.err.println("align generation. over. candidates: " + tmp.length)
					
					tmp.foreach(x => {
						val (c, t) = confiFunc(x)
						x.assign(c, t)
					})
					val fil = tmp.filter(_.confidence > threshold).toList
					
					System.err.println("assign confidence. over.")
					
					if (!fil.isEmpty) {
						var confidence = threshold
						var category = null:String
						var chosen = null:List[Align]
						for (x <- fil) {
							if (x.confidence > confidence || (x.confidence == confidence && x.category > category)) {
								confidence = x.confidence
								category = x.category
								chosen = List(x)
							} else if (x.confidence == confidence && x.category == category) {
								chosen = x :: chosen
							}
						}
						
						allalgns = chosen ::: allalgns
						val sbs = for (x <- allalgns; (a, b) = x.piPair) yield {
							
							b.setup(ie, false)
							ie.explore()
							assert(b.ietmref.to.hasSuper(x.hp.acc.ietmref.to))
							
							Subsume(a, b)
						}
						sbs.foreach(_.claim(ie))
						
						System.err.println("claim subsume. over. chosen: " + chosen.length + " all aligns: " + allalgns.length)
						
						val propsAfter = props.filter(_.check).length
						val rpartAfter = rpart.filter(_._1.check).map(_._2).sum
						val ppartAfter = ppart.filter(_._1.check).map(_._2).sum
						
						val contraAfter = ie.hasContra()
						
						if (propsAfter == propsBefore && rpartAfter == rpartBefore && ppartAfter == ppartBefore) {
							invain += 1
						} else {
							invain = 0
						}
						
						System.err.println("in vain: " + invain)
						
						ret = new TraceInfo(propnum, rweight, pweight, 
							propsBefore, rpartBefore, ppartBefore, contraBefore, chosen, 
							propsAfter, rpartAfter, ppartAfter, contraAfter) :: ret
						
						System.err.println(ret.head)
						
						if (patience > invain) loop()
					}
				}
			}
			
			if (hypo.streeNodeList.length < 100) {
				loop()
			}
			
			ret.reverse
		}
	}
}
