package tifmo

import scala.collection.mutable

package stree {
	
	class Align(val tp: Path, val hp: Path, val clue: Path, val soft: Boolean) extends Serializable {
		
		private[this] var scr = 0.0
		private[stree] def assign(x: Double) {
			scr = x
		}
		def score = scr
		
		def piPair = {
			
			val tpipool = mutable.Set.empty[PI]
			def extract(acctm: Term, srctm: Term, supps: List[PI]) {
				srctm match {
					case IR(core, sats) => acctm match {
						case IR(acore, asats) => {
							assert(asats.size <= 1)
							val nsats = if (!asats.isEmpty) {
								val pp = (asats.head._1, supps.head)
								assert(sats.contains(pp))
								tpipool ++= (sats - pp).map(_._2)
								if (!supps.tail.isEmpty) {
									extract(asats.head._2.term, supps.head.term, supps.tail)
								}
							} else {
								tpipool ++= sats.map(_._2)
							}
							extract(acore, core, supps)
						}
						case _ => throw new Exception("weird path IR in extract!")
					}
					case PO(tm, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							extract(atm, tm, supps)
						}
						case _ => throw new Exception("weird path PO in extract!")
					}
					case DI(tm, arg, r) => acctm match {
						case DI(atm, aarg, ar) => {
							assert(r == ar && arg == aarg)
							extract(atm, tm, supps)
						}
						case _ => throw new Exception("weird path DI in extract!")
					}
					case _ => {}
				}
			}
			if (!tp.src.tail.isEmpty) {
				extract(tp.acc.term, tp.src.head.term, tp.src.tail)
			}
			
			def construct(acctm: Term, srctm: Term, supps: List[PI]): Term = {
				srctm match {
					case IR(core, sats) => acctm match {
						case IR(acore, asats) => {
							assert(asats.size <= 1)
							val nsats = if (!asats.isEmpty) {
								val pp = (asats.head._1, supps.head)
								assert(sats.contains(pp))
								val pren = (sats - pp).flatMap(x => {
									tpipool.filter(_.roughMatch(x._2)).map((x._1, _))
								})
								pren + (if (supps.tail.isEmpty) {
									if (soft) {
										(pp._1, tp.src.last)
									} else {
										(pp._1, hp.src.last)
									}
								} else {
									assert(asats.head._2.intoR == supps.head.intoR)
									val tm = construct(asats.head._2.term, supps.head.term, supps.tail)
									(pp._1, new PI(tm, supps.head.intoR))
								})
							} else {
								sats.flatMap(x => {
									tpipool.filter(_.roughMatch(x._2)).map((x._1, _))
								})
							}
							val ncore = construct(acore, core, supps)
							IR(ncore, nsats)
						}
						case _ => throw new Exception("weird path IR in construct!")
					}
					case PO(tm, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							PO(construct(atm, tm, supps), r)
						}
						case _ => throw new Exception("weird path PO in construct!")
					}
					case DI(tm, arg, r) => acctm match {
						case DI(atm, aarg, ar) => {
							assert(r == ar && arg == aarg)
							DI(construct(atm, tm, supps), arg, r)
						}
						case _ => throw new Exception("weird path DI in construct!")
					}
					case _ => {
						assert(acctm == srctm)
						acctm
					}
				}
			}
			val hpi = if (hp.src.tail.isEmpty) {
				if (soft) {
					tp.src.last
				} else {
					hp.src.last
				}
			} else {
				assert(hp.acc.intoR == hp.src.head.intoR)
				val tm = construct(hp.acc.term, hp.src.head.term, hp.src.tail)
				new PI(tm, hp.acc.intoR)
			}
			(tp.src.head, hpi)
		}
		
		override def toString = "by " + clue + " (" + tp + ") implies (" + hp + ")" + (if (soft) "" else "[hard]")
	}
	
	object Align {
				
		private[this] def getParts(x: Term, subs: mutable.Set[PI], diuargs: mutable.Set[PI], deargs: mutable.Set[PI], ditms: mutable.Set[Term], dutms: mutable.Set[Term], detms: mutable.Set[Term]) = {
			
			val recurCache = mutable.Set.empty[Term]
			def recur(x: Term) {
				if (recurCache.add(x)) {
					x match {
						case WORD(word) => {}
						case IR(core, sats) => {
							subs ++= sats.map(_._2)
							recur(core)
							sats.foreach(y => recur(y._2.term))
						}
						case PO(tm, r) => {
							recur(tm)
						}
						case DI(tm, arg, r) => {
							diuargs += arg
							ditms += tm
							recur(tm)
						}
						case DU(tm, arg, r) => {
							diuargs += arg
							dutms += tm
						}
						case DE(tm, arg, r) => {
							deargs += arg
							detms += tm
						}
						case SL(tm, sel) => {}
					}
				}
			}
			
			recur(x)
		}
		
		private[this] def genTargetPI(lower: Iterable[PI], upper: Iterable[PI], fund: List[(Set[PI], Set[PI])]): List[(Set[PI], Set[PI])] = {
			
			val lsubs = mutable.Set.empty[PI] ++ lower
			val (ldiuargs, ldeargs, lditms, ldutms, ldetms) = 
				(mutable.Set.empty[PI], mutable.Set.empty[PI], mutable.Set.empty[Term], mutable.Set.empty[Term], mutable.Set.empty[Term])
			lower.foreach(x => getParts(x.term, lsubs, ldiuargs, ldeargs, lditms, ldutms, ldetms))
			
			val usubs = mutable.Set.empty[PI] ++ upper
			val (udiuargs, udeargs, uditms, udutms, udetms) = 
				(mutable.Set.empty[PI], mutable.Set.empty[PI], mutable.Set.empty[Term], mutable.Set.empty[Term], mutable.Set.empty[Term])
			upper.foreach(x => getParts(x.term, usubs, udiuargs, udeargs, uditms, udutms, udetms))
			
			if (lsubs.isEmpty || usubs.isEmpty) {
				fund
			} else {
				val tmp1 = genTargetPI(udiuargs, ldiuargs ++ ldeargs, fund)
				val tmp2 = genTargetPI(udeargs, ldeargs, tmp1)
				val tmp3 = genTargetPI(ldeargs, udeargs, tmp2)
				val tmp4 = genTargetTM(ldetms, udetms ++ uditms, tmp3)
				val tmp5 = genTargetTM(udetms, ldetms, tmp4)
				val tmp6 = genTargetTM(udutms, ldutms, tmp5)
				val tmp7 = genTargetTM(ldutms, udutms, tmp6)
				(lsubs.toSet, usubs.toSet) :: tmp7
			}
		}
		
		private[this] def genTargetTM(lower: Iterable[Term], upper: Iterable[Term], fund: List[(Set[PI], Set[PI])]): List[(Set[PI], Set[PI])] = {
			
			val lsubs = mutable.Set.empty[PI]
			val (ldiuargs, ldeargs, lditms, ldutms, ldetms) = 
				(mutable.Set.empty[PI], mutable.Set.empty[PI], mutable.Set.empty[Term], mutable.Set.empty[Term], mutable.Set.empty[Term])
			lower.foreach(x => getParts(x, lsubs, ldiuargs, ldeargs, lditms, ldutms, ldetms))
			
			val usubs = mutable.Set.empty[PI]
			val (udiuargs, udeargs, uditms, udutms, udetms) = 
				(mutable.Set.empty[PI], mutable.Set.empty[PI], mutable.Set.empty[Term], mutable.Set.empty[Term], mutable.Set.empty[Term])
			upper.foreach(x => getParts(x, usubs, udiuargs, udeargs, uditms, udutms, udetms))
			
			if (lsubs.isEmpty || usubs.isEmpty) {
				fund
			} else {
				val tmp1 = genTargetPI(udiuargs, ldiuargs ++ ldeargs, fund)
				val tmp2 = genTargetPI(udeargs, ldeargs, tmp1)
				val tmp3 = genTargetPI(ldeargs, udeargs, tmp2)
				val tmp4 = genTargetTM(ldetms, udetms ++ uditms, tmp3)
				val tmp5 = genTargetTM(udetms, ldetms, tmp4)
				val tmp6 = genTargetTM(udutms, ldutms, tmp5)
				val tmp7 = genTargetTM(ldutms, udutms, tmp6)
				(lsubs.toSet, usubs.toSet) :: tmp7
			}
		}
		
		def genTarget(pre: List[AtomSt], aim: List[AtomSt]) = {
			
			val (piPoolT, piPoolH) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			val (slPoolT, slPoolH) = (mutable.Set.empty[SL], mutable.Set.empty[SL])
			def extract(st: AtomSt, pipool: mutable.Set[PI], slpool: mutable.Set[SL]) {
				val recurCache = mutable.Set.empty[Term]
				def recur(x: Term) {
					if (recurCache.add(x)) {
						x match {
							case WORD(word) => {}
							case IR(core, sats) => {
								recur(core)
								sats.foreach(y => {
									pipool.add(y._2)
									recur(y._2.term)
								})
							}
							case PO(tm, r) => {
								recur(tm)
							}
							case DI(tm, arg, r) => {
								recur(tm)
								pipool.add(arg)
								recur(arg.term)
							}
							case DU(tm, arg, r) => {
								recur(tm)
								pipool.add(arg)
								recur(arg.term)
							}
							case DE(tm, arg, r) => {
								recur(tm)
								pipool.add(arg)
								recur(arg.term)
							}
							case xsl @ SL(tm, sel) => {
								slpool.add(xsl)
								recur(tm)
							}
						}
					}
				}
				st match {
					case NonEmpty(a) => {
						pipool.add(a)
						recur(a.term)
					}
					case Subsume(a, b) => {
						pipool.add(a)
						pipool.add(b)
						recur(a.term)
						recur(b.term)
					}
					case Disjoint(a, b) => {
						pipool.add(a)
						pipool.add(b)
						recur(a.term)
						recur(b.term)
					}
				}
			}
			pre.foreach(extract(_, piPoolT, slPoolT))
			aim.foreach(extract(_, piPoolH, slPoolH))
			
			val (neT, neH) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			val (subLower, subUpper) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			val (djtLower, djtUpper) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			def sepPrem(st: AtomSt) {
				st match {
					case NonEmpty(a) => neT.add(a)
					case Subsume(a, b) => {
						subUpper.add(a)
						subLower.add(b)
					}
					case Disjoint(a, b) => {
						djtUpper.add(a)
						djtUpper.add(b)
					}
				}
			}
			pre.foreach(sepPrem(_))
			def sepHypo(st: AtomSt) {
				st match {
					case NonEmpty(a) => neH.add(a)
					case Subsume(a, b) => {
						subLower.add(a)
						subUpper.add(b)
					}
					case Disjoint(a, b) => {
						djtLower.add(a)
						djtLower.add(b)
					}
				}
			}
			aim.foreach(sepHypo(_))
			
			val tmp1 = genTargetPI(djtLower, djtUpper, Nil)
			val tmp2 = genTargetPI(subLower, subUpper, tmp1)
			val tmp3 = {
				def sepSel(sl: SL, selnumpool: mutable.Map[SelNum, Set[Term]]) {
					sl.sel match {
						case sn @ SelNum(num) => {
							if (selnumpool.contains(sn)) {
								selnumpool(sn) = selnumpool(sn) + sl.term
							} else {
								selnumpool(sn) = Set(sl.term)
							}
						}
						case _ => {}
					}
				}
				val selnumPoolT = mutable.Map.empty[SelNum, Set[Term]]
				val selnumPoolH = mutable.Map.empty[SelNum, Set[Term]]
				slPoolT.foreach(sepSel(_, selnumPoolT))
				slPoolH.foreach(sepSel(_, selnumPoolH))
				(tmp2 /: (selnumPoolT.keySet intersect selnumPoolH.keySet))((tmp, k) => {
					genTargetTM(selnumPoolT(k), selnumPoolH(k), tmp)
				})
			}
			val tmp4 = genTargetPI(neT.toSet, neH.toSet, tmp3)
			((piPoolT.toSet, tmp4.head._2) :: tmp4.tail, slPoolT.toSet, slPoolH.toSet)
		}
		
		
		private[this] def findAligns(start: PI, clue: Path, hstart: Path, fund: List[Align]) = {
			
			def hasChildren(x: Term): Boolean = x match {
				case WORD(word) => false
				case DI(tm, arg, r) => true
				case DU(tm, arg, r) => true
				case DE(tm, arg, r) => true
				case IR(core, sats) => !sats.isEmpty || hasChildren(core)
				case PO(tm, r) => hasChildren(tm)
				case SL(tm, sel) => hasChildren(tm)
			}
			
			var als = fund
			
			def loopHypo(tp: Path, hp: Path, avoid: Set[Path], ret: List[Path]): List[Path] = {
				if (avoid.contains(hp)) {
					ret
				} else {
					if (tp.src.last.ietmref.to.hasSuper(hp.src.last.paths.head.acc.ietmref.to)) {
						als = new Align(tp, hp, clue, true) :: als
						hp :: ret
					} else {
						if (!hasChildren(tp.src.last.term) && !hasChildren(hp.src.last.term)) {
							als = new Align(tp, hp, clue, false) :: als
						}
						(ret /: hp.longer)((x, y) => loopHypo(tp, y, avoid, x))
					}
				}
			}
			
			def loopText(tp: Path, avoid: Set[Path]) {
				for (x <- tp.longer) {
					if (!clue.src.exists(x.src.last.roughMatch(_))) {
						loopText(x, avoid ++ loopHypo(x, hstart, avoid, Nil))
					}
				}
			}
			
			loopText(start.paths.head, Set.empty[Path])
			als
		}
		
		private[this] def findClues(start: PI, cinit: Path) = {
			var ret = Nil:List[(Path, Path)]
			def recur(x: Path) {
				for (y <- x.longer) {
					if (start.ietmref.to.hasSuper(y.acc.ietmref.to)) {
						recur(y)
					} else {
						ret = (x, y) :: ret
					}
				}
			}
			recur(cinit)
			ret
		}
		
		def all(target: List[(Set[PI], Set[PI])]) = {
			var ret = Nil:List[Align]
			for ((ts, hs) <- target; start <- ts; c <- hs; if start.roughMatch(c)) {
				for ((clue, hstart) <- findClues(start, c.paths.head)) {
					ret = findAligns(start, clue, hstart, ret)
				}
			}
			ret
		}
	}
}
