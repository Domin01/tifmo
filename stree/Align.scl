package tifmo

import knowledge.SemRole.SemRole
import inference.Slction
import scala.collection.mutable

package stree {
	
	class Align(val tp: Path, val hp: Path, val clue: Path, val soft: Boolean) extends Serializable {
		
		private[this] var confi = 0.0
		private[this] var cat = null:String
		private[stree] def assign(c: Double, t: String) {
			confi = c
			cat = t
		}
		def confidence = confi
		def category = cat
		
		def piPair = {
			
			val tpi = mutable.Set.empty[PI]
			val tsl = mutable.Set.empty[Item]
			val tdi = mutable.Set.empty[Item]
			val tdu = mutable.Set.empty[Item]
			val tde = mutable.Set.empty[Item]
			def extract(acctm: Term, srctm: Term, supps: List[PI]) {
				srctm match {
					case WORD(word) => {}
					case IR(core, sats) => acctm match {
						case IR(acore, asats) => {
							assert(asats.size <= 1)
							if (!asats.isEmpty) {
								val pp = (asats.head._1, supps.head)
								assert(sats.contains(pp))
								for ((r, y) <- (sats - pp)) {
									y match {
										case pi @ PI(tm, rr) => tpi.add(pi)
										case SL(itm, sel) => tsl.add(y)
									}
								}
								if (!supps.tail.isEmpty || !soft) {
									extract(asats.head._2.term, supps.head.term, supps.tail)
								}
							} else {
								for ((r, y) <- sats) {
									y match {
										case pi @ PI(tm, rr) => tpi.add(pi)
										case SL(itm, sel) => tsl.add(y)
									}
								}
							}
							extract(acore, core, supps)
						}
						case _ => throw new Exception("weird path IR in extract!")
					}
					case PO(tm, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							extract(atm, tm, supps)
						}
						case _ => throw new Exception("weird path PO in extract!")
					}
					case DI(tm, arg, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							tdi.add(arg)
							extract(atm, tm, supps)
						}
						case _ => throw new Exception("weird path DI in extract!")
					}
					case DU(tm, arg, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							tdu.add(arg)
							extract(atm, tm, supps)
						}
						case _ => throw new Exception("weird path DU in extract!")
					}
					case DE(tm, arg, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							tde.add(arg)
							extract(atm, tm, supps)
						}
						case _ => throw new Exception("weird path DE in extract!")
					}
				}
			}
			if (!tp.src.tail.isEmpty || !soft) {
				extract(tp.acc.term, tp.src.head.term, tp.src.tail)
			}
			
			def construct(acctm: Term, srctm: Term, supps: List[PI]): Term = {
				srctm match {
					case WORD(word) => {
						assert(acctm == srctm)
						WORD(word)
					}
					case IR(core, sats) => acctm match {
						case IR(acore, asats) => {
							assert(asats.size <= 1)
							val nsats = if (!asats.isEmpty) {
								val pp = (asats.head._1, supps.head)
								assert(sats.contains(pp))
								val pren = (sats - pp).flatMap((x:(SemRole, Item)) => x._2 match {
									case pi @ PI(tm, rr) => {
										for (y <- tpi; if y.veryRoughMatch(pi)) yield ((x._1, (y:Item)))
										//tpi.filter(_.veryRoughMatch(pi)).map((x._1, _))
									}
									case SL(itm, sel) => {
										for (y <- tsl; if y.ietmref.to.hasSuper(x._2.ietmref.to)) yield ((x._1, (y:Item)))
										//tsl.filter(_.ietmref.to.hasSuper(x._2.ietmref.to)).map((x._1, _))
									}
								})
								pren + (if (soft && supps.tail.isEmpty) {
									(pp._1, tp.src.last)
								} else {
									assert(asats.head._2.intoR == supps.head.intoR)
									val tm = construct(asats.head._2.term, supps.head.term, supps.tail)
									(pp._1, PI(tm, supps.head.intoR))
								})
							} else {
								sats.flatMap((x:(SemRole, Item)) => x._2 match {
									case pi @ PI(tm, rr) => {
										for (y <- tpi; if y.veryRoughMatch(pi)) yield ((x._1, (y:Item)))
										//tpi.filter(_.veryRoughMatch(pi)).map((x._1, _))
									}
									case SL(itm, sel) => {
										for (y <- tsl; if y.ietmref.to.hasSuper(x._2.ietmref.to)) yield ((x._1, (y:Item)))
										//tsl.filter(_.ietmref.to.hasSuper(x._2.ietmref.to)).map((x._1, _))
									}
								})
							}
							val ncore = construct(acore, core, supps)
							IR(ncore, nsats)
						}
						case _ => throw new Exception("weird path IR in construct!")
					}
					case PO(tm, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							PO(construct(atm, tm, supps), r)
						}
						case _ => throw new Exception("weird path PO in construct!")
					}
					case DI(tm, arg, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							val narg = {
								val fil = tdi.filter(_.ietmref.to.hasSub(arg.ietmref.to))
								if (fil.isEmpty) {
									val defil = tde.filter(_.ietmref.to.hasSub(arg.ietmref.to))
									if (defil.size == 1) {
										defil.head
									} else {
										null
									}
								} else if (fil.size == 1) {
									fil.head
								} else {
									null
								}
							}
							if (narg != null) {
								DI(construct(atm, tm, supps), narg, r)
							} else {
								PO(construct(atm, tm, supps), r)
							}
						}
						case _ => throw new Exception("weird path DI in construct!")
					}
					case DU(tm, arg, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							val narg = {
								val fil = tdu.filter(_.ietmref.to.hasSub(arg.ietmref.to))
								if (fil.size == 1) {
									fil.head
								} else {
									null
								}
							}
							if (narg != null) {
								DU(construct(atm, tm, supps), narg, r)
							} else {
								PO(construct(atm, tm, supps), r)
							}
						}
						case _ => throw new Exception("weird path DU in construct!")
					}
					case DE(tm, arg, r) => acctm match {
						case PO(atm, ar) => {
							assert(r == ar)
							if (!tde.filter(_.ietmref.to == arg.ietmref.to).isEmpty) {
								DE(construct(atm, tm, supps), arg, r)
							} else {
								PO(construct(atm, tm, supps), r)
							}
						}
						case _ => throw new Exception("weird path DE in construct!")
					}
				}
			}
			assert(hp.acc.intoR == hp.src.head.intoR)
			val hpi = PI(construct(hp.acc.term, hp.src.head.term, hp.src.tail), hp.acc.intoR)
			(tp.src.head, hpi)
		}
		
		override def toString = "by " + clue + " (" + tp + ") implies (" + hp + ")" + (if (soft) "" else "[hard]")
	}
	
	object Align {
		
		private[this] def getPartsLower(x: PI, subs: mutable.Set[PI], sls: mutable.Set[Item], diargs: mutable.Set[Item], duargs: mutable.Set[Item], deargs: mutable.Set[Item]) {
			subs.add(x)
			val cache = mutable.Set.empty[Term]
			def recur(t: Term) {
				if (cache.add(t)) {
					t match {
						case WORD(word) => {}
						case IR(core, sats) => {
							for ((r, y) <- sats) {
								y match {
									case pi @ PI(tm, rr) => {
										subs.add(pi)
										recur(pi.term)
									}
									case SL(itm, sel) => {
										sls.add(y)
										def tmpfunc(z: Item): PI = z match {
											case zpi @ PI(ztm, zrr) => zpi
											case SL(zitm, zsel) => tmpfunc(zitm)
										}
										val pi = tmpfunc(y)
										subs.add(pi)
										recur(pi.term)
									}
								}
							}
							recur(core)
						}
						case PO(tm, r) => {
							recur(tm)
						}
						case DI(tm, arg, r) => {
							diargs.add(arg)
							recur(tm)
						}
						case DU(tm, arg, r) => {
							duargs.add(arg)
							recur(tm)
						}
						case DE(tm, arg, r) => {
							deargs.add(arg)
							recur(tm)
						}
					}
				}
			}
			recur(x.term)
		}
		
		private[this] def getPartsUpper(x: PI, subs: mutable.Set[PI], sls: mutable.Set[Item], diargs: mutable.Set[Item], duargs: mutable.Set[Item], deargs: mutable.Set[Item]) {
			subs.add(x)
			val cache = mutable.Set.empty[Term]
			def recur(t: Term) {
				if (cache.add(t)) {
					t match {
						case WORD(word) => {}
						case IR(core, sats) => {
							for ((r, y) <- sats) {
								y match {
									case pi @ PI(tm, rr) => {
										subs.add(pi)
										recur(pi.term)
									}
									case SL(itm, sel) => {
										sls.add(y)
									}
								}
							}
							recur(core)
						}
						case PO(tm, r) => {
							recur(tm)
						}
						case DI(tm, arg, r) => {
							diargs.add(arg)
							recur(tm)
						}
						case DU(tm, arg, r) => {
							duargs.add(arg)
							recur(tm)
						}
						case DE(tm, arg, r) => {
							deargs.add(arg)
							recur(tm)
						}
					}
				}
			}
			recur(x.term)
		}
		
		private[this] def sepSL(lower: Iterable[Item], upper: Iterable[Item]): List[(Set[PI], Set[PI])] = {
			
			def proc(item: Item, pipool: mutable.Set[PI], slmap: mutable.Map[Slction, Set[Item]]) {
				item match {
					case pi @ PI(tm, r) => pipool.add(pi)
					case SL(itm, sel) => for (slct <- sel) {
						slmap(slct) = slmap.getOrElse(slct, Set.empty[Item]) + itm
					}
				}
			}
			val (lpi, upi) = (mutable.Set.empty[PI], mutable.Set.empty[PI])
			val (lsl, usl) = (mutable.Map.empty[Slction, Set[Item]], mutable.Map.empty[Slction, Set[Item]])
			lower.foreach(proc(_, lpi, lsl))
			upper.foreach(proc(_, upi, usl))
			
			var tmp = Nil:List[(Set[Item], Set[Item])]
			for (slct <- (lsl.keySet intersect usl.keySet)) {
				if (slct.isInstanceOf[SelNum]) {
					tmp = (lsl(slct), usl(slct)) :: tmp
				} else if (slct.isInstanceOf[SelSup]) {
					tmp = (usl(slct), lsl(slct)) :: tmp
				} else {
					throw new Exception("wrong slct??")
				}
			}
			
			val preret = tmp.flatMap(x => sepSL(x._1, x._2))
			if (!lpi.isEmpty && !upi.isEmpty) {
				(lpi.toSet, upi.toSet) :: preret
			} else {
				preret
			}
		}
		
		private[this] def targetItem(lower: Iterable[Item], upper: Iterable[Item], fund: List[(Set[PI], Set[PI])]): List[(Set[PI], Set[PI])] = {
			
			var ret = fund
			for ((l, u) <- sepSL(lower, upper)) {
				
				val (lsubs, lsls, ldiargs, lduargs, ldeargs) = (mutable.Set.empty[PI], mutable.Set.empty[Item], mutable.Set.empty[Item], mutable.Set.empty[Item], mutable.Set.empty[Item])
				l.foreach(getPartsLower(_, lsubs, lsls, ldiargs, lduargs, ldeargs))
				
				val (usubs, usls, udiargs, uduargs, udeargs) = (mutable.Set.empty[PI], mutable.Set.empty[Item], mutable.Set.empty[Item], mutable.Set.empty[Item], mutable.Set.empty[Item])
				u.foreach(getPartsUpper(_, usubs, usls, udiargs, uduargs, udeargs))
				
				ret = targetItem(udeargs, ldeargs, ret)
				ret = targetItem(ldeargs, udeargs, ret)
				ret = targetItem(uduargs, lduargs, ret)
				ret = targetItem(udiargs, ldiargs ++ ldeargs, ret)
				ret = targetItem(lsls, usls, ret)
				ret = (lsubs.toSet, usubs.toSet) :: ret
			}
			
			ret
		}
		
		def genTarget(pre: List[AtomSt], aim: List[AtomSt]) = {
			
			val (neT, neH) = (mutable.Set.empty[Item], mutable.Set.empty[Item])
			val (subLower, subUpper) = (mutable.Set.empty[Item], mutable.Set.empty[Item])
			val (djtLower, djtUpper) = (mutable.Set.empty[Item], mutable.Set.empty[Item])
			def sepPrem(st: AtomSt) {
				st match {
					case NonEmpty(a) => neT.add(a)
					case Subsume(a, b) => {
						subUpper.add(a)
						subLower.add(b)
					}
					case Disjoint(a, b) => {
						djtUpper.add(a)
						djtUpper.add(b)
					}
				}
			}
			pre.foreach(sepPrem(_))
			def sepHypo(st: AtomSt) {
				st match {
					case NonEmpty(a) => neH.add(a)
					case Subsume(a, b) => {
						subLower.add(a)
						subUpper.add(b)
					}
					case Disjoint(a, b) => {
						djtLower.add(a)
						djtLower.add(b)
					}
				}
			}
			aim.foreach(sepHypo(_))
			
			targetItem(neT, neH, targetItem(subLower, subUpper, targetItem(djtLower, djtUpper, Nil)))
		}
		
		
		private[this] def findAligns(start: PI, clue: Path, hstart: Path, fund: List[Align]) = {
			/*
			def hasChildren(x: Term): Boolean = x match {
				case WORD(word) => false
				case DI(tm, arg, r) => true
				case DU(tm, arg, r) => true
				case DE(tm, arg, r) => true
				case IR(core, sats) => !sats.isEmpty || hasChildren(core)
				case PO(tm, r) => hasChildren(tm)
				case SL(tm, sel) => hasChildren(tm)
			}*/
			
			var als = fund
			
			def loopHypo(tp: Path, hp: Path, avoid: Set[Path], ret: List[Path]): List[Path] = {
				if (avoid.contains(hp) || hp.collidWord) {
					ret
				} else {
					if (!hp.src.last.term.word.isStopwd && hp.src.last.roughMatch(tp.src.last)) {
						als = new Align(tp, hp, clue, true) :: als
						hp :: ret
					} else {
						if (tp.src.last.paths.length == 1 && hp.src.last.paths.length == 1) {
							als = new Align(tp, hp, clue, false) :: als
						}
						(ret /: hp.longer)((x, y) => loopHypo(tp, y, avoid, x))
					}
				}
			}
			
			def loopText(tp: Path, avoid: Set[Path]) {
				for (x <- tp.longer; if !x.collidWord && !clue.src.exists(_.roughMatch(x.src.last))) {
					//if (!clue.src.exists(x.src.last.roughMatch(_))) {
					loopText(x, avoid ++ loopHypo(x, hstart, avoid, Nil))
					//}
				}
			}
			
			loopText(start.paths.head, Set.empty[Path])
			als
		}
		
		private[this] def findClues(start: PI, cinit: Path) = {
			var ret = Nil:List[(Path, Path)]
			def recur(x: Path) {
				for (y <- x.longer; if !y.collidWord) {
					if (start.ietmref.to.hasSuper(y.acc.ietmref.to)) {
						recur(y)
					} else {
						ret = (x, y) :: ret
					}
				}
			}
			recur(cinit)
			ret
		}
		
		def all(target: List[(Set[PI], Set[PI])]) = {
			var ret = Nil:List[Align]
			for ((ts, hs) <- target; start <- ts; c <- hs; if !start.term.word.isStopwd && !c.term.word.isStopwd && c.roughMatch(start)) {
				
				for ((clue, hstart) <- findClues(start, c.paths.head)) {
					ret = findAligns(start, clue, hstart, ret)
				}
			}
			ret
		}
		
		private[this] def findPreClues(start: PI, cinit: Path) = {
			var ret = Nil:List[Path]
			def recur(x: Path) {
				if (x.src.last.paths.length == 1) {
					ret = x :: ret
				} else {
					for (y <- x.longer; if !y.collidWord && start.ietmref.to.hasSuper(y.acc.ietmref.to)) {
						recur(y)
					}
				}
			}
			recur(cinit)
			ret
		}
		
		private[this] def findPreAligns(start: PI, clue: Path, fund: List[Align]) = {
			
			var als = fund
			
			var flag = false
			def loopText(tp: Path) {
				if (tp.src.last.paths.length == 1) {
					als = new Align(tp, clue, clue, false) :: als
				} else {
					var tmp = tp.longer
					while (!tmp.isEmpty && !flag) {
						if (clue.src.exists(_.roughMatch(tmp.head.src.last))) {
							flag = true
						} else {
							loopText(tmp.head)
						}
						tmp = tmp.tail
					}
				}
			}
			loopText(start.paths.head)
			
			if (flag) fund else als
		}
		
		def pre(target: List[(Set[PI], Set[PI])]) = {
			var ret = Nil:List[Align]
			for ((ts, hs) <- target; start <- ts; c <- hs; if !start.term.word.isStopwd && !c.term.word.isStopwd && c.roughMatch(start)) {
				for (clue <- findPreClues(start, c.paths.head)) {
					var flag = false
					ret = findPreAligns(start, clue, ret)
				}
			}
			ret
		}
		
	}
}
