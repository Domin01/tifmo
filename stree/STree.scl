package tifmo

import knowledge.SemRole.SemRole
import scala.collection.mutable

package stree {
	
	class STree(pnl: List[PreNode]) extends Serializable {
		
		val streeNodeList = for (pn <- pnl) yield {
			val ret = new STreeNode(pn.word, pn.coref, pn.outr, pn.qtfier, pn.sel, pn.rootNeg, pn.updateCoref, 
				pn.sortedChildren.toList.map(x => (x._1, x._2.correspondingSTreeNode)))
			pn.correspondingSTreeNode = ret
			ret.children.foreach(_._2.parent = ret)
			ret
		}
		
		private[this] def getcid(coref: String) = coref.split("&")(0)
		
		def demandRoles(setLexRoles: (String, Set[SemRole]) => Unit) {
			val corefRoles = mutable.Map.empty[String, Set[SemRole]]
			for (n <- streeNodeList) {
				setLexRoles(n.word.lex, n.execorder.toSet)
				if (n.coref != null) {
					corefRoles(getcid(n.coref)) = corefRoles.getOrElse(getcid(n.coref), Set.empty[SemRole]) ++ n.execorder
				}
			}
			for (n <- streeNodeList; if n.coref != null) {
				setLexRoles(n.word.lex, corefRoles(getcid(n.coref)))
			}
		}
		
		def meaning(getLexRoles: String => Set[SemRole]) = {
			var ret = Nil:List[AtomSt]
			
			val corefPre = mutable.Map.empty[String, Set[IR]]
			val corefCur = mutable.Map.empty[String, Set[IR]]
			
			def anaph(coref: String) = {
				if (coref == null) {
					Set.empty[IR]
				} else {
					corefCur.getOrElseUpdate(coref, {
						val cid = getcid(coref)
						if (corefPre.contains(cid)) corefPre(cid) else Set.empty[IR]
					})
				}
			}
			def anaphSet(coref: String, r: SemRole, a: PI) {
				if (coref != null && r != null && a != null) {
					corefCur(coref) = corefCur(coref).map(x => IR(x.core, x.sats.filter(_._1 != r) + ((r, a))))
				}
			}
			def anaphUpdate() {
				for (cid <- corefCur.keySet.map(getcid(_))) {
					corefPre(cid) = Set.empty[IR]
				}
				for ((k, v) <- corefCur; cid = getcid(k)) {
					corefPre(cid) = corefPre(cid) ++ v
				}
				corefCur.clear()
			}
			
			for (n <- streeNodeList) {
				
				if (n.parent == null && n.rootNeg) {
					
					n.rootNegation(getLexRoles(n.word.lex))
					ret = n.atomst ::: ret
					
				} else {
					
					n.approximation(anaph(n.coref))
					n.halfExecution(getLexRoles(n.word.lex))
					
					def recur(x: STreeNode) {
						x.refinement()
						anaphSet(x.coref, x.outRole, x.refPI)
						for ((r, c) <- x.children; if c.qtfier == null) {
							recur(c)
						}
					}
					
					if (n.parent == null) {
						recur(n)
						if (n.updateCoref) anaphUpdate()
						def state(x: STreeNode) {
							x.fullExecution()
							ret = x.atomst ::: ret
							for ((r, c) <- x.children; if c.qtfier == null) {
								state(c)
							}
						}
						state(n)
					} else if (n.qtfier != null) {
						recur(n)
					}
				}
			}
			
			ret
		}
		
		def nonTrivialProps = {
			var ret = Nil:List[AtomSt]
			for (n <- streeNodeList; if n.parent == null) {
				if (n.rootNeg) {
					
					ret = n.atomst.last :: ret
					
				} else {
				
					def recur(x: STreeNode) {
						if (x.nontrivial) {
							x.fullexec match {
								case PO(tm, r) => ret = x.atomst.last :: ret
								case _ => ret = x.atomst ::: ret
							}
						}
						for ((r, c) <- x.children; if c.qtfier == null) {
							recur(c)
						}
					}
					recur(n)
					
				}
			}
			ret
		}
		
		def rolePartial = {
			var ret = Nil:List[(NonEmpty, Int)]
			for (n <- streeNodeList; if n.parent == null) {
				
				if (n.rootNeg) {
					
					// do nothing
					
				} else {
				
					def parpart(x: STreeNode, r: SemRole) {
						
						def pifollow(x: STreeNode): (Int, PI) = {
							for (rr <- x.execorder; if rr != x.outRole) {
								parpart(x, rr)
							}
							var counter = if (x.word.isStopwd) 0 else 1
							for ((qrr, qc) <- x.children; if qc.qtfier != null && qrr == x.outRole) {
								def qcrecur(y: STreeNode) {
									if (!y.word.isStopwd) counter += y.execorder.length
									for ((ry, yc) <- y.children) {
										qcrecur(yc)
									}
								}
								qcrecur(qc)
							}
							val sats = (for ((rr, c) <- x.children; if c.qtfier == null && rr == x.outRole) yield {
								val (num, pi) = pifollow(c)
								counter += num
								(rr, (pi:Item))
							}).toSet
							(counter, PI(IR(WORD(x.word), sats), x.outRole))
						}
						
						var counter = if (x.word.isStopwd) 0 else 1
						for ((qrr, qc) <- x.children; if qc.qtfier != null && qrr == r) {
							def qcrecur(y: STreeNode) {
								if (!y.word.isStopwd) counter += y.execorder.length
								for ((ry, yc) <- y.children) {
									qcrecur(yc)
								}
							}
							qcrecur(qc)
						}
						val sats = (for ((rr, c) <- x.children; if c.qtfier == null && rr == r) yield {
							val (num, pi) = pifollow(c)
							counter += num
							(r, (pi:Item))
						}).toSet
						ret = (NonEmpty(PI(IR(WORD(x.word), sats), r)), counter) :: ret
					}
					n.execorder.foreach(parpart(n, _))
				
				}
			}
			ret
		}
		
		def pathPartial = {
			var ret = Nil:List[(AtomSt, Double)]
			for (n <- streeNodeList; if n.parent == null && !n.execorder.isEmpty) {
				
				if (n.rootNeg) {
					
					// do nothing
					
				} else {
					
					def recur(x: STreeNode) {
						val xw = {
							val qcs = x.children.filter(_._2.qtfier != null)
							var ret = if (x.word.isStopwd) 0.0 else (1.0 /: qcs)(_ + _._2.weight)
							def qcrecur(y: STreeNode) {
								if (!y.word.isStopwd) ret += y.weight
								for ((ry, yc) <- y.children) {
									qcrecur(yc)
								}
							}
							for ((qrr, qc) <- qcs) {
								qcrecur(qc)
							}
							ret
						}
						if (x.parent == null) {
							x.fullexec match {
								case PO(tm, r) => ret = (x.atomst.last, xw) :: ret
								case _ => {
									val tmpw = xw / x.atomst.length
									x.atomst.foreach(y => ret = (y, tmpw) :: ret)
								}
							}
						} else {
							ret = (NonEmpty(x.halfItem), xw) :: ret
						}
						val fil = x.children.filter(_._2.qtfier == null).toSet
						if (!x.word.isStopwd) {
							val lastr = x.execorder.last
							if (fil.size == 0) {
								// nothing to do
							} else if (fil.size == 1) {
								val ne = NonEmpty(PI(IR(WORD(x.word), fil.map(y => (y._1, y._2.halfItem))), lastr))
								val weight = fil.head._2.weight.toDouble
								ret = (ne, weight) :: ret
							} else {
								for (ctwo <- fil.subsets(2)) {
									val ne = NonEmpty(PI(IR(WORD(x.word), ctwo.map(y => (y._1, y._2.halfItem))), lastr))
									val weight = ((0.0 /: ctwo)(_ + _._2.weight)) / (fil.size - 1)
									ret = (ne, weight) :: ret
								}
							}
						}
						for ((r, c) <- fil) {
							recur(c)
						}
					}
					recur(n)
					
				}
			}
			ret
		}
		
		override def toString = streeNodeList.mkString("==== STree: ====\n", "\n", "\n----------------\n")
	}
	
	object STree {
		
		def roleWeight(nl: List[STreeNode]) = {
			var ret = 0
			for (n <- nl; if !n.word.isStopwd) {
				ret += n.execorder.length
			}
			ret
		}
		
		def pathWeight(nl: List[STreeNode]) = {
			var ret = 0
			for (n <- nl; if !n.word.isStopwd) {
				def loop(x: STreeNode) {
					if (!x.word.isStopwd) ret += 1
					if (x.parent != null) loop(x.parent)
				}
				if (!n.execorder.isEmpty) {
					loop(n)
				}
			}
			ret
		}
		
	}
}
