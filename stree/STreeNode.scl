package tifmo

import knowledge.SemRole.SemRole
import knowledge.WordInfo
import stree.Qtfier.Qtfier
import inference.Slction
import scala.util.Sorting

package stree {
	
	class STreeNode(
		val word: WordInfo,
		val coref: String,
		val outRole: SemRole,
		val qtfier: Qtfier,
		val slction: Slction,
		val children: List[(SemRole, STreeNode)]
	) extends Serializable {
		val weight: Int = ((if (word.isStopwd) 0 else 1) /: children)(_ + _._2.weight)
		
		private[this] var prt = null:STreeNode
		private[stree] def parent_=(x: STreeNode) {
			assert(x != null)
			assert(prt == null)
			prt = x
		}
		def parent = prt
		
		val execorder = {
			val roles = (children.map(_._1).toSet + outRole) - null
			
			def orderfunc(r: SemRole) = if (r == outRole) {
				children.lastIndexWhere(x => x._1 != outRole && x._2.qtfier != null).toDouble + 0.5
			} else {
				children.lastIndexWhere(_._1 == r).toDouble
			}
			
			Sorting.stableSort[SemRole, Double](roles.toList, orderfunc(_)).toList
		}
		val gathered = execorder.map(r => {
			val fil = children.filter(y => y._1 == r && y._2.qtfier != null)
			if (fil.isEmpty) {
				(r, null)
			} else {
				assert(fil.size == 1)
				(r, fil.head._2)
			}
		}).toMap
		
		def execute(a: Term, r: SemRole) = {
			if (gathered(r) == null || gathered(r).halfexecPI == null) {
				PO(a, r)
			} else {
				gathered(r).qtfier match {
					case Qtfier.ALL => {
						DI(a, gathered(r).halfexecPI, r)
					}
					case Qtfier.EXACTLY => {
						DE(a, gathered(r).halfexecPI, r)
					}
					case Qtfier.NO => {
						DU(a, gathered(r).halfexecPI, r)
					}
				}
			}
		}
		
		@transient private[this] var aprx = null:IR
		def approx = aprx
		def approximation(anaph: Set[PI]) {
			val core = WORD(word)
			val presats = (for ((r, c) <- children; if c.qtfier == null) yield ((r, c.halfexecPI))).toSet
			val sats = if (outRole != null) {
				presats ++ anaph.map((outRole, _))
			} else if (!execorder.isEmpty) {
				presats ++ anaph.map((execorder.last, _))
			} else {
				presats
			}
			aprx = IR(core, sats)
		}
		
		@transient private[this] var slct = null:Term
		def select = slct
		def selection() {
			slct = if (slction == null) approx else SL(approx, slction)
		}
		
		@transient private[this] var hfex = null:Term
		def halfexec = hfex
		@transient private[this] var hfexPI = null:PI
		def halfexecPI = hfexPI
		@transient private[this] var addRoles = null:List[SemRole]
		def halfExecution(roles: Set[SemRole]) {
			if (roles != null) {
				assert(execorder.forall(roles.contains(_)))
				addRoles = (roles -- execorder).toList
			}
			val tmp = (select /: addRoles)((a, r) => {
				PO(a, r)
			})
			val toexec = execorder.takeWhile(_ != outRole)
			hfex = (tmp /: toexec)((a, r) => {
				execute(a, r)
			})
			if (outRole != null) hfexPI = new PI(hfex, outRole)
		}
		
		
		@transient lazy val refRole = {
			if (parent == null) {
				null
			} else {
				parent.children.find(_._2 == this) match {
					case Some((r, x)) => r
					case None => throw new Exception("error tree!")
				}
			}
		}
		
		@transient lazy val refPI = {
			if (parent == null || qtfier != null) {
				null
			} else {
				new PI(parent.refine, refRole)
			}
		}
		
		@transient private[this] var rfne = null:IR
		def refine = rfne
		def refinement(anaph: Set[PI]) = {
			val or = if (outRole != null) {
				outRole
			} else if (!execorder.isEmpty) {
				execorder.last
			} else {
				null
			}
			if (or != null) {
				val tmp = if (refPI == null) approx.sats else approx.sats + ((or, refPI))
				val nsats = tmp ++ anaph.map((or, _))
				
				rfne = IR(approx.core, nsats)
				
				approximation(anaph)
				selection()
				halfExecution(null)
				
				new PI(refine, or)
			} else {
				null
			}
		}
		
		@transient private[this] var flex = null:Term
		def fullexec = flex
		@transient private[this] var ntrvl = false
		def nontrivial = ntrvl
		@transient private[this] var atst = null:List[AtomSt]
		def atomst = atst
		def fullExecution() = {
			
			val halfdash = if (parent == null || qtfier != null) {
				halfexec
			} else {
				IR(halfexec, Set((outRole, refPI)))
			}
			
			val toexec = execorder.dropWhile(_ != outRole)
			
			flex = (halfdash /: toexec)((a, r) => {
				execute(a, r)
			})
			
			ntrvl = (parent == null || toexec.exists(r => gathered(r) != null && gathered(r).halfexecPI != null))
			
			atst = fullexec match {
				case PO(tm, r) => {
					var ret = Nil:List[AtomSt]
					def recur(x: Term) {
						x match {
							case PO(tm, r) => {
								ret = NonEmpty(new PI(tm, r)) :: ret
								recur(tm)
							}
							case DI(tm, arg, r) => {
								ret = NonEmpty(new PI(tm, r)) :: ret
								recur(tm)
							}
							case DU(tm, arg, r) => {
								ret = NonEmpty(new PI(tm, r)) :: ret
								recur(tm)
							}
							case DE(tm, arg, r) => {
								ret = NonEmpty(new PI(tm, r)) :: ret
								recur(tm)
							}
							case _ => {}
						}
					}
					recur(fullexec)
					ret
				}
				case DI(tm, arg, r) => {
					Subsume(arg, new PI(tm, r)) :: Nil
				}
				case DU(tm, arg, r) => {
					Disjoint(arg, new PI(tm, r)) :: Nil
				}
				case DE(tm, arg, r) => {
					Subsume(arg, new PI(tm, r)) :: Subsume(new PI(tm, r), arg) :: Nil
				}
				case _ => Nil
			}
		}
		
		override def toString = (if (slction == null) "" else slction.toString) + "(" + word + (if (coref == null) "" else "@" + coref) + ")" + outRole + " <- " + (if (qtfier == null) "--" else qtfier.toString) + " -- " + refRole + "(" + (if (parent == null) "ROOT" else parent.word + (if (parent.coref == null) "" else "@" + parent.coref)) + ")"
	}
}
