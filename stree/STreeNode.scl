package tifmo

import knowledge.SemRole.SemRole
import knowledge.WordInfo
import stree.Qtfier.Qtfier
import inference.Slction
import scala.util.Sorting

package stree {
	
	class STreeNode(
		val word: WordInfo,
		val coref: String,
		val outRole: SemRole,
		val qtfier: Qtfier,
		val sel: Set[Slction],
		val rootNeg: Boolean,
		val updateCoref: Boolean,
		val children: List[(SemRole, STreeNode)]
	) extends Serializable {
		val weight: Int = ((if (word.isStopwd) 0 else 1) /: children)(_ + _._2.weight)
		
		private[this] var prt = null:STreeNode
		private[stree] def parent_=(x: STreeNode) {
			assert(x != null)
			assert(prt == null)
			prt = x
		}
		def parent = prt
		
		val execorder = {
			val roles = (children.map(_._1).toSet + outRole) - null
			
			def orderfunc(r: SemRole) = if (r == outRole) {
				children.lastIndexWhere(x => x._1 != outRole && x._2.qtfier != null).toDouble + 0.5
			} else {
				children.lastIndexWhere(_._1 == r).toDouble
			}
			
			Sorting.stableSort[SemRole, Double](roles.toList, orderfunc(_)).toList
		}
		val gathered = execorder.map(r => {
			val fil = children.filter(y => y._1 == r && y._2.qtfier != null)
			if (fil.isEmpty) {
				(r, null)
			} else {
				assert(fil.size == 1)
				(r, fil.head._2)
			}
		}).toMap
		
		def execute(a: Term, r: SemRole) = {
			if (gathered(r) == null || gathered(r).halfItem == null) {
				PO(a, r)
			} else {
				gathered(r).qtfier match {
					case Qtfier.ALL => {
						DI(a, gathered(r).halfItem, r)
					}
					case Qtfier.EXACTLY => {
						DE(a, gathered(r).halfItem, r)
					}
					case Qtfier.NO => {
						DU(a, gathered(r).halfItem, r)
					}
				}
			}
		}
		
		@transient private[this] var aprx = null:IR
		def approx = aprx
		def approximation(anaph: Set[IR]) {
			val core = WORD(word)
			val presats = (for ((r, c) <- children; if c.qtfier == null) yield ((r, c.halfItem))).toSet
			val sats = if (outRole != null) {
				presats ++ anaph.map(x => (outRole, PI(x, outRole)))
			} else {
				presats
			}
			aprx = IR(core, sats)
		}
		
		@transient private[this] var hfex = null:Term
		def halfexec = hfex
		@transient private[this] var hfit = null:Item
		def halfItem = hfit
		@transient private[this] var addRoles = null:List[SemRole]
		def halfExecution(roles: Set[SemRole]) {
			assert(execorder.forall(roles.contains(_)))
			addRoles = (roles -- execorder).toList
			val tmp = ((approx:Term) /: addRoles)((a, r) => {
				PO(a, r)
			})
			val toexec = execorder.takeWhile(_ != outRole)
			hfex = (tmp /: toexec)((a, r) => {
				execute(a, r)
			})
			if (outRole != null) {
				hfit = if (sel.isEmpty) {
					PI(hfex, outRole)
				} else {
					SL(PI(hfex, outRole), sel)
				}
			}
		}
		
		
		@transient lazy val refRole = {
			if (parent == null) {
				null
			} else {
				parent.children.find(_._2 == this) match {
					case Some((r, x)) => r
					case None => throw new Exception("error tree!")
				}
			}
		}
		
		@transient lazy val refPI = {
			if (parent == null || qtfier != null) {
				null
			} else {
				PI(parent.refine, refRole)
			}
		}
		
		@transient private[this] var rfne = null:IR
		def refine = rfne
		def refinement() {
			
			val core = WORD(word)
			val presats = (for ((r, c) <- children; if r != outRole && c.qtfier == null) yield ((r, c.halfItem))).toSet
			val sats = if (refPI != null) {
				presats + ((outRole, refPI))
			} else {
				presats
			}
			rfne = IR(core, sats)
		}
		
		@transient private[this] var flex = null:Term
		def fullexec = flex
		@transient private[this] var ntrvl = false
		def nontrivial = ntrvl
		@transient private[this] var atst = null:List[AtomSt]
		def atomst = atst
		def fullExecution() {
			
			val halfdash = if (parent == null || qtfier != null) {
				halfexec
			} else {
				IR(halfexec, Set((outRole, refPI)))
			}
			
			val toexec = execorder.dropWhile(_ != outRole)
			
			flex = (halfdash /: toexec)((a, r) => {
				execute(a, r)
			})
			
			ntrvl = (parent == null || toexec.exists(r => gathered(r) != null))
			
			atst = fullexec match {
				case PO(tm, r) => {
					var ret = Nil:List[AtomSt]
					def recur(x: Term) {
						x match {
							case PO(tm, r) => {
								ret = NonEmpty(PI(tm, r)) :: ret
								recur(tm)
							}
							case DI(tm, arg, r) => {
								ret = NonEmpty(PI(tm, r)) :: ret
								recur(tm)
							}
							case DU(tm, arg, r) => {
								ret = NonEmpty(PI(tm, r)) :: ret
								recur(tm)
							}
							case DE(tm, arg, r) => {
								ret = NonEmpty(PI(tm, r)) :: ret
								recur(tm)
							}
							case _ => {}
						}
					}
					recur(fullexec)
					ret
				}
				case DI(tm, arg, r) => {
					Subsume(arg, PI(tm, r)) :: Nil
				}
				case DU(tm, arg, r) => {
					Disjoint(arg, PI(tm, r)) :: Nil
				}
				case DE(tm, arg, r) => {
					Subsume(arg, PI(tm, r)) :: Subsume(PI(tm, r), arg) :: Nil
				}
				case _ => Nil
			}
		}
		
		def rootNegation(roles: Set[SemRole]) {
			
			val core = WORD(word)
			val sats = (for ((r, c) <- children; if c.qtfier == null) yield ((r, c.halfItem))).toSet
			aprx = IR(core, sats)
			
			assert(execorder.forall(roles.contains(_)))
			addRoles = (roles -- execorder).toList
			
			val tmp = ((approx:Term) /: addRoles)((a, r) => {
				PO(a, r)
			})
			flex = (tmp /: execorder)((a, r) => {
				execute(a, r)
			})
			
			atst = fullexec match {
				case PO(tm, r) => {
					var ret = Nil:List[AtomSt]
					def recur(x: Term) {
						x match {
							case PO(tm, r) => {
								ret = Disjoint(PI(tm, r), PI(tm, r)) :: ret
								recur(tm)
							}
							case _ => {}
						}
					}
					recur(fullexec)
					ret
				}
				case _ => throw new Exception("wrong root negation")
			}
		}
		
		override def toString = sel.mkString("", ",", "") + "(" + word + (if (coref == null) "" else "@" + coref) + ")" + outRole + " <- " + (if (qtfier == null) "--" else qtfier.toString) + " -- " + refRole + "(" + (if (parent == null) "ROOT" else parent.word + (if (parent.coref == null) "" else "@" + parent.coref)) + ")"
	}
}
