package tifmo

import inference.Slction
import inference.IETerm
import inference.IEngine
import inference.FuncArg
import inference.FAConversion
import inference.IEPredSubsume

package stree {
	
	class SelSup(private val sups: Set[String]) extends Slction with FAConversion {
		
		def applySL(h: IETerm, a: IETerm, ie: IEngine) {
				ie.claimSubsume(h, a)
				var task = Nil:List[() => Unit]
				for ((xh, xa) <- ie.selBy(this); if xa.hasSuper(a)) {
					task = (() => ie.claimSubsume(h, xh)) :: task
				}
				task.foreach(_())
				ie.foreachSuperset(a, List(this, h, ie), SelSup.rSLSup0)
		}
		
		override def equals(a: Any) = {
			if (a.isInstanceOf[SelSup]) {
				val that = a.asInstanceOf[SelSup]
				!(sups intersect that.sups).isEmpty
			} else {
				false
			}
		}
		override def hashCode = "SelSup".hashCode
		override def toString = "SelSup[" + sups.mkString("", ",", "") + "]"
	}
	
	object SelSup extends FAConversion {
		
		val rSLSup0 = (sub: IEPredSubsume, args: List[FuncArg]) => args match {
			case FuncArg(slct:Slction) :: FuncArg(h:IETerm) :: FuncArg(ie:IEngine) :: Nil => {
				val fd = ie.findSL(h.roles, Set((null:IETerm, sub.superset, slct)))
				if (fd != null) {
					ie.claimSubsume(fd, h)
				}
			}
			case _ => throw new Exception("rSLNum0 error!")
		}
		
	}
	
}
