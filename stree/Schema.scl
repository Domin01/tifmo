package tifmo

import knowledge.SemRole.SemRole
import scala.collection.mutable

package stree {
	
	class MNode(valid: PI => Boolean, val children: Set[(SemRole, MNode)]) {
		
		private[this] val mc = mutable.Set.empty[(SemRole, Item)]
		private def matched = mc.toSet
		
		private[this] val nc = mutable.Set.empty[(SemRole, Item)]
		private def nonmatch = nc.toSet
		
		private[this] var res = null:PI
		private[stree] def result = res
		
		private[this] var cur = null:PI
		def currentMatch = cur
		
		private[stree] def matching(x: PI): Boolean = {
			mc.clear()
			nc.clear()
			res = null
			cur = x
			valid(x) && {
				val tocheck = mutable.Set.empty[(SemRole, MNode)] ++ children
				def construct(y: Term): Term = {
					y match {
						case WORD(word) => WORD(word)
						case IR(core, sats) => {
							val msats = sats.flatMap(z => if (z._2.isInstanceOf[PI]) {
								val tmp = for ((r, m) <- children; if r == z._1 && m.matching(z._2.asInstanceOf[PI])) yield {
									tocheck.remove((r, m))
									(r, (m.result:Item))
								}
								if (tmp.isEmpty) nc.add(z) else mc.add(z)
								tmp
							} else {
								nc.add(z)
								Set.empty[(SemRole, Item)]
							})
							IR(construct(core), msats)
						}
						case PO(tm, r) => PO(construct(tm), r)
						case DI(tm, arg, r) => PO(construct(tm), r)
						case DU(tm, arg, r) => PO(construct(tm), r)
						case DE(tm, arg, r) => PO(construct(tm), r)
					}
				}
				res = PI(construct(x.term), x.intoR)
				tocheck.isEmpty
			}
		}
		
		private[stree] def matching(x: PI, bind: Set[(MNode, SemRole, MNode, SemRole)]): Boolean = {
			mc.clear()
			nc.clear()
			res = null
			valid(x) && {
				val tocheck = mutable.Set.empty[(SemRole, MNode)] ++ children
				def construct(y: Term): Term = {
					y match {
						case WORD(word) => WORD(word)
						case IR(core, sats) => {
							val msats = sats.filter(_._2.isInstanceOf[PI]).flatMap(z => {
								val tmp = for ((r, m) <- children; if r == z._1 && m.matching(z._2.asInstanceOf[PI], bind)) yield {
									tocheck.remove((r, m))
									(r, (m.result:Item))
								}
								if (tmp.isEmpty) {
									val bfil = bind.filter(w => w._3 == this && w._4 == z._1)
									bfil.flatMap(w => {
										w._1.nonmatch.filter(_._1 == w._2).map(v => (z._1, v._2))
									})
								} else {
									tmp
								}
							})
							IR(construct(core), msats)
						}
						case PO(tm, r) => PO(construct(tm), r)
						case DI(tm, arg, r) => PO(construct(tm), r)
						case DU(tm, arg, r) => PO(construct(tm), r)
						case DE(tm, arg, r) => PO(construct(tm), r)
					}
				}
				res = PI(construct(x.term), x.intoR)
				tocheck.isEmpty
			}
		}
		
	}
	
	class Schema(lm: MNode, um: MNode, bind: Set[(MNode, SemRole, MNode, SemRole)]) {
		/*
		def prePair(x: PI, y: PI) = {
			if (lm.matching(x) && um.matching(y)) {
				Some((lm.result, um.result))
			} else {
				None
			}
		}*/
		
		def fullPair(x: PI, y: PI) = {
			if (lm.matching(x) && um.matching(y, bind)) {
				Some((x, um.result))
			} else {
				None
			}
		}
		
	}
}
