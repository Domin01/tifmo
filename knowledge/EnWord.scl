package tifmo

import knowledge.SemRole.SemRole
import resource.EnStopWords
import resource.EnDownward
import resource.EnWordNet
import resource.EnWordNet.SemEntry
import resource.EnWordNet.WordNetPointer._
import resource.EnPolarity
import stree.STree
import stree.PI
import stree.MNode
import stree.Schema
import mylib.longestCommSeq

package knowledge {
	
	class EnDoc(val raw: String) extends Serializable {
		var waa = null:Array[Array[EnWord]]
		var stree = null:STree
	}
	
	class EnWord(val doc: EnDoc, val sidx: Int, val idx: Int, val surf: String, val pos: String, 
		val ner: String, val lem: String, val cid: String, val sign: Boolean) extends WordInfo {
		
		def getContext(offsetL: Int, offsetR: Int) = {
			val sent = doc.waa(sidx)
			val from = (idx - offsetL) max 0
			val until = (idx + offsetR) min sent.length
			sent.slice(from, until)
		}
		
		def reverse() = {
			new EnWord(doc, sidx, idx, surf, pos, ner, lem, cid, !sign)
		}
		
		val mypos = if (ner == "DATE" || ner == "TIME") {
			"D"
		} else if (pos.length < 2) {
			"O"
		} else pos.substring(0, 2) match {
			case "JJ" => "J"
			case "NN" => "N"
			case "RB" => "R"
			case "VB" => "V"
			case _ => "O"
		}
		
		val lex = lem + "/" + mypos
		
		private[this] def compDate(x: String, y: String) = {
			x.length == y.length && (0 until x.length).forall(i => y.charAt(i) == 'X' || x.charAt(i) == y.charAt(i))
		}
		val isStopwd = if (pos == "JJS") {
			true
		} else if (ner != "O") {
			false
		} else {
			EnStopWords.isStopWord(lem)
		}
		
		override val hashCode = (doc, sidx, idx, lex, sign).hashCode
		override def equals(a: Any) = {
			if (a.isInstanceOf[EnWord]) {
				val that = a.asInstanceOf[EnWord]
				doc == that.doc && sidx == that.sidx && idx == that.idx && lex == that.lex && sign == that.sign
			} else {
				false
			}
		}
		
		@transient lazy val syns = if (ner != "O" || EnStopWords.isStopWord(lem)) Set.empty[SemEntry] else {
			val tmp = EnWordNet.synsets(lem, mypos)
			if (mypos == "R") tmp ++ EnWordNet.lexical(tmp, DERIVED_FROM_ADJ) else tmp
		}
		
		@transient lazy val lemmas = EnWordNet.getLemmas(syns) + lem.toLowerCase
		
		@transient lazy val ants = EnWordNet.lexical(syns, ANTONYM)
		
		
		@transient lazy val hypers = EnWordNet.semantic(syns, HYPERNYM)
		
		@transient lazy val hyper_insts = EnWordNet.semantic(syns, HYPERNYM_INSTANCE)
		
		@transient lazy val holo_mems = EnWordNet.semantic(syns, HOLONYM_MEMBER)
		
		@transient lazy val holo_parts = EnWordNet.semantic(syns, HOLONYM_PART)
		
		@transient lazy val holo_substs = EnWordNet.semantic(syns, HOLONYM_SUBSTANCE)
		
		@transient lazy val hyperall = syns ++ hypers ++ hyper_insts ++ holo_mems ++ holo_parts ++ holo_substs
		
		
		@transient lazy val hypos = EnWordNet.semantic(syns, HYPONYM)
		
		@transient lazy val hypo_insts = EnWordNet.semantic(syns, HYPONYM_INSTANCE)
		
		@transient lazy val mero_mems = EnWordNet.semantic(syns, MERONYM_MEMBER)
		
		@transient lazy val mero_parts = EnWordNet.semantic(syns, MERONYM_PART)
		
		@transient lazy val mero_substs = EnWordNet.semantic(syns, MERONYM_SUBSTANCE)
		
		@transient lazy val hypoall = syns ++ hypos ++ hypo_insts ++ mero_mems ++ mero_parts ++ mero_substs
		
		
		@transient lazy val ents = EnWordNet.semantic(syns, ENTAILMENT)
		
		
		@transient lazy val hyperhyper_insts = EnWordNet.semantic(hyper_insts, HYPERNYM) ++ hyper_insts
		
		
		@transient lazy val attrs = EnWordNet.semantic(syns, ATTRIBUTE)
		
		@transient lazy val deriv_rels = EnWordNet.lexical(syns, DERIVATIONALLY_RELATED)
		
		@transient lazy val perts = EnWordNet.lexical(syns, PERTAINYM)
		
		
		def synonymTo(that: EnWord, roughly: Boolean = false) = {
			if (mypos == "D") {
				that.mypos == "D" && (roughly || sign == that.sign) && lem == that.lem
			} else {
				if (roughly) {
					lex == that.lex || longestCommSeq.rate(lem.toLowerCase, that.lem.toLowerCase) > 0.9 || !(syns intersect that.syns).isEmpty || !(syns intersect that.ants).isEmpty || !(ants intersect that.syns).isEmpty || !(deriv_rels intersect that.syns).isEmpty || !(that.deriv_rels intersect syns).isEmpty
				} else if (sign == that.sign) {
					lex == that.lex || (mypos == that.mypos && longestCommSeq.rate(lem.toLowerCase, that.lem.toLowerCase) > 0.9) || !(syns intersect that.syns).isEmpty
				} else {
					!(syns intersect that.ants).isEmpty || !(ants intersect that.syns).isEmpty
				}
			}
		}
		
		def hyponymOf(that: EnWord) = sign == that.sign && {
			if (mypos == "D") {
				that.mypos == "D" && {
						if (sign) compDate(lem, that.lem) else compDate(that.lem, lem)
					}
			} else mypos == "N" && that.mypos == "N" && {
				if (sign) {
					/*
					!(hypers intersect that.hypos).isEmpty || 
						!(hyper_insts intersect that.hypo_insts).isEmpty || 
						!(holo_mems intersect that.mero_mems).isEmpty || 
						!(holo_parts intersect that.mero_parts).isEmpty || 
						!(holo_substs intersect that.mero_substs).isEmpty || 
						!(ents intersect that.syns).isEmpty
					*/
					!(hyperall intersect that.hypoall).isEmpty || !(ents intersect that.syns).isEmpty
				} else {
					/*
					!(that.hypers intersect hypos).isEmpty || 
						!(that.hyper_insts intersect hypo_insts).isEmpty || 
						!(that.holo_mems intersect mero_mems).isEmpty || 
						!(that.holo_parts intersect mero_parts).isEmpty || 
						!(that.holo_substs intersect mero_substs).isEmpty || 
						!(that.ents intersect syns).isEmpty
					*/
					!(that.hyperall intersect hypoall).isEmpty || !(that.ents intersect syns).isEmpty
				}
			}
		}
		
		def antonymTo(that: EnWord) = {
			sign && that.sign && {
				!(syns intersect that.ants).isEmpty || !(ants intersect that.syns).isEmpty || ((syns intersect that.syns).isEmpty && !(hyperhyper_insts intersect that.hyperhyper_insts).isEmpty)
			}
		}
		
		def samePolarity(y: EnWord) = {
			if (sign == y.sign) {
				//lemmas.exists(a => y.lemmas.exists(b => EnPolarity.samePole(a, b)))
				!(syns intersect y.syns).isEmpty || !(deriv_rels intersect y.syns).isEmpty || !(y.deriv_rels intersect syns).isEmpty || EnPolarity.samePole(lem, y.lem)
			} else {
				//lemmas.exists(a => y.lemmas.exists(b => EnPolarity.diffPole(a, b)))
				 !(syns intersect y.ants).isEmpty || !(ants intersect y.syns).isEmpty || EnPolarity.diffPole(lem, y.lem)
			}
		}
		
		def hasPolarity = {
			//lemmas.exists(a => EnPolarity.positiv.contains(a) || EnPolarity.negativ.contains(a))
			EnPolarity.positiv.contains(lem) || EnPolarity.negativ.contains(lem)
		}
		
		def isNegWord = {
			if (mypos == "V") EnDownward.isNegWord(lem, "V") else lemmas.exists(EnDownward.isNegWord(_, mypos))
		}
		
		def morphosem(that: EnWord) = {
			
			var ret = Nil:List[Schema]
			/*
			def attrSchemas(adj: EnWord, noun: EnWord) = {
				def func1(r1: SemRole, r2: SemRole) {
					val ynode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) || xword.samePolarity(adj)
					}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(noun) && x.intoR == r1
					}, Set((r2, ynode)))
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.ARG, nnode)))
					//////////
					val jnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.POSS, jnode)))
					///////////
					ret = new Schema(xnode, xxnode, Set.empty) :: ret
				}
				def func2(r1: SemRole, r2: SemRole) {
					val jnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.POSS, jnode)))
					///////////
					val ynode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) || xword.samePolarity(adj)
					}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(noun) && x.intoR == r1
					}, Set((r2, ynode)))
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xxnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xxnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.ARG, nnode)))
					//////////
					ret = new Schema(xxnode, xnode, Set.empty) :: ret
				}
				def func3(r1: SemRole, r2: SemRole, r3: SemRole) {
					val ynode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) || xword.samePolarity(adj)
					}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(noun) && x.intoR == r1
					}, Set((r2, ynode)))
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.ARG, nnode)))
					//////////
					val rnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val znode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "V" && x.intoR == r3
					}, Set((SemRole.THG, rnode)))
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.ARG, znode)))
					///////////
					ret = new Schema(xnode, xxnode, Set.empty) :: ret
				}
				def func4(r1: SemRole, r2: SemRole, r3: SemRole) {
					val rnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val znode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "V" && x.intoR == r3
					}, Set((SemRole.THG, rnode)))
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.ARG, znode)))
					///////////
					val ynode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) || xword.samePolarity(adj)
					}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(noun) && x.intoR == r1
					}, Set((r2, ynode)))
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xxnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xxnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.ARG, nnode)))
					//////////
					ret = new Schema(xxnode, xnode, Set.empty) :: ret
				}
				
				func1(SemRole.POSS, SemRole.POSS)
				func2(SemRole.POSS, SemRole.POSS)
				func1(SemRole.POSS, SemRole.ARG)
				func2(SemRole.POSS, SemRole.ARG)
				func1(SemRole.ARG, SemRole.POSS)
				func2(SemRole.ARG, SemRole.POSS)
				
				func3(SemRole.POSS, SemRole.POSS, SemRole.SBJ)
				func4(SemRole.POSS, SemRole.POSS, SemRole.SBJ)
				func3(SemRole.POSS, SemRole.ARG, SemRole.SBJ)
				func4(SemRole.POSS, SemRole.ARG, SemRole.SBJ)
				func3(SemRole.ARG, SemRole.POSS, SemRole.SBJ)
				func4(SemRole.ARG, SemRole.POSS, SemRole.SBJ)
				
				func3(SemRole.POSS, SemRole.POSS, SemRole.OBJ)
				func4(SemRole.POSS, SemRole.POSS, SemRole.OBJ)
				func3(SemRole.POSS, SemRole.ARG, SemRole.OBJ)
				func4(SemRole.POSS, SemRole.ARG, SemRole.OBJ)
				func3(SemRole.ARG, SemRole.POSS, SemRole.OBJ)
				func4(SemRole.ARG, SemRole.POSS, SemRole.OBJ)
				
			}
			*/
			def vnrelSchemas(verb: EnWord, noun: EnWord) = {
				def func1() {
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.SBJ && xword.synonymTo(verb)
						}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.ARG && xword.synonymTo(noun)
						}, Set.empty[(SemRole, MNode)])
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "V" && x.intoR == SemRole.SBJ
						}, Set((SemRole.OBJ, nnode)))
					ret = new Schema(vnode, xnode, Set((vnode, SemRole.THG, nnode, SemRole.POSS))) :: ret
				}
				def func2() {
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.SBJ && xword.synonymTo(verb)
						}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.ARG && xword.synonymTo(noun)
						}, Set.empty[(SemRole, MNode)])
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "V" && x.intoR == SemRole.SBJ
						}, Set((SemRole.OBJ, nnode)))
					ret = new Schema(xnode, vnode, Set((nnode, SemRole.POSS, vnode, SemRole.THG))) :: ret
				}
				def func3() {
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG
						}, Set.empty[(SemRole, MNode)])
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.SBJ && xword.synonymTo(verb)
						}, Set((SemRole.OBJ, xnode)))
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG && 
								xnode.currentMatch.term.word.isInstanceOf[EnWord] && {
								val tmp = xnode.currentMatch.term.word.asInstanceOf[EnWord]
								xword.synonymTo(tmp) || tmp.hyponymOf(xword)
							}
						}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.ARG && xword.synonymTo(noun)
						}, Set((SemRole.POSS, xxnode)))
					ret = new Schema(vnode, nnode, Set((vnode, SemRole.THG, nnode, SemRole.POSS))) :: ret
				}
				def func4() {
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG
						}, Set.empty[(SemRole, MNode)])
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.ARG && xword.synonymTo(noun)
						}, Set((SemRole.POSS, xxnode)))
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG && 
								xxnode.currentMatch.term.word.isInstanceOf[EnWord] && {
								val tmp = xxnode.currentMatch.term.word.asInstanceOf[EnWord]
								xword.synonymTo(tmp) || tmp.hyponymOf(xword)
							}
						}, Set.empty[(SemRole, MNode)])
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.SBJ && xword.synonymTo(verb)
						}, Set((SemRole.OBJ, xnode)))
					ret = new Schema(nnode, vnode, Set((nnode, SemRole.POSS, vnode, SemRole.THG))) :: ret
				}
				
				def func5() {
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.OBJ && xword.synonymTo(verb)
						}, Set.empty)
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG
						}, Set((SemRole.ARG, vnode)))
					
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.POSS && xword.synonymTo(noun)
						}, Set.empty)
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG && 
								xnode.currentMatch.term.word.isInstanceOf[EnWord] && {
								val tmp = xnode.currentMatch.term.word.asInstanceOf[EnWord]
								xword.synonymTo(tmp) || tmp.hyponymOf(xword)
							}
						}, Set((SemRole.ARG, nnode)))
					ret = new Schema(xnode, xxnode, Set((vnode, SemRole.THG, nnode, SemRole.POSS), (vnode, SemRole.SBJ, nnode, SemRole.ARG))) :: ret
				}
				
				def func6() {
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.POSS && xword.synonymTo(noun)
						}, Set.empty)
					
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG
						}, Set((SemRole.ARG, nnode)))
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							x.intoR == SemRole.OBJ && xword.synonymTo(verb)
						}, Set.empty)
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
							val xword = x.term.word.asInstanceOf[EnWord]
							xword.mypos == "N" && x.intoR == SemRole.ARG && 
								xxnode.currentMatch.term.word.isInstanceOf[EnWord] && {
								val tmp = xxnode.currentMatch.term.word.asInstanceOf[EnWord]
								xword.synonymTo(tmp) || tmp.hyponymOf(xword)
							}
						}, Set((SemRole.ARG, vnode)))
					ret = new Schema(xxnode, xnode, Set((nnode, SemRole.POSS, vnode, SemRole.THG), (nnode, SemRole.ARG, vnode, SemRole.SBJ))) :: ret
				}
				
				func1()
				func2()
				//func3()
				//func4()
				func5()
				func6()
			}
			
			def pertSchemas(adj: EnWord, noun: EnWord) = {
				
				def func1() {
					val jnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val ynode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.POSS, jnode)))
					/////////////
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(noun) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					/////////////
					ret = new Schema(ynode, nnode, Set.empty) :: ret
					ret = new Schema(nnode, ynode, Set.empty) :: ret
				}
				def func2(xpos: String, r1: SemRole) {
					val jnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val ynode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.POSS, jnode)))
					/////////////
					val nnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(noun) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == xpos && x.intoR == r1
					}, Set((SemRole.POSS, nnode)))
					/////////////
					ret = new Schema(ynode, xnode, Set.empty) :: ret
					ret = new Schema(xnode, ynode, Set.empty) :: ret
				}
				
				func1()
				func2("N", SemRole.ARG)
				func2("V", SemRole.SBJ)
				func2("V", SemRole.OBJ)
			}
			
			def vjrelSchemas(verb: EnWord, adj: EnWord) = {
				
				def func1() {
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(verb) && x.intoR == SemRole.SBJ
					}, Set.empty[(SemRole, MNode)])
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.ARG, vnode)))
					///////////////////
					val jnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.POSS, jnode)))
					///////////
					ret = new Schema(xnode, xxnode, Set.empty) :: ret
				}
				def func2() {
					val jnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.POSS, jnode)))
					///////////
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(verb) && x.intoR == SemRole.SBJ
					}, Set.empty[(SemRole, MNode)])
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xxnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xxnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.ARG, vnode)))
					///////////////////
					ret = new Schema(xxnode, xnode, Set.empty) :: ret
				}
				def func3(r3: SemRole) {
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(verb) && x.intoR == SemRole.SBJ
					}, Set.empty[(SemRole, MNode)])
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.ARG, vnode)))
					///////////////////
					val rnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val znode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "V" && x.intoR == r3
					}, Set((SemRole.THG, rnode)))
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.ARG, znode)))
					///////////
					ret = new Schema(xnode, xxnode, Set.empty) :: ret
				}
				def func4(r3: SemRole) {
					val rnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(adj) && x.intoR == SemRole.ARG
					}, Set.empty[(SemRole, MNode)])
					val znode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "V" && x.intoR == r3
					}, Set((SemRole.THG, rnode)))
					val xxnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG
					}, Set((SemRole.ARG, znode)))
					///////////
					val vnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.synonymTo(verb) && x.intoR == SemRole.SBJ
					}, Set.empty[(SemRole, MNode)])
					val xnode = new MNode((x:PI) => x.term.word.isInstanceOf[EnWord] && {
						val xword = x.term.word.asInstanceOf[EnWord]
						xword.mypos == "N" && x.intoR == SemRole.ARG && 
							xxnode.currentMatch.term.word.isInstanceOf[EnWord] && {
							val tmp = xxnode.currentMatch.term.word.asInstanceOf[EnWord]
							xword.synonymTo(tmp) || tmp.hyponymOf(xword)
						}
					}, Set((SemRole.ARG, vnode)))
					///////////////////
					ret = new Schema(xxnode, xnode, Set.empty) :: ret
				}
				
				func1()
				func2()
				
				func3(SemRole.SBJ)
				func4(SemRole.SBJ)
				
				func3(SemRole.OBJ)
				func4(SemRole.OBJ)
			}
			/*
			if (Set("J", "R").contains(mypos) && that.mypos == "N" && !(attrs intersect that.syns).isEmpty) {
				println("Attribute: " + this + " ~ " + that)
				attrSchemas(this, that)
			}
			*/
			if (mypos == "V" && that.mypos == "N" && !(deriv_rels intersect that.syns).isEmpty) {
				println("Derivationally related: " + this + " ~ " + that)
				vnrelSchemas(this, that)
			}
			if (Set("J", "R").contains(mypos) && that.mypos == "N" && (!(perts intersect that.syns).isEmpty || !(deriv_rels intersect that.syns).isEmpty)) {
				println("Pertainym: " + this + " ~ " + that)
				pertSchemas(this, that)
			}
			if (mypos == "V" && Set("J", "R").contains(that.mypos) && !(deriv_rels intersect that.syns).isEmpty) {
				println("Derivationally related: " + this + " ~ " + that)
				vjrelSchemas(this, that)
			}
			
			ret
		}
	}
	
}
