package tifmo

import resource.WordNet
import resource.NgramDist
import mylib.oneFromEach

import scala.collection.mutable
import scala.util.Sorting

package knowledge {
	
	class EnWord(val sidx: Int, val idx: Int, val surf: String, val pos: String, 
		val ner: String, val lex: String, val nm: String, val cid: String, val sign: Boolean) extends WordInfo {
		
		override val hashCode = (sidx, idx, surf, sign).hashCode
		override def equals(a: Any) = {
			if (a.isInstanceOf[EnWord]) {
				val that = a.asInstanceOf[EnWord]
				sidx == that.sidx && idx == that.idx && sign == that.sign && 
					surf == that.surf && pos == that.pos && ner == that.ner && 
					lex == that.lex && nm == that.nm && cid == that.cid
			} else {
				false
			}
		}
		override val toString = (if (sign) "" else "(-)") + surf
		
		val isPronoun = (pos.length >= 2) && (pos.substring(0, 2) == "PR")
		
		lazy val neg = {
			assert(sign)
			new EnWord(sidx, idx, surf, pos, ner, lex, nm, cid, false)
		}
		
		lazy val wordSynSets = WordNet.synsets(lex, pos)
		
		lazy val antSynSets = wordSynSets.flatMap(WordNet.getAntonymSynsets(_))
		
		lazy val hyperSynSets = wordSynSets.flatMap(WordNet.getHyperSynsets(_)).flatMap(WordNet.getHyperSynsets(_)) //.flatMap(WordNet.getHyperSynsets(_))
		
	}
	
	object EnWord {
	
		def lcs(a: String, b: String) = {
			val tab = Array.ofDim[Int](a.length + 1, b.length + 1)
			for (i <- 0 until a.length; j <- 0 until b.length) {
				if (a.charAt(i) == b.charAt(j)) {
					tab(i + 1)(j + 1) = tab(i)(j) + 1
				} else {
					tab(i + 1)(j + 1) = tab(i)(j + 1) max tab(i + 1)(j)
				}
			}
			tab(a.length)(b.length)
		}
		def lcsr(a: String, b: String) = 2.0 * lcs(a, b) / (a.length + b.length)
		
		def judgeSynonym(a: EnWord, b: EnWord) = {
			if (a.sign && !b.sign) {
				!(b.antSynSets intersect a.wordSynSets).isEmpty
			} else if (!a.sign && b.sign) {
				!(a.antSynSets intersect b.wordSynSets).isEmpty
			} else {
				lcsr(a.lex, b.lex) > 0.9 || !(a.wordSynSets intersect b.wordSynSets).isEmpty
			}
		}
		
		def judgeAntonym(a: EnWord, b: EnWord) = a.sign && b.sign && {
			!(a.antSynSets intersect b.wordSynSets).isEmpty || !(b.antSynSets intersect a.wordSynSets).isEmpty
		}
		
		def judgeHypernym(a: EnWord, b: EnWord) = (a.sign == b.sign) && {
			if (a.sign) {
				!(a.hyperSynSets intersect b.wordSynSets).isEmpty
			} else {
				!(b.hyperSynSets intersect a.wordSynSets).isEmpty
			}
		}
		
		private[this] val ngram = new NgramDist(5, 40)
		def cossim(aws: Set[EnWord], bws: Set[EnWord], 
				cache: mutable.Map[List[Set[String]], (mutable.Map[String, Long], Double)]) = {
			
			def norm(x: mutable.Map[String, Long]) = {
				if (x.isEmpty) {
					1.0
				} else {
					var retsq = 0.0
					for ((k, v) <- x) {
						retsq += v * v
					}
					math.sqrt(retsq)
				}
			}
			
			def lookup(sss: List[Set[String]]) = {
				if (cache.contains(sss)) {
					cache(sss)
				} else {
					val tmp = mutable.Map.empty[String, Long]
					for (l <- oneFromEach[String](sss)) {
						ngram.get(l.mkString("", " ", ""), tmp)
					}
					val ret = (tmp, norm(tmp))
					cache(sss) = ret
					ret
				}
			}
			
			def surflex(ws: Set[EnWord]) = {
				val wl = ws.toList
				val wlm = wl.map(x => Set((if (x.ner == "O") x.surf.toLowerCase else x.surf), x.lex))
				Sorting.stableSort[Set[String], (String, String)](wlm, x => (x.max, x.min)).toList
			}
			
			val (adist, anorm) = lookup(surflex(aws))
			val (bdist, bnorm) = lookup(surflex(bws))
			
			val dot = {
				val ck = adist.keySet intersect bdist.keySet
				(0.0 /: ck)((a, k) => a + adist(k) * bdist(k))
			}
			
			dot / anorm / bnorm
		}
		
	}
}
