package tifmo

import resource.WordNet
import resource.NgramDist
import mylib.oneFromEach

import scala.collection.mutable

package knowledge {
	
	class EnWord(
		val surf: String,
		val ner: String,
		val sign: Boolean
	) extends WordInfo {
		
		private[this] var posvar = null:String
		def pos = posvar
		def pos_=(x: String) {
			assert(posvar == null)
			posvar = x
		}
		
		private[this] var sivar = -1
		def si = sivar
		def si_=(x: Int) {
			assert(sivar == -1)
			sivar = x
		}
		
		private[this] var wivar = -1
		def wi = wivar
		def wi_=(x: Int) {
			assert(wivar == -1)
			wivar = x
		}
		
		private[this] var lexvar = null:String
		def lex = lexvar
		def lex_=(x: String) {
			assert(lexvar == null)
			lexvar = x
		}
		
		override lazy val hashCode = (surf, ner, sign, pos, si, wi, lex).hashCode
		override def equals(a: Any) = {
			if (a.isInstanceOf[EnWord]) {
				val that = a.asInstanceOf[EnWord]
				surf == that.surf && ner == that.ner && sign == that.sign && pos == that.pos && si == that.si && wi == that.wi && lex == that.lex
			} else {
				false
			}
		}
		
		def isPronoun = (pos.length >= 2) && (pos.substring(0, 2) == "PR")
		
		lazy val neg = {
			assert(sign)
			val ret = new EnWord(surf, ner, false)
			ret.pos = pos
			ret.si = si
			ret.wi = wi
			ret.lex = lex
			ret
		}
		
		override def toString = (if (sign) "" else "(-)") + surf
		
		lazy val wordSynSets = WordNet.synsets(lex, pos)
		
		lazy val antSynSets = wordSynSets.flatMap(WordNet.getAntonymSynsets(_))
		
		lazy val hyperSynSets = wordSynSets.flatMap(WordNet.getHyperSynsets(_)).flatMap(WordNet.getHyperSynsets(_)).flatMap(WordNet.getHyperSynsets(_))
		
	}
	
	object EnWord {
	
		def lcs(a: String, b: String) = {
			val tab = Array.ofDim[Int](a.length + 1, b.length + 1)
			for (i <- 0 until a.length; j <- 0 until b.length) {
				if (a.charAt(i) == b.charAt(j)) {
					tab(i + 1)(j + 1) = tab(i)(j) + 1
				} else {
					tab(i + 1)(j + 1) = tab(i)(j + 1) max tab(i + 1)(j)
				}
			}
			tab(a.length)(b.length)
		}
		def lcsr(a: String, b: String) = 2.0 * lcs(a, b) / (a.length + b.length)
		
		def judgeSynonym(a: EnWord, b: EnWord) = {
			if (a.sign && !b.sign) {
				!(b.antSynSets intersect a.wordSynSets).isEmpty
			} else if (!a.sign && b.sign) {
				!(a.antSynSets intersect b.wordSynSets).isEmpty
			} else {
				lcsr(a.lex, b.lex) > 0.9 || !(a.wordSynSets intersect b.wordSynSets).isEmpty
			}
		}
		
		def judgeAntonym(a: EnWord, b: EnWord) = a.sign && b.sign && {
			!(a.antSynSets intersect b.wordSynSets).isEmpty || !(b.antSynSets intersect a.wordSynSets).isEmpty
		}
		
		def judgeHypernym(a: EnWord, b: EnWord) = (a.sign == b.sign) && {
			if (a.sign) {
				!(a.hyperSynSets intersect b.wordSynSets).isEmpty
			} else {
				!(b.hyperSynSets intersect a.wordSynSets).isEmpty
			}
		}
		
		private[this] val ngram = new NgramDist(5, 40)
		def cossim(aws: Set[EnWord], bws: Set[EnWord], 
				acache: mutable.Map[Set[EnWord], (mutable.Map[String, Long], Double)], 
				bcache: mutable.Map[Set[EnWord], (mutable.Map[String, Long], Double)]) = {
			
			def norm(x: mutable.Map[String, Long]) = {
				var retsq = 0.0
				for ((k, v) <- x) {
					retsq += v * v
				}
				math.sqrt(retsq)
			}
			
			val (adist, anorm) = if (acache.contains(aws)) {
				acache(aws)
			} else {
				val tmp = mutable.Map.empty[String, Long]
				val awll = aws.toList.map(x => Set((if (x.ner == "O") x.surf.toLowerCase else x.surf), x.lex))
				for (l <- oneFromEach[String](awll)) {
					ngram.get(l.mkString("", " ", ""), tmp)
				}
				if (tmp.isEmpty) {
					acache(aws) = (tmp, 1.0)
					(tmp, 1.0)
				} else {
					val tmpnorm = norm(tmp)
					acache(aws) = (tmp, tmpnorm)
					(tmp, tmpnorm)
				}
			}
			
			val (bdist, bnorm) = if (bcache.contains(bws)) {
				bcache(bws)
			} else {
				val tmp = mutable.Map.empty[String, Long]
				val bwll = bws.toList.map(x => Set((if (x.ner == "O") x.surf.toLowerCase else x.surf), x.lex))
				for (l <- oneFromEach[String](bwll)) {
					ngram.get(l.mkString("", " ", ""), tmp)
				}
				if (tmp.isEmpty) {
					bcache(bws) = (tmp, 1.0)
					(tmp, 1.0)
				} else {
					val tmpnorm = norm(tmp)
					bcache(bws) = (tmp, tmpnorm)
					(tmp, tmpnorm)
				}
			}
			
			val dot = {
				val ck = adist.keySet intersect bdist.keySet
				(0.0 /: ck)((a, k) => a + adist(k) * bdist(k))
			}
			
			dot / anorm / bnorm
		}
		
	}
}
