package tifmo

import inference.IEWord
import inference.SemRole

import scala.collection.mutable

package stree {
	
	class Document(
		val sents: List[Sentence]
	) extends Serializable {
		
		private[stree] def meaning(getRs: (IEWord) => Set[SemRole]) = {
			val maxCorefCopy = 5
			
			val corefHeads = mutable.Map.empty[String, Set[IEWord]]
			val corefSents = mutable.Map.empty[String, Int]
			for (sent <- sents) {
				val ids = mutable.Set.empty[String]
				for (n <- sent.nodes) {
					val tmp = n.token.corefid
					if (tmp != null) {
						if (!n.token.word.isStopWord) {
							corefHeads(tmp) = corefHeads.getOrElse(tmp, Set.empty[IEWord]) + n.token.word
						}
						ids += tmp
					}
				}
				for (id <- ids) corefSents(id) = corefSents.getOrElse(id, 0) + 1
			}
			
			val corefPool = mutable.Map.empty[String, Set[(SemRole, Item)]]
			val getCoref = (x: String) => corefPool.getOrElse(x, Set.empty[(SemRole, Item)])
			val setCoref = (k: String, v: Set[(SemRole, Item)]) => if (corefHeads.contains(k) && corefSents(k) < maxCorefCopy) corefPool(k) = v
			
			val getWD = (n: STreeNode) => {
				if (n.token.corefid == null) {
					if (n.token.word.isStopWord) {
						(WORD(Set.empty[IEWord], n.locRoles, n), Set.empty[SemRole])
					} else {
						val getrs = getRs(n.token.word)
						(WORD(Set(n.token.word), getrs ++ n.locRoles, n), n.locRoles -- getrs)
					}
				} else {
					if (!corefHeads.contains(n.token.corefid)) {
						(WORD(Set.empty[IEWord], n.locRoles, n), Set.empty[SemRole])
					} else {
						val ws = corefHeads(n.token.corefid)
						val tmp = ws.map(getRs(_))
						val rs = tmp.head.filter(r => tmp.forall(_.contains(r)))
						val crs = getCoref(n.token.corefid).map(_._1)
						(WORD(ws, rs ++ n.locRoles ++ crs, n), n.locRoles ++ crs -- rs)
					}
				}
			}
			
			(for (sent <- sents) yield {
				sent.meaning(getWD, getCoref, setCoref)
			}).flatten
		}
		
		def contentWords[T <: IEWord] = {
			allWords[T].filter(!_.isStopWord)
		}
		
		def allWords[T <: IEWord] = sents.flatMap(_.allWords[T]).toSet
		
		def toXML = {
<Document>
	{sents.map(_.toXML)}
</Document>
		}
	}
	
	object Document {
		
		def fromXML(x: xml.Node, wr: WordReader, rr: RoleReader, sr: SlctReader = DefaultSlctReader) = {
			assert(x.label == "Document")
			val sents = (for (sent <- x \ "Sentence") yield {
				Sentence.fromXML(sent, wr, rr, sr)
			}).toList
			new Document(sents)
		}
	}
	
}
