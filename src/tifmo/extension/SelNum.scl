package tifmo

import inference.IETerm
import inference.IEngine
import inference.Relation
import inference.RuleFunc
import inference.FuncArg
import inference.FAConversion._
import inference.IEPredNonEmpty
import inference.IEPredSubsume
import inference.IEPredRL

import inference.Debug_SimpleRuleTrace

package stree {
	
	case class SelNum(num: String) extends Slction {
		
		def applyRL(ie: IEngine, a: IETerm, b: IETerm) {
			ie.ifNotEmpty(a, List(this, b), rSelNum2)
		}
	}
	
	private[stree] object rSelNum0 extends RuleFunc[IEPredRL] {
		def apply(ie: IEngine, pred: IEPredRL, args: List[FuncArg]) {
			args match {
				case FuncArg(a:IETerm) :: FuncArg(rl:Relation) :: Nil => {
					
					//System.err.println("rSelNum0: " + rl + " " + a + " " + pred)
					
					if (pred.rl == rl) {
						
						ie.claimSubsume(a, pred.a)
						ie.claimSubsume(pred.a, a)
					}
				}
				case _ => throw new Exception("rSelNum0 error!")
			}
		}
	}
	
	private[stree] object rSelNum1 extends RuleFunc[IEPredSubsume] {
		def apply(ie: IEngine, pred: IEPredSubsume, args: List[FuncArg]) {
			args match {
				case FuncArg(a:IETerm) :: FuncArg(rl:Relation) :: Nil => {
					
					//System.err.println("rSelNum1: " + rl + " " + a + " " + pred)
					
					ie.foreachXRLB(pred.superset, args, rSelNum0)
				}
				case _ => throw new Exception("rSelNum1 error!")
			}
		}
	}
	
	private[stree] object rSelNum2 extends RuleFunc[IEPredNonEmpty] {
		def apply(ie: IEngine, pred: IEPredNonEmpty, args: List[FuncArg]) {
			args match {
				case FuncArg(rl:Relation) :: FuncArg(b:IETerm) :: Nil => {
					
					//System.err.println("rSelNum2: " + rl + " " + b + " " + pred)
					
					ie.foreachSuperset(b, List(pred.term, rl), rSelNum1)
				}
				case _ => throw new Exception("rSelNum2 error!")
			}
		}
	}
	
}
