package rite.main


import scala.collection.mutable

package mylib {
	
	object listCoverings {
		
		def apply[T](tocover: Set[T], toavoid: Set[Set[T]], subsets: Set[Set[T]]) = {
			
			def recurse(a: Set[T], b: Set[Set[T]], ss: Set[Set[T]]): List[List[Set[T]]] = {
				var ret = Nil:List[List[Set[T]]]
				
				var cc = a.map(x => ss.filter(_.contains(x))).minBy[Int](_.size)
				val rest = ss -- cc
				
				while(!cc.isEmpty) {
					if (!b.exists(_.subsetOf(cc.head))) {
						if (a.subsetOf(cc.head)) {
							ret = List(cc.head) :: ret
						} else {
							val (in, out) = a.partition(cc.head.contains(_))
							for (x <- recurse(out, b.map(_ -- cc.head) + in, rest ++ cc.tail)) {
								ret = (cc.head :: x) :: ret
							}
						}
					}
					cc = cc.tail
				}
				
				ret
			}
			
			def once(a: Set[T], b: Set[Set[T]], ss: Set[Set[T]]): List[List[Set[T]]] = {
				
				var ret = Nil:List[List[Set[T]]]
				
				var cc = a.map(x => ss.filter(_.contains(x))).minBy[Int](_.size)
				val rest = ss -- cc
				
				var stop = false
				while(!cc.isEmpty && !stop) {
					if (!b.exists(_.subsetOf(cc.head))) {
						if (a.subsetOf(cc.head)) {
							ret = List(cc.head) :: ret
							stop = true
						} else {
							val (in, out) = a.partition(cc.head.contains(_))
							for (x <- once(out, b.map(_ -- cc.head) + in, rest ++ cc.tail)) {
								ret = (cc.head :: x) :: ret
								stop = true
							}
						}
					}
					cc = cc.tail
				}
				
				ret
			}
			
			if (tocover.isEmpty) {
				List(Nil)
			} else {
				if (tocover.size > 30) {
					once(tocover, toavoid, subsets)
				} else {
					recurse(tocover, toavoid, subsets)
				}
			}
		}
	}
}
